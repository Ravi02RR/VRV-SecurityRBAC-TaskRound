const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["assets/Login-BGRZ3ENH.js", "assets/shield-DHy16W9h.js", "assets/copy-C-A97iw0.js", "assets/Signup-BPlnPFWT.js", "assets/Home-CxFjwrMi.js", "assets/search-CT8D7kA1.js", "assets/trash-2-Bbf5WKSm.js", "assets/Profile-BklSzYE6.js", "assets/AdminDashboard-DNovdMO1.js", "assets/PostDetail-C3Av3PFg.js"]))) => i.map(i => d[i]);
var j0 = Object.defineProperty; var I0 = (t, r, i) => r in t ? j0(t, r, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[r] = i; var Oh = (t, r, i) => I0(t, typeof r != "symbol" ? r + "" : r, i); (function () { const r = document.createElement("link").relList; if (r && r.supports && r.supports("modulepreload")) return; for (const l of document.querySelectorAll('link[rel="modulepreload"]')) s(l); new MutationObserver(l => { for (const f of l) if (f.type === "childList") for (const u of f.addedNodes) u.tagName === "LINK" && u.rel === "modulepreload" && s(u) }).observe(document, { childList: !0, subtree: !0 }); function i(l) { const f = {}; return l.integrity && (f.integrity = l.integrity), l.referrerPolicy && (f.referrerPolicy = l.referrerPolicy), l.crossOrigin === "use-credentials" ? f.credentials = "include" : l.crossOrigin === "anonymous" ? f.credentials = "omit" : f.credentials = "same-origin", f } function s(l) { if (l.ep) return; l.ep = !0; const f = i(l); fetch(l.href, f) } })(); function km(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var ql = { exports: {} }, Mi = {}, Gl = { exports: {} }, ue = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Nh; function B0() { if (Nh) return ue; Nh = 1; var t = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), f = Symbol.for("react.provider"), u = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), m = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), v = Symbol.iterator; function w(L) { return L === null || typeof L != "object" ? null : (L = v && L[v] || L["@@iterator"], typeof L == "function" ? L : null) } var C = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, S = Object.assign, R = {}; function P(L, j, ae) { this.props = L, this.context = j, this.refs = R, this.updater = ae || C } P.prototype.isReactComponent = {}, P.prototype.setState = function (L, j) { if (typeof L != "object" && typeof L != "function" && L != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, L, j, "setState") }, P.prototype.forceUpdate = function (L) { this.updater.enqueueForceUpdate(this, L, "forceUpdate") }; function A() { } A.prototype = P.prototype; function N(L, j, ae) { this.props = L, this.context = j, this.refs = R, this.updater = ae || C } var F = N.prototype = new A; F.constructor = N, S(F, P.prototype), F.isPureReactComponent = !0; var b = Array.isArray, z = Object.prototype.hasOwnProperty, Y = { current: null }, ne = { key: !0, ref: !0, __self: !0, __source: !0 }; function Q(L, j, ae) { var ce, de = {}, he = null, we = null; if (j != null) for (ce in j.ref !== void 0 && (we = j.ref), j.key !== void 0 && (he = "" + j.key), j) z.call(j, ce) && !ne.hasOwnProperty(ce) && (de[ce] = j[ce]); var ye = arguments.length - 2; if (ye === 1) de.children = ae; else if (1 < ye) { for (var Pe = Array(ye), dt = 0; dt < ye; dt++)Pe[dt] = arguments[dt + 2]; de.children = Pe } if (L && L.defaultProps) for (ce in ye = L.defaultProps, ye) de[ce] === void 0 && (de[ce] = ye[ce]); return { $$typeof: t, type: L, key: he, ref: we, props: de, _owner: Y.current } } function se(L, j) { return { $$typeof: t, type: L.type, key: j, ref: L.ref, props: L.props, _owner: L._owner } } function me(L) { return typeof L == "object" && L !== null && L.$$typeof === t } function Ue(L) { var j = { "=": "=0", ":": "=2" }; return "$" + L.replace(/[=:]/g, function (ae) { return j[ae] }) } var ft = /\/+/g; function Ze(L, j) { return typeof L == "object" && L !== null && L.key != null ? Ue("" + L.key) : j.toString(36) } function rt(L, j, ae, ce, de) { var he = typeof L; (he === "undefined" || he === "boolean") && (L = null); var we = !1; if (L === null) we = !0; else switch (he) { case "string": case "number": we = !0; break; case "object": switch (L.$$typeof) { case t: case r: we = !0 } }if (we) return we = L, de = de(we), L = ce === "" ? "." + Ze(we, 0) : ce, b(de) ? (ae = "", L != null && (ae = L.replace(ft, "$&/") + "/"), rt(de, j, ae, "", function (dt) { return dt })) : de != null && (me(de) && (de = se(de, ae + (!de.key || we && we.key === de.key ? "" : ("" + de.key).replace(ft, "$&/") + "/") + L)), j.push(de)), 1; if (we = 0, ce = ce === "" ? "." : ce + ":", b(L)) for (var ye = 0; ye < L.length; ye++) { he = L[ye]; var Pe = ce + Ze(he, ye); we += rt(he, j, ae, Pe, de) } else if (Pe = w(L), typeof Pe == "function") for (L = Pe.call(L), ye = 0; !(he = L.next()).done;)he = he.value, Pe = ce + Ze(he, ye++), we += rt(he, j, ae, Pe, de); else if (he === "object") throw j = String(L), Error("Objects are not valid as a React child (found: " + (j === "[object Object]" ? "object with keys {" + Object.keys(L).join(", ") + "}" : j) + "). If you meant to render a collection of children, use an array instead."); return we } function Rt(L, j, ae) { if (L == null) return L; var ce = [], de = 0; return rt(L, ce, "", "", function (he) { return j.call(ae, he, de++) }), ce } function et(L) { if (L._status === -1) { var j = L._result; j = j(), j.then(function (ae) { (L._status === 0 || L._status === -1) && (L._status = 1, L._result = ae) }, function (ae) { (L._status === 0 || L._status === -1) && (L._status = 2, L._result = ae) }), L._status === -1 && (L._status = 0, L._result = j) } if (L._status === 1) return L._result.default; throw L._result } var le = { current: null }, $ = { transition: null }, Z = { ReactCurrentDispatcher: le, ReactCurrentBatchConfig: $, ReactCurrentOwner: Y }; function K() { throw Error("act(...) is not supported in production builds of React.") } return ue.Children = { map: Rt, forEach: function (L, j, ae) { Rt(L, function () { j.apply(this, arguments) }, ae) }, count: function (L) { var j = 0; return Rt(L, function () { j++ }), j }, toArray: function (L) { return Rt(L, function (j) { return j }) || [] }, only: function (L) { if (!me(L)) throw Error("React.Children.only expected to receive a single React element child."); return L } }, ue.Component = P, ue.Fragment = i, ue.Profiler = l, ue.PureComponent = N, ue.StrictMode = s, ue.Suspense = p, ue.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Z, ue.act = K, ue.cloneElement = function (L, j, ae) { if (L == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + L + "."); var ce = S({}, L.props), de = L.key, he = L.ref, we = L._owner; if (j != null) { if (j.ref !== void 0 && (he = j.ref, we = Y.current), j.key !== void 0 && (de = "" + j.key), L.type && L.type.defaultProps) var ye = L.type.defaultProps; for (Pe in j) z.call(j, Pe) && !ne.hasOwnProperty(Pe) && (ce[Pe] = j[Pe] === void 0 && ye !== void 0 ? ye[Pe] : j[Pe]) } var Pe = arguments.length - 2; if (Pe === 1) ce.children = ae; else if (1 < Pe) { ye = Array(Pe); for (var dt = 0; dt < Pe; dt++)ye[dt] = arguments[dt + 2]; ce.children = ye } return { $$typeof: t, type: L.type, key: de, ref: he, props: ce, _owner: we } }, ue.createContext = function (L) { return L = { $$typeof: u, _currentValue: L, _currentValue2: L, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, L.Provider = { $$typeof: f, _context: L }, L.Consumer = L }, ue.createElement = Q, ue.createFactory = function (L) { var j = Q.bind(null, L); return j.type = L, j }, ue.createRef = function () { return { current: null } }, ue.forwardRef = function (L) { return { $$typeof: h, render: L } }, ue.isValidElement = me, ue.lazy = function (L) { return { $$typeof: y, _payload: { _status: -1, _result: L }, _init: et } }, ue.memo = function (L, j) { return { $$typeof: m, type: L, compare: j === void 0 ? null : j } }, ue.startTransition = function (L) { var j = $.transition; $.transition = {}; try { L() } finally { $.transition = j } }, ue.unstable_act = K, ue.useCallback = function (L, j) { return le.current.useCallback(L, j) }, ue.useContext = function (L) { return le.current.useContext(L) }, ue.useDebugValue = function () { }, ue.useDeferredValue = function (L) { return le.current.useDeferredValue(L) }, ue.useEffect = function (L, j) { return le.current.useEffect(L, j) }, ue.useId = function () { return le.current.useId() }, ue.useImperativeHandle = function (L, j, ae) { return le.current.useImperativeHandle(L, j, ae) }, ue.useInsertionEffect = function (L, j) { return le.current.useInsertionEffect(L, j) }, ue.useLayoutEffect = function (L, j) { return le.current.useLayoutEffect(L, j) }, ue.useMemo = function (L, j) { return le.current.useMemo(L, j) }, ue.useReducer = function (L, j, ae) { return le.current.useReducer(L, j, ae) }, ue.useRef = function (L) { return le.current.useRef(L) }, ue.useState = function (L) { return le.current.useState(L) }, ue.useSyncExternalStore = function (L, j, ae) { return le.current.useSyncExternalStore(L, j, ae) }, ue.useTransition = function () { return le.current.useTransition() }, ue.version = "18.3.1", ue } var Fh; function Wu() { return Fh || (Fh = 1, Gl.exports = B0()), Gl.exports }/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Vh; function z0() { if (Vh) return Mi; Vh = 1; var t = Wu(), r = Symbol.for("react.element"), i = Symbol.for("react.fragment"), s = Object.prototype.hasOwnProperty, l = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, f = { key: !0, ref: !0, __self: !0, __source: !0 }; function u(h, p, m) { var y, v = {}, w = null, C = null; m !== void 0 && (w = "" + m), p.key !== void 0 && (w = "" + p.key), p.ref !== void 0 && (C = p.ref); for (y in p) s.call(p, y) && !f.hasOwnProperty(y) && (v[y] = p[y]); if (h && h.defaultProps) for (y in p = h.defaultProps, p) v[y] === void 0 && (v[y] = p[y]); return { $$typeof: r, type: h, key: w, ref: C, props: v, _owner: l.current } } return Mi.Fragment = i, Mi.jsx = u, Mi.jsxs = u, Mi } var jh; function U0() { return jh || (jh = 1, ql.exports = z0()), ql.exports } var H = U0(), k = Wu(); const b0 = km(k); var ds = {}, Ql = { exports: {} }, ut = {}, Xl = { exports: {} }, Yl = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ih; function $0() { return Ih || (Ih = 1, function (t) { function r($, Z) { var K = $.length; $.push(Z); e: for (; 0 < K;) { var L = K - 1 >>> 1, j = $[L]; if (0 < l(j, Z)) $[L] = Z, $[K] = j, K = L; else break e } } function i($) { return $.length === 0 ? null : $[0] } function s($) { if ($.length === 0) return null; var Z = $[0], K = $.pop(); if (K !== Z) { $[0] = K; e: for (var L = 0, j = $.length, ae = j >>> 1; L < ae;) { var ce = 2 * (L + 1) - 1, de = $[ce], he = ce + 1, we = $[he]; if (0 > l(de, K)) he < j && 0 > l(we, de) ? ($[L] = we, $[he] = K, L = he) : ($[L] = de, $[ce] = K, L = ce); else if (he < j && 0 > l(we, K)) $[L] = we, $[he] = K, L = he; else break e } } return Z } function l($, Z) { var K = $.sortIndex - Z.sortIndex; return K !== 0 ? K : $.id - Z.id } if (typeof performance == "object" && typeof performance.now == "function") { var f = performance; t.unstable_now = function () { return f.now() } } else { var u = Date, h = u.now(); t.unstable_now = function () { return u.now() - h } } var p = [], m = [], y = 1, v = null, w = 3, C = !1, S = !1, R = !1, P = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, N = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function F($) { for (var Z = i(m); Z !== null;) { if (Z.callback === null) s(m); else if (Z.startTime <= $) s(m), Z.sortIndex = Z.expirationTime, r(p, Z); else break; Z = i(m) } } function b($) { if (R = !1, F($), !S) if (i(p) !== null) S = !0, et(z); else { var Z = i(m); Z !== null && le(b, Z.startTime - $) } } function z($, Z) { S = !1, R && (R = !1, A(Q), Q = -1), C = !0; var K = w; try { for (F(Z), v = i(p); v !== null && (!(v.expirationTime > Z) || $ && !Ue());) { var L = v.callback; if (typeof L == "function") { v.callback = null, w = v.priorityLevel; var j = L(v.expirationTime <= Z); Z = t.unstable_now(), typeof j == "function" ? v.callback = j : v === i(p) && s(p), F(Z) } else s(p); v = i(p) } if (v !== null) var ae = !0; else { var ce = i(m); ce !== null && le(b, ce.startTime - Z), ae = !1 } return ae } finally { v = null, w = K, C = !1 } } var Y = !1, ne = null, Q = -1, se = 5, me = -1; function Ue() { return !(t.unstable_now() - me < se) } function ft() { if (ne !== null) { var $ = t.unstable_now(); me = $; var Z = !0; try { Z = ne(!0, $) } finally { Z ? Ze() : (Y = !1, ne = null) } } else Y = !1 } var Ze; if (typeof N == "function") Ze = function () { N(ft) }; else if (typeof MessageChannel < "u") { var rt = new MessageChannel, Rt = rt.port2; rt.port1.onmessage = ft, Ze = function () { Rt.postMessage(null) } } else Ze = function () { P(ft, 0) }; function et($) { ne = $, Y || (Y = !0, Ze()) } function le($, Z) { Q = P(function () { $(t.unstable_now()) }, Z) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function ($) { $.callback = null }, t.unstable_continueExecution = function () { S || C || (S = !0, et(z)) }, t.unstable_forceFrameRate = function ($) { 0 > $ || 125 < $ ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : se = 0 < $ ? Math.floor(1e3 / $) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return w }, t.unstable_getFirstCallbackNode = function () { return i(p) }, t.unstable_next = function ($) { switch (w) { case 1: case 2: case 3: var Z = 3; break; default: Z = w }var K = w; w = Z; try { return $() } finally { w = K } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function ($, Z) { switch ($) { case 1: case 2: case 3: case 4: case 5: break; default: $ = 3 }var K = w; w = $; try { return Z() } finally { w = K } }, t.unstable_scheduleCallback = function ($, Z, K) { var L = t.unstable_now(); switch (typeof K == "object" && K !== null ? (K = K.delay, K = typeof K == "number" && 0 < K ? L + K : L) : K = L, $) { case 1: var j = -1; break; case 2: j = 250; break; case 5: j = 1073741823; break; case 4: j = 1e4; break; default: j = 5e3 }return j = K + j, $ = { id: y++, callback: Z, priorityLevel: $, startTime: K, expirationTime: j, sortIndex: -1 }, K > L ? ($.sortIndex = K, r(m, $), i(p) === null && $ === i(m) && (R ? (A(Q), Q = -1) : R = !0, le(b, K - L))) : ($.sortIndex = j, r(p, $), S || C || (S = !0, et(z))), $ }, t.unstable_shouldYield = Ue, t.unstable_wrapCallback = function ($) { var Z = w; return function () { var K = w; w = Z; try { return $.apply(this, arguments) } finally { w = K } } } }(Yl)), Yl } var Bh; function H0() { return Bh || (Bh = 1, Xl.exports = $0()), Xl.exports }/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var zh; function W0() {
  if (zh) return ut; zh = 1; var t = Wu(), r = H0(); function i(e) { for (var n = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, o = 1; o < arguments.length; o++)n += "&args[]=" + encodeURIComponent(arguments[o]); return "Minified React error #" + e + "; visit " + n + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var s = new Set, l = {}; function f(e, n) { u(e, n), u(e + "Capture", n) } function u(e, n) { for (l[e] = n, e = 0; e < n.length; e++)s.add(n[e]) } var h = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), p = Object.prototype.hasOwnProperty, m = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, y = {}, v = {}; function w(e) { return p.call(v, e) ? !0 : p.call(y, e) ? !1 : m.test(e) ? v[e] = !0 : (y[e] = !0, !1) } function C(e, n, o, a) { if (o !== null && o.type === 0) return !1; switch (typeof n) { case "function": case "symbol": return !0; case "boolean": return a ? !1 : o !== null ? !o.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function S(e, n, o, a) { if (n === null || typeof n > "u" || C(e, n, o, a)) return !0; if (a) return !1; if (o !== null) switch (o.type) { case 3: return !n; case 4: return n === !1; case 5: return isNaN(n); case 6: return isNaN(n) || 1 > n }return !1 } function R(e, n, o, a, c, d, g) { this.acceptsBooleans = n === 2 || n === 3 || n === 4, this.attributeName = a, this.attributeNamespace = c, this.mustUseProperty = o, this.propertyName = e, this.type = n, this.sanitizeURL = d, this.removeEmptyString = g } var P = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { P[e] = new R(e, 0, !1, e, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var n = e[0]; P[n] = new R(n, 1, !1, e[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { P[e] = new R(e, 2, !1, e.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { P[e] = new R(e, 2, !1, e, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { P[e] = new R(e, 3, !1, e.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (e) { P[e] = new R(e, 3, !0, e, null, !1, !1) }), ["capture", "download"].forEach(function (e) { P[e] = new R(e, 4, !1, e, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (e) { P[e] = new R(e, 6, !1, e, null, !1, !1) }), ["rowSpan", "start"].forEach(function (e) { P[e] = new R(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var A = /[\-:]([a-z])/g; function N(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var n = e.replace(A, N); P[n] = new R(n, 1, !1, e, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var n = e.replace(A, N); P[n] = new R(n, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var n = e.replace(A, N); P[n] = new R(n, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (e) { P[e] = new R(e, 1, !1, e.toLowerCase(), null, !1, !1) }), P.xlinkHref = new R("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (e) { P[e] = new R(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function F(e, n, o, a) { var c = P.hasOwnProperty(n) ? P[n] : null; (c !== null ? c.type !== 0 : a || !(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N") && (S(n, o, c, a) && (o = null), a || c === null ? w(n) && (o === null ? e.removeAttribute(n) : e.setAttribute(n, "" + o)) : c.mustUseProperty ? e[c.propertyName] = o === null ? c.type === 3 ? !1 : "" : o : (n = c.attributeName, a = c.attributeNamespace, o === null ? e.removeAttribute(n) : (c = c.type, o = c === 3 || c === 4 && o === !0 ? "" : "" + o, a ? e.setAttributeNS(a, n, o) : e.setAttribute(n, o)))) } var b = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, z = Symbol.for("react.element"), Y = Symbol.for("react.portal"), ne = Symbol.for("react.fragment"), Q = Symbol.for("react.strict_mode"), se = Symbol.for("react.profiler"), me = Symbol.for("react.provider"), Ue = Symbol.for("react.context"), ft = Symbol.for("react.forward_ref"), Ze = Symbol.for("react.suspense"), rt = Symbol.for("react.suspense_list"), Rt = Symbol.for("react.memo"), et = Symbol.for("react.lazy"), le = Symbol.for("react.offscreen"), $ = Symbol.iterator; function Z(e) { return e === null || typeof e != "object" ? null : (e = $ && e[$] || e["@@iterator"], typeof e == "function" ? e : null) } var K = Object.assign, L; function j(e) {
    if (L === void 0) try { throw Error() } catch (o) { var n = o.stack.trim().match(/\n( *(at )?)/); L = n && n[1] || "" } return `
`+ L + e
  } var ae = !1; function ce(e, n) {
    if (!e || ae) return ""; ae = !0; var o = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (n) if (n = function () { throw Error() }, Object.defineProperty(n.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(n, []) } catch (M) { var a = M } Reflect.construct(e, [], n) } else { try { n.call() } catch (M) { a = M } e.call(n.prototype) } else { try { throw Error() } catch (M) { a = M } e() } } catch (M) {
      if (M && a && typeof M.stack == "string") {
        for (var c = M.stack.split(`
`), d = a.stack.split(`
`), g = c.length - 1, x = d.length - 1; 1 <= g && 0 <= x && c[g] !== d[x];)x--; for (; 1 <= g && 0 <= x; g--, x--)if (c[g] !== d[x]) {
          if (g !== 1 || x !== 1) do if (g--, x--, 0 > x || c[g] !== d[x]) {
            var E = `
`+ c[g].replace(" at new ", " at "); return e.displayName && E.includes("<anonymous>") && (E = E.replace("<anonymous>", e.displayName)), E
          } while (1 <= g && 0 <= x); break
        }
      }
    } finally { ae = !1, Error.prepareStackTrace = o } return (e = e ? e.displayName || e.name : "") ? j(e) : ""
  } function de(e) { switch (e.tag) { case 5: return j(e.type); case 16: return j("Lazy"); case 13: return j("Suspense"); case 19: return j("SuspenseList"); case 0: case 2: case 15: return e = ce(e.type, !1), e; case 11: return e = ce(e.type.render, !1), e; case 1: return e = ce(e.type, !0), e; default: return "" } } function he(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case ne: return "Fragment"; case Y: return "Portal"; case se: return "Profiler"; case Q: return "StrictMode"; case Ze: return "Suspense"; case rt: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case Ue: return (e.displayName || "Context") + ".Consumer"; case me: return (e._context.displayName || "Context") + ".Provider"; case ft: var n = e.render; return e = e.displayName, e || (e = n.displayName || n.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case Rt: return n = e.displayName || null, n !== null ? n : he(e.type) || "Memo"; case et: n = e._payload, e = e._init; try { return he(e(n)) } catch { } }return null } function we(e) { var n = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (n.displayName || "Context") + ".Consumer"; case 10: return (n._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = n.render, e = e.displayName || e.name || "", n.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return n; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return he(n); case 8: return n === Q ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof n == "function") return n.displayName || n.name || null; if (typeof n == "string") return n }return null } function ye(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function Pe(e) { var n = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (n === "checkbox" || n === "radio") } function dt(e) { var n = Pe(e) ? "checked" : "value", o = Object.getOwnPropertyDescriptor(e.constructor.prototype, n), a = "" + e[n]; if (!e.hasOwnProperty(n) && typeof o < "u" && typeof o.get == "function" && typeof o.set == "function") { var c = o.get, d = o.set; return Object.defineProperty(e, n, { configurable: !0, get: function () { return c.call(this) }, set: function (g) { a = "" + g, d.call(this, g) } }), Object.defineProperty(e, n, { enumerable: o.enumerable }), { getValue: function () { return a }, setValue: function (g) { a = "" + g }, stopTracking: function () { e._valueTracker = null, delete e[n] } } } } function to(e) { e._valueTracker || (e._valueTracker = dt(e)) } function Ic(e) { if (!e) return !1; var n = e._valueTracker; if (!n) return !0; var o = n.getValue(), a = ""; return e && (a = Pe(e) ? e.checked ? "true" : "false" : e.value), e = a, e !== o ? (n.setValue(e), !0) : !1 } function no(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function ea(e, n) { var o = n.checked; return K({}, n, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: o ?? e._wrapperState.initialChecked }) } function Bc(e, n) { var o = n.defaultValue == null ? "" : n.defaultValue, a = n.checked != null ? n.checked : n.defaultChecked; o = ye(n.value != null ? n.value : o), e._wrapperState = { initialChecked: a, initialValue: o, controlled: n.type === "checkbox" || n.type === "radio" ? n.checked != null : n.value != null } } function zc(e, n) { n = n.checked, n != null && F(e, "checked", n, !1) } function ta(e, n) { zc(e, n); var o = ye(n.value), a = n.type; if (o != null) a === "number" ? (o === 0 && e.value === "" || e.value != o) && (e.value = "" + o) : e.value !== "" + o && (e.value = "" + o); else if (a === "submit" || a === "reset") { e.removeAttribute("value"); return } n.hasOwnProperty("value") ? na(e, n.type, o) : n.hasOwnProperty("defaultValue") && na(e, n.type, ye(n.defaultValue)), n.checked == null && n.defaultChecked != null && (e.defaultChecked = !!n.defaultChecked) } function Uc(e, n, o) { if (n.hasOwnProperty("value") || n.hasOwnProperty("defaultValue")) { var a = n.type; if (!(a !== "submit" && a !== "reset" || n.value !== void 0 && n.value !== null)) return; n = "" + e._wrapperState.initialValue, o || n === e.value || (e.value = n), e.defaultValue = n } o = e.name, o !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, o !== "" && (e.name = o) } function na(e, n, o) { (n !== "number" || no(e.ownerDocument) !== e) && (o == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + o && (e.defaultValue = "" + o)) } var qr = Array.isArray; function ar(e, n, o, a) { if (e = e.options, n) { n = {}; for (var c = 0; c < o.length; c++)n["$" + o[c]] = !0; for (o = 0; o < e.length; o++)c = n.hasOwnProperty("$" + e[o].value), e[o].selected !== c && (e[o].selected = c), c && a && (e[o].defaultSelected = !0) } else { for (o = "" + ye(o), n = null, c = 0; c < e.length; c++) { if (e[c].value === o) { e[c].selected = !0, a && (e[c].defaultSelected = !0); return } n !== null || e[c].disabled || (n = e[c]) } n !== null && (n.selected = !0) } } function ra(e, n) { if (n.dangerouslySetInnerHTML != null) throw Error(i(91)); return K({}, n, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function bc(e, n) { var o = n.value; if (o == null) { if (o = n.children, n = n.defaultValue, o != null) { if (n != null) throw Error(i(92)); if (qr(o)) { if (1 < o.length) throw Error(i(93)); o = o[0] } n = o } n == null && (n = ""), o = n } e._wrapperState = { initialValue: ye(o) } } function $c(e, n) { var o = ye(n.value), a = ye(n.defaultValue); o != null && (o = "" + o, o !== e.value && (e.value = o), n.defaultValue == null && e.defaultValue !== o && (e.defaultValue = o)), a != null && (e.defaultValue = "" + a) } function Hc(e) { var n = e.textContent; n === e._wrapperState.initialValue && n !== "" && n !== null && (e.value = n) } function Wc(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function ia(e, n) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Wc(n) : e === "http://www.w3.org/2000/svg" && n === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var ro, Kc = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (n, o, a, c) { MSApp.execUnsafeLocalFunction(function () { return e(n, o, a, c) }) } : e }(function (e, n) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = n; else { for (ro = ro || document.createElement("div"), ro.innerHTML = "<svg>" + n.valueOf().toString() + "</svg>", n = ro.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; n.firstChild;)e.appendChild(n.firstChild) } }); function Gr(e, n) { if (n) { var o = e.firstChild; if (o && o === e.lastChild && o.nodeType === 3) { o.nodeValue = n; return } } e.textContent = n } var Qr = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Ug = ["Webkit", "ms", "Moz", "O"]; Object.keys(Qr).forEach(function (e) { Ug.forEach(function (n) { n = n + e.charAt(0).toUpperCase() + e.substring(1), Qr[n] = Qr[e] }) }); function qc(e, n, o) { return n == null || typeof n == "boolean" || n === "" ? "" : o || typeof n != "number" || n === 0 || Qr.hasOwnProperty(e) && Qr[e] ? ("" + n).trim() : n + "px" } function Gc(e, n) { e = e.style; for (var o in n) if (n.hasOwnProperty(o)) { var a = o.indexOf("--") === 0, c = qc(o, n[o], a); o === "float" && (o = "cssFloat"), a ? e.setProperty(o, c) : e[o] = c } } var bg = K({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function oa(e, n) { if (n) { if (bg[e] && (n.children != null || n.dangerouslySetInnerHTML != null)) throw Error(i(137, e)); if (n.dangerouslySetInnerHTML != null) { if (n.children != null) throw Error(i(60)); if (typeof n.dangerouslySetInnerHTML != "object" || !("__html" in n.dangerouslySetInnerHTML)) throw Error(i(61)) } if (n.style != null && typeof n.style != "object") throw Error(i(62)) } } function sa(e, n) { if (e.indexOf("-") === -1) return typeof n.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var aa = null; function la(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var ua = null, lr = null, ur = null; function Qc(e) { if (e = gi(e)) { if (typeof ua != "function") throw Error(i(280)); var n = e.stateNode; n && (n = Ro(n), ua(e.stateNode, e.type, n)) } } function Xc(e) { lr ? ur ? ur.push(e) : ur = [e] : lr = e } function Yc() { if (lr) { var e = lr, n = ur; if (ur = lr = null, Qc(e), n) for (e = 0; e < n.length; e++)Qc(n[e]) } } function Jc(e, n) { return e(n) } function Zc() { } var ca = !1; function ef(e, n, o) { if (ca) return e(n, o); ca = !0; try { return Jc(e, n, o) } finally { ca = !1, (lr !== null || ur !== null) && (Zc(), Yc()) } } function Xr(e, n) { var o = e.stateNode; if (o === null) return null; var a = Ro(o); if (a === null) return null; o = a[n]; e: switch (n) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (a = !a.disabled) || (e = e.type, a = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !a; break e; default: e = !1 }if (e) return null; if (o && typeof o != "function") throw Error(i(231, n, typeof o)); return o } var fa = !1; if (h) try { var Yr = {}; Object.defineProperty(Yr, "passive", { get: function () { fa = !0 } }), window.addEventListener("test", Yr, Yr), window.removeEventListener("test", Yr, Yr) } catch { fa = !1 } function $g(e, n, o, a, c, d, g, x, E) { var M = Array.prototype.slice.call(arguments, 3); try { n.apply(o, M) } catch (I) { this.onError(I) } } var Jr = !1, io = null, oo = !1, da = null, Hg = { onError: function (e) { Jr = !0, io = e } }; function Wg(e, n, o, a, c, d, g, x, E) { Jr = !1, io = null, $g.apply(Hg, arguments) } function Kg(e, n, o, a, c, d, g, x, E) { if (Wg.apply(this, arguments), Jr) { if (Jr) { var M = io; Jr = !1, io = null } else throw Error(i(198)); oo || (oo = !0, da = M) } } function In(e) { var n = e, o = e; if (e.alternate) for (; n.return;)n = n.return; else { e = n; do n = e, n.flags & 4098 && (o = n.return), e = n.return; while (e) } return n.tag === 3 ? o : null } function tf(e) { if (e.tag === 13) { var n = e.memoizedState; if (n === null && (e = e.alternate, e !== null && (n = e.memoizedState)), n !== null) return n.dehydrated } return null } function nf(e) { if (In(e) !== e) throw Error(i(188)) } function qg(e) { var n = e.alternate; if (!n) { if (n = In(e), n === null) throw Error(i(188)); return n !== e ? null : e } for (var o = e, a = n; ;) { var c = o.return; if (c === null) break; var d = c.alternate; if (d === null) { if (a = c.return, a !== null) { o = a; continue } break } if (c.child === d.child) { for (d = c.child; d;) { if (d === o) return nf(c), e; if (d === a) return nf(c), n; d = d.sibling } throw Error(i(188)) } if (o.return !== a.return) o = c, a = d; else { for (var g = !1, x = c.child; x;) { if (x === o) { g = !0, o = c, a = d; break } if (x === a) { g = !0, a = c, o = d; break } x = x.sibling } if (!g) { for (x = d.child; x;) { if (x === o) { g = !0, o = d, a = c; break } if (x === a) { g = !0, a = d, o = c; break } x = x.sibling } if (!g) throw Error(i(189)) } } if (o.alternate !== a) throw Error(i(190)) } if (o.tag !== 3) throw Error(i(188)); return o.stateNode.current === o ? e : n } function rf(e) { return e = qg(e), e !== null ? of(e) : null } function of(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var n = of(e); if (n !== null) return n; e = e.sibling } return null } var sf = r.unstable_scheduleCallback, af = r.unstable_cancelCallback, Gg = r.unstable_shouldYield, Qg = r.unstable_requestPaint, _e = r.unstable_now, Xg = r.unstable_getCurrentPriorityLevel, ha = r.unstable_ImmediatePriority, lf = r.unstable_UserBlockingPriority, so = r.unstable_NormalPriority, Yg = r.unstable_LowPriority, uf = r.unstable_IdlePriority, ao = null, It = null; function Jg(e) { if (It && typeof It.onCommitFiberRoot == "function") try { It.onCommitFiberRoot(ao, e, void 0, (e.current.flags & 128) === 128) } catch { } } var At = Math.clz32 ? Math.clz32 : tv, Zg = Math.log, ev = Math.LN2; function tv(e) { return e >>>= 0, e === 0 ? 32 : 31 - (Zg(e) / ev | 0) | 0 } var lo = 64, uo = 4194304; function Zr(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function co(e, n) { var o = e.pendingLanes; if (o === 0) return 0; var a = 0, c = e.suspendedLanes, d = e.pingedLanes, g = o & 268435455; if (g !== 0) { var x = g & ~c; x !== 0 ? a = Zr(x) : (d &= g, d !== 0 && (a = Zr(d))) } else g = o & ~c, g !== 0 ? a = Zr(g) : d !== 0 && (a = Zr(d)); if (a === 0) return 0; if (n !== 0 && n !== a && !(n & c) && (c = a & -a, d = n & -n, c >= d || c === 16 && (d & 4194240) !== 0)) return n; if (a & 4 && (a |= o & 16), n = e.entangledLanes, n !== 0) for (e = e.entanglements, n &= a; 0 < n;)o = 31 - At(n), c = 1 << o, a |= e[o], n &= ~c; return a } function nv(e, n) { switch (e) { case 1: case 2: case 4: return n + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return n + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function rv(e, n) { for (var o = e.suspendedLanes, a = e.pingedLanes, c = e.expirationTimes, d = e.pendingLanes; 0 < d;) { var g = 31 - At(d), x = 1 << g, E = c[g]; E === -1 ? (!(x & o) || x & a) && (c[g] = nv(x, n)) : E <= n && (e.expiredLanes |= x), d &= ~x } } function pa(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function cf() { var e = lo; return lo <<= 1, !(lo & 4194240) && (lo = 64), e } function ma(e) { for (var n = [], o = 0; 31 > o; o++)n.push(e); return n } function ei(e, n, o) { e.pendingLanes |= n, n !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, n = 31 - At(n), e[n] = o } function iv(e, n) { var o = e.pendingLanes & ~n; e.pendingLanes = n, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= n, e.mutableReadLanes &= n, e.entangledLanes &= n, n = e.entanglements; var a = e.eventTimes; for (e = e.expirationTimes; 0 < o;) { var c = 31 - At(o), d = 1 << c; n[c] = 0, a[c] = -1, e[c] = -1, o &= ~d } } function ya(e, n) { var o = e.entangledLanes |= n; for (e = e.entanglements; o;) { var a = 31 - At(o), c = 1 << a; c & n | e[a] & n && (e[a] |= n), o &= ~c } } var ge = 0; function ff(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var df, ga, hf, pf, mf, va = !1, fo = [], fn = null, dn = null, hn = null, ti = new Map, ni = new Map, pn = [], ov = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function yf(e, n) { switch (e) { case "focusin": case "focusout": fn = null; break; case "dragenter": case "dragleave": dn = null; break; case "mouseover": case "mouseout": hn = null; break; case "pointerover": case "pointerout": ti.delete(n.pointerId); break; case "gotpointercapture": case "lostpointercapture": ni.delete(n.pointerId) } } function ri(e, n, o, a, c, d) { return e === null || e.nativeEvent !== d ? (e = { blockedOn: n, domEventName: o, eventSystemFlags: a, nativeEvent: d, targetContainers: [c] }, n !== null && (n = gi(n), n !== null && ga(n)), e) : (e.eventSystemFlags |= a, n = e.targetContainers, c !== null && n.indexOf(c) === -1 && n.push(c), e) } function sv(e, n, o, a, c) { switch (n) { case "focusin": return fn = ri(fn, e, n, o, a, c), !0; case "dragenter": return dn = ri(dn, e, n, o, a, c), !0; case "mouseover": return hn = ri(hn, e, n, o, a, c), !0; case "pointerover": var d = c.pointerId; return ti.set(d, ri(ti.get(d) || null, e, n, o, a, c)), !0; case "gotpointercapture": return d = c.pointerId, ni.set(d, ri(ni.get(d) || null, e, n, o, a, c)), !0 }return !1 } function gf(e) { var n = Bn(e.target); if (n !== null) { var o = In(n); if (o !== null) { if (n = o.tag, n === 13) { if (n = tf(o), n !== null) { e.blockedOn = n, mf(e.priority, function () { hf(o) }); return } } else if (n === 3 && o.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = o.tag === 3 ? o.stateNode.containerInfo : null; return } } } e.blockedOn = null } function ho(e) { if (e.blockedOn !== null) return !1; for (var n = e.targetContainers; 0 < n.length;) { var o = xa(e.domEventName, e.eventSystemFlags, n[0], e.nativeEvent); if (o === null) { o = e.nativeEvent; var a = new o.constructor(o.type, o); aa = a, o.target.dispatchEvent(a), aa = null } else return n = gi(o), n !== null && ga(n), e.blockedOn = o, !1; n.shift() } return !0 } function vf(e, n, o) { ho(e) && o.delete(n) } function av() { va = !1, fn !== null && ho(fn) && (fn = null), dn !== null && ho(dn) && (dn = null), hn !== null && ho(hn) && (hn = null), ti.forEach(vf), ni.forEach(vf) } function ii(e, n) { e.blockedOn === n && (e.blockedOn = null, va || (va = !0, r.unstable_scheduleCallback(r.unstable_NormalPriority, av))) } function oi(e) { function n(c) { return ii(c, e) } if (0 < fo.length) { ii(fo[0], e); for (var o = 1; o < fo.length; o++) { var a = fo[o]; a.blockedOn === e && (a.blockedOn = null) } } for (fn !== null && ii(fn, e), dn !== null && ii(dn, e), hn !== null && ii(hn, e), ti.forEach(n), ni.forEach(n), o = 0; o < pn.length; o++)a = pn[o], a.blockedOn === e && (a.blockedOn = null); for (; 0 < pn.length && (o = pn[0], o.blockedOn === null);)gf(o), o.blockedOn === null && pn.shift() } var cr = b.ReactCurrentBatchConfig, po = !0; function lv(e, n, o, a) { var c = ge, d = cr.transition; cr.transition = null; try { ge = 1, wa(e, n, o, a) } finally { ge = c, cr.transition = d } } function uv(e, n, o, a) { var c = ge, d = cr.transition; cr.transition = null; try { ge = 4, wa(e, n, o, a) } finally { ge = c, cr.transition = d } } function wa(e, n, o, a) { if (po) { var c = xa(e, n, o, a); if (c === null) ja(e, n, a, mo, o), yf(e, a); else if (sv(c, e, n, o, a)) a.stopPropagation(); else if (yf(e, a), n & 4 && -1 < ov.indexOf(e)) { for (; c !== null;) { var d = gi(c); if (d !== null && df(d), d = xa(e, n, o, a), d === null && ja(e, n, a, mo, o), d === c) break; c = d } c !== null && a.stopPropagation() } else ja(e, n, a, null, o) } } var mo = null; function xa(e, n, o, a) { if (mo = null, e = la(a), e = Bn(e), e !== null) if (n = In(e), n === null) e = null; else if (o = n.tag, o === 13) { if (e = tf(n), e !== null) return e; e = null } else if (o === 3) { if (n.stateNode.current.memoizedState.isDehydrated) return n.tag === 3 ? n.stateNode.containerInfo : null; e = null } else n !== e && (e = null); return mo = e, null } function wf(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Xg()) { case ha: return 1; case lf: return 4; case so: case Yg: return 16; case uf: return 536870912; default: return 16 }default: return 16 } } var mn = null, Sa = null, yo = null; function xf() { if (yo) return yo; var e, n = Sa, o = n.length, a, c = "value" in mn ? mn.value : mn.textContent, d = c.length; for (e = 0; e < o && n[e] === c[e]; e++); var g = o - e; for (a = 1; a <= g && n[o - a] === c[d - a]; a++); return yo = c.slice(e, 1 < a ? 1 - a : void 0) } function go(e) { var n = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && n === 13 && (e = 13)) : e = n, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function vo() { return !0 } function Sf() { return !1 } function ht(e) { function n(o, a, c, d, g) { this._reactName = o, this._targetInst = c, this.type = a, this.nativeEvent = d, this.target = g, this.currentTarget = null; for (var x in e) e.hasOwnProperty(x) && (o = e[x], this[x] = o ? o(d) : d[x]); return this.isDefaultPrevented = (d.defaultPrevented != null ? d.defaultPrevented : d.returnValue === !1) ? vo : Sf, this.isPropagationStopped = Sf, this } return K(n.prototype, { preventDefault: function () { this.defaultPrevented = !0; var o = this.nativeEvent; o && (o.preventDefault ? o.preventDefault() : typeof o.returnValue != "unknown" && (o.returnValue = !1), this.isDefaultPrevented = vo) }, stopPropagation: function () { var o = this.nativeEvent; o && (o.stopPropagation ? o.stopPropagation() : typeof o.cancelBubble != "unknown" && (o.cancelBubble = !0), this.isPropagationStopped = vo) }, persist: function () { }, isPersistent: vo }), n } var fr = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Ea = ht(fr), si = K({}, fr, { view: 0, detail: 0 }), cv = ht(si), Pa, Ca, ai, wo = K({}, si, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: ka, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ai && (ai && e.type === "mousemove" ? (Pa = e.screenX - ai.screenX, Ca = e.screenY - ai.screenY) : Ca = Pa = 0, ai = e), Pa) }, movementY: function (e) { return "movementY" in e ? e.movementY : Ca } }), Ef = ht(wo), fv = K({}, wo, { dataTransfer: 0 }), dv = ht(fv), hv = K({}, si, { relatedTarget: 0 }), Ta = ht(hv), pv = K({}, fr, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), mv = ht(pv), yv = K({}, fr, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), gv = ht(yv), vv = K({}, fr, { data: 0 }), Pf = ht(vv), wv = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, xv = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Sv = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Ev(e) { var n = this.nativeEvent; return n.getModifierState ? n.getModifierState(e) : (e = Sv[e]) ? !!n[e] : !1 } function ka() { return Ev } var Pv = K({}, si, { key: function (e) { if (e.key) { var n = wv[e.key] || e.key; if (n !== "Unidentified") return n } return e.type === "keypress" ? (e = go(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? xv[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: ka, charCode: function (e) { return e.type === "keypress" ? go(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? go(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Cv = ht(Pv), Tv = K({}, wo, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Cf = ht(Tv), kv = K({}, si, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: ka }), Rv = ht(kv), Av = K({}, fr, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Lv = ht(Av), Dv = K({}, wo, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), _v = ht(Dv), Mv = [9, 13, 27, 32], Ra = h && "CompositionEvent" in window, li = null; h && "documentMode" in document && (li = document.documentMode); var Ov = h && "TextEvent" in window && !li, Tf = h && (!Ra || li && 8 < li && 11 >= li), kf = " ", Rf = !1; function Af(e, n) { switch (e) { case "keyup": return Mv.indexOf(n.keyCode) !== -1; case "keydown": return n.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Lf(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var dr = !1; function Nv(e, n) { switch (e) { case "compositionend": return Lf(n); case "keypress": return n.which !== 32 ? null : (Rf = !0, kf); case "textInput": return e = n.data, e === kf && Rf ? null : e; default: return null } } function Fv(e, n) { if (dr) return e === "compositionend" || !Ra && Af(e, n) ? (e = xf(), yo = Sa = mn = null, dr = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(n.ctrlKey || n.altKey || n.metaKey) || n.ctrlKey && n.altKey) { if (n.char && 1 < n.char.length) return n.char; if (n.which) return String.fromCharCode(n.which) } return null; case "compositionend": return Tf && n.locale !== "ko" ? null : n.data; default: return null } } var Vv = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Df(e) { var n = e && e.nodeName && e.nodeName.toLowerCase(); return n === "input" ? !!Vv[e.type] : n === "textarea" } function _f(e, n, o, a) { Xc(a), n = Co(n, "onChange"), 0 < n.length && (o = new Ea("onChange", "change", null, o, a), e.push({ event: o, listeners: n })) } var ui = null, ci = null; function jv(e) { Qf(e, 0) } function xo(e) { var n = gr(e); if (Ic(n)) return e } function Iv(e, n) { if (e === "change") return n } var Mf = !1; if (h) { var Aa; if (h) { var La = "oninput" in document; if (!La) { var Of = document.createElement("div"); Of.setAttribute("oninput", "return;"), La = typeof Of.oninput == "function" } Aa = La } else Aa = !1; Mf = Aa && (!document.documentMode || 9 < document.documentMode) } function Nf() { ui && (ui.detachEvent("onpropertychange", Ff), ci = ui = null) } function Ff(e) { if (e.propertyName === "value" && xo(ci)) { var n = []; _f(n, ci, e, la(e)), ef(jv, n) } } function Bv(e, n, o) { e === "focusin" ? (Nf(), ui = n, ci = o, ui.attachEvent("onpropertychange", Ff)) : e === "focusout" && Nf() } function zv(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return xo(ci) } function Uv(e, n) { if (e === "click") return xo(n) } function bv(e, n) { if (e === "input" || e === "change") return xo(n) } function $v(e, n) { return e === n && (e !== 0 || 1 / e === 1 / n) || e !== e && n !== n } var Lt = typeof Object.is == "function" ? Object.is : $v; function fi(e, n) { if (Lt(e, n)) return !0; if (typeof e != "object" || e === null || typeof n != "object" || n === null) return !1; var o = Object.keys(e), a = Object.keys(n); if (o.length !== a.length) return !1; for (a = 0; a < o.length; a++) { var c = o[a]; if (!p.call(n, c) || !Lt(e[c], n[c])) return !1 } return !0 } function Vf(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function jf(e, n) { var o = Vf(e); e = 0; for (var a; o;) { if (o.nodeType === 3) { if (a = e + o.textContent.length, e <= n && a >= n) return { node: o, offset: n - e }; e = a } e: { for (; o;) { if (o.nextSibling) { o = o.nextSibling; break e } o = o.parentNode } o = void 0 } o = Vf(o) } } function If(e, n) { return e && n ? e === n ? !0 : e && e.nodeType === 3 ? !1 : n && n.nodeType === 3 ? If(e, n.parentNode) : "contains" in e ? e.contains(n) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(n) & 16) : !1 : !1 } function Bf() { for (var e = window, n = no(); n instanceof e.HTMLIFrameElement;) { try { var o = typeof n.contentWindow.location.href == "string" } catch { o = !1 } if (o) e = n.contentWindow; else break; n = no(e.document) } return n } function Da(e) { var n = e && e.nodeName && e.nodeName.toLowerCase(); return n && (n === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || n === "textarea" || e.contentEditable === "true") } function Hv(e) { var n = Bf(), o = e.focusedElem, a = e.selectionRange; if (n !== o && o && o.ownerDocument && If(o.ownerDocument.documentElement, o)) { if (a !== null && Da(o)) { if (n = a.start, e = a.end, e === void 0 && (e = n), "selectionStart" in o) o.selectionStart = n, o.selectionEnd = Math.min(e, o.value.length); else if (e = (n = o.ownerDocument || document) && n.defaultView || window, e.getSelection) { e = e.getSelection(); var c = o.textContent.length, d = Math.min(a.start, c); a = a.end === void 0 ? d : Math.min(a.end, c), !e.extend && d > a && (c = a, a = d, d = c), c = jf(o, d); var g = jf(o, a); c && g && (e.rangeCount !== 1 || e.anchorNode !== c.node || e.anchorOffset !== c.offset || e.focusNode !== g.node || e.focusOffset !== g.offset) && (n = n.createRange(), n.setStart(c.node, c.offset), e.removeAllRanges(), d > a ? (e.addRange(n), e.extend(g.node, g.offset)) : (n.setEnd(g.node, g.offset), e.addRange(n))) } } for (n = [], e = o; e = e.parentNode;)e.nodeType === 1 && n.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof o.focus == "function" && o.focus(), o = 0; o < n.length; o++)e = n[o], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var Wv = h && "documentMode" in document && 11 >= document.documentMode, hr = null, _a = null, di = null, Ma = !1; function zf(e, n, o) { var a = o.window === o ? o.document : o.nodeType === 9 ? o : o.ownerDocument; Ma || hr == null || hr !== no(a) || (a = hr, "selectionStart" in a && Da(a) ? a = { start: a.selectionStart, end: a.selectionEnd } : (a = (a.ownerDocument && a.ownerDocument.defaultView || window).getSelection(), a = { anchorNode: a.anchorNode, anchorOffset: a.anchorOffset, focusNode: a.focusNode, focusOffset: a.focusOffset }), di && fi(di, a) || (di = a, a = Co(_a, "onSelect"), 0 < a.length && (n = new Ea("onSelect", "select", null, n, o), e.push({ event: n, listeners: a }), n.target = hr))) } function So(e, n) { var o = {}; return o[e.toLowerCase()] = n.toLowerCase(), o["Webkit" + e] = "webkit" + n, o["Moz" + e] = "moz" + n, o } var pr = { animationend: So("Animation", "AnimationEnd"), animationiteration: So("Animation", "AnimationIteration"), animationstart: So("Animation", "AnimationStart"), transitionend: So("Transition", "TransitionEnd") }, Oa = {}, Uf = {}; h && (Uf = document.createElement("div").style, "AnimationEvent" in window || (delete pr.animationend.animation, delete pr.animationiteration.animation, delete pr.animationstart.animation), "TransitionEvent" in window || delete pr.transitionend.transition); function Eo(e) { if (Oa[e]) return Oa[e]; if (!pr[e]) return e; var n = pr[e], o; for (o in n) if (n.hasOwnProperty(o) && o in Uf) return Oa[e] = n[o]; return e } var bf = Eo("animationend"), $f = Eo("animationiteration"), Hf = Eo("animationstart"), Wf = Eo("transitionend"), Kf = new Map, qf = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function yn(e, n) { Kf.set(e, n), f(n, [e]) } for (var Na = 0; Na < qf.length; Na++) { var Fa = qf[Na], Kv = Fa.toLowerCase(), qv = Fa[0].toUpperCase() + Fa.slice(1); yn(Kv, "on" + qv) } yn(bf, "onAnimationEnd"), yn($f, "onAnimationIteration"), yn(Hf, "onAnimationStart"), yn("dblclick", "onDoubleClick"), yn("focusin", "onFocus"), yn("focusout", "onBlur"), yn(Wf, "onTransitionEnd"), u("onMouseEnter", ["mouseout", "mouseover"]), u("onMouseLeave", ["mouseout", "mouseover"]), u("onPointerEnter", ["pointerout", "pointerover"]), u("onPointerLeave", ["pointerout", "pointerover"]), f("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), f("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), f("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), f("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), f("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), f("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var hi = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Gv = new Set("cancel close invalid load scroll toggle".split(" ").concat(hi)); function Gf(e, n, o) { var a = e.type || "unknown-event"; e.currentTarget = o, Kg(a, n, void 0, e), e.currentTarget = null } function Qf(e, n) { n = (n & 4) !== 0; for (var o = 0; o < e.length; o++) { var a = e[o], c = a.event; a = a.listeners; e: { var d = void 0; if (n) for (var g = a.length - 1; 0 <= g; g--) { var x = a[g], E = x.instance, M = x.currentTarget; if (x = x.listener, E !== d && c.isPropagationStopped()) break e; Gf(c, x, M), d = E } else for (g = 0; g < a.length; g++) { if (x = a[g], E = x.instance, M = x.currentTarget, x = x.listener, E !== d && c.isPropagationStopped()) break e; Gf(c, x, M), d = E } } } if (oo) throw e = da, oo = !1, da = null, e } function Se(e, n) { var o = n[$a]; o === void 0 && (o = n[$a] = new Set); var a = e + "__bubble"; o.has(a) || (Xf(n, e, 2, !1), o.add(a)) } function Va(e, n, o) { var a = 0; n && (a |= 4), Xf(o, e, a, n) } var Po = "_reactListening" + Math.random().toString(36).slice(2); function pi(e) { if (!e[Po]) { e[Po] = !0, s.forEach(function (o) { o !== "selectionchange" && (Gv.has(o) || Va(o, !1, e), Va(o, !0, e)) }); var n = e.nodeType === 9 ? e : e.ownerDocument; n === null || n[Po] || (n[Po] = !0, Va("selectionchange", !1, n)) } } function Xf(e, n, o, a) { switch (wf(n)) { case 1: var c = lv; break; case 4: c = uv; break; default: c = wa }o = c.bind(null, n, o, e), c = void 0, !fa || n !== "touchstart" && n !== "touchmove" && n !== "wheel" || (c = !0), a ? c !== void 0 ? e.addEventListener(n, o, { capture: !0, passive: c }) : e.addEventListener(n, o, !0) : c !== void 0 ? e.addEventListener(n, o, { passive: c }) : e.addEventListener(n, o, !1) } function ja(e, n, o, a, c) { var d = a; if (!(n & 1) && !(n & 2) && a !== null) e: for (; ;) { if (a === null) return; var g = a.tag; if (g === 3 || g === 4) { var x = a.stateNode.containerInfo; if (x === c || x.nodeType === 8 && x.parentNode === c) break; if (g === 4) for (g = a.return; g !== null;) { var E = g.tag; if ((E === 3 || E === 4) && (E = g.stateNode.containerInfo, E === c || E.nodeType === 8 && E.parentNode === c)) return; g = g.return } for (; x !== null;) { if (g = Bn(x), g === null) return; if (E = g.tag, E === 5 || E === 6) { a = d = g; continue e } x = x.parentNode } } a = a.return } ef(function () { var M = d, I = la(o), B = []; e: { var V = Kf.get(e); if (V !== void 0) { var W = Ea, G = e; switch (e) { case "keypress": if (go(o) === 0) break e; case "keydown": case "keyup": W = Cv; break; case "focusin": G = "focus", W = Ta; break; case "focusout": G = "blur", W = Ta; break; case "beforeblur": case "afterblur": W = Ta; break; case "click": if (o.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": W = Ef; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": W = dv; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": W = Rv; break; case bf: case $f: case Hf: W = mv; break; case Wf: W = Lv; break; case "scroll": W = cv; break; case "wheel": W = _v; break; case "copy": case "cut": case "paste": W = gv; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": W = Cf }var X = (n & 4) !== 0, Me = !X && e === "scroll", D = X ? V !== null ? V + "Capture" : null : V; X = []; for (var T = M, _; T !== null;) { _ = T; var U = _.stateNode; if (_.tag === 5 && U !== null && (_ = U, D !== null && (U = Xr(T, D), U != null && X.push(mi(T, U, _)))), Me) break; T = T.return } 0 < X.length && (V = new W(V, G, null, o, I), B.push({ event: V, listeners: X })) } } if (!(n & 7)) { e: { if (V = e === "mouseover" || e === "pointerover", W = e === "mouseout" || e === "pointerout", V && o !== aa && (G = o.relatedTarget || o.fromElement) && (Bn(G) || G[qt])) break e; if ((W || V) && (V = I.window === I ? I : (V = I.ownerDocument) ? V.defaultView || V.parentWindow : window, W ? (G = o.relatedTarget || o.toElement, W = M, G = G ? Bn(G) : null, G !== null && (Me = In(G), G !== Me || G.tag !== 5 && G.tag !== 6) && (G = null)) : (W = null, G = M), W !== G)) { if (X = Ef, U = "onMouseLeave", D = "onMouseEnter", T = "mouse", (e === "pointerout" || e === "pointerover") && (X = Cf, U = "onPointerLeave", D = "onPointerEnter", T = "pointer"), Me = W == null ? V : gr(W), _ = G == null ? V : gr(G), V = new X(U, T + "leave", W, o, I), V.target = Me, V.relatedTarget = _, U = null, Bn(I) === M && (X = new X(D, T + "enter", G, o, I), X.target = _, X.relatedTarget = Me, U = X), Me = U, W && G) t: { for (X = W, D = G, T = 0, _ = X; _; _ = mr(_))T++; for (_ = 0, U = D; U; U = mr(U))_++; for (; 0 < T - _;)X = mr(X), T--; for (; 0 < _ - T;)D = mr(D), _--; for (; T--;) { if (X === D || D !== null && X === D.alternate) break t; X = mr(X), D = mr(D) } X = null } else X = null; W !== null && Yf(B, V, W, X, !1), G !== null && Me !== null && Yf(B, Me, G, X, !0) } } e: { if (V = M ? gr(M) : window, W = V.nodeName && V.nodeName.toLowerCase(), W === "select" || W === "input" && V.type === "file") var J = Iv; else if (Df(V)) if (Mf) J = bv; else { J = zv; var ee = Bv } else (W = V.nodeName) && W.toLowerCase() === "input" && (V.type === "checkbox" || V.type === "radio") && (J = Uv); if (J && (J = J(e, M))) { _f(B, J, o, I); break e } ee && ee(e, V, M), e === "focusout" && (ee = V._wrapperState) && ee.controlled && V.type === "number" && na(V, "number", V.value) } switch (ee = M ? gr(M) : window, e) { case "focusin": (Df(ee) || ee.contentEditable === "true") && (hr = ee, _a = M, di = null); break; case "focusout": di = _a = hr = null; break; case "mousedown": Ma = !0; break; case "contextmenu": case "mouseup": case "dragend": Ma = !1, zf(B, o, I); break; case "selectionchange": if (Wv) break; case "keydown": case "keyup": zf(B, o, I) }var te; if (Ra) e: { switch (e) { case "compositionstart": var ie = "onCompositionStart"; break e; case "compositionend": ie = "onCompositionEnd"; break e; case "compositionupdate": ie = "onCompositionUpdate"; break e }ie = void 0 } else dr ? Af(e, o) && (ie = "onCompositionEnd") : e === "keydown" && o.keyCode === 229 && (ie = "onCompositionStart"); ie && (Tf && o.locale !== "ko" && (dr || ie !== "onCompositionStart" ? ie === "onCompositionEnd" && dr && (te = xf()) : (mn = I, Sa = "value" in mn ? mn.value : mn.textContent, dr = !0)), ee = Co(M, ie), 0 < ee.length && (ie = new Pf(ie, e, null, o, I), B.push({ event: ie, listeners: ee }), te ? ie.data = te : (te = Lf(o), te !== null && (ie.data = te)))), (te = Ov ? Nv(e, o) : Fv(e, o)) && (M = Co(M, "onBeforeInput"), 0 < M.length && (I = new Pf("onBeforeInput", "beforeinput", null, o, I), B.push({ event: I, listeners: M }), I.data = te)) } Qf(B, n) }) } function mi(e, n, o) { return { instance: e, listener: n, currentTarget: o } } function Co(e, n) { for (var o = n + "Capture", a = []; e !== null;) { var c = e, d = c.stateNode; c.tag === 5 && d !== null && (c = d, d = Xr(e, o), d != null && a.unshift(mi(e, d, c)), d = Xr(e, n), d != null && a.push(mi(e, d, c))), e = e.return } return a } function mr(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Yf(e, n, o, a, c) { for (var d = n._reactName, g = []; o !== null && o !== a;) { var x = o, E = x.alternate, M = x.stateNode; if (E !== null && E === a) break; x.tag === 5 && M !== null && (x = M, c ? (E = Xr(o, d), E != null && g.unshift(mi(o, E, x))) : c || (E = Xr(o, d), E != null && g.push(mi(o, E, x)))), o = o.return } g.length !== 0 && e.push({ event: n, listeners: g }) } var Qv = /\r\n?/g, Xv = /\u0000|\uFFFD/g; function Jf(e) {
    return (typeof e == "string" ? e : "" + e).replace(Qv, `
`).replace(Xv, "")
  } function To(e, n, o) { if (n = Jf(n), Jf(e) !== n && o) throw Error(i(425)) } function ko() { } var Ia = null, Ba = null; function za(e, n) { return e === "textarea" || e === "noscript" || typeof n.children == "string" || typeof n.children == "number" || typeof n.dangerouslySetInnerHTML == "object" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null } var Ua = typeof setTimeout == "function" ? setTimeout : void 0, Yv = typeof clearTimeout == "function" ? clearTimeout : void 0, Zf = typeof Promise == "function" ? Promise : void 0, Jv = typeof queueMicrotask == "function" ? queueMicrotask : typeof Zf < "u" ? function (e) { return Zf.resolve(null).then(e).catch(Zv) } : Ua; function Zv(e) { setTimeout(function () { throw e }) } function ba(e, n) { var o = n, a = 0; do { var c = o.nextSibling; if (e.removeChild(o), c && c.nodeType === 8) if (o = c.data, o === "/$") { if (a === 0) { e.removeChild(c), oi(n); return } a-- } else o !== "$" && o !== "$?" && o !== "$!" || a++; o = c } while (o); oi(n) } function gn(e) { for (; e != null; e = e.nextSibling) { var n = e.nodeType; if (n === 1 || n === 3) break; if (n === 8) { if (n = e.data, n === "$" || n === "$!" || n === "$?") break; if (n === "/$") return null } } return e } function ed(e) { e = e.previousSibling; for (var n = 0; e;) { if (e.nodeType === 8) { var o = e.data; if (o === "$" || o === "$!" || o === "$?") { if (n === 0) return e; n-- } else o === "/$" && n++ } e = e.previousSibling } return null } var yr = Math.random().toString(36).slice(2), Bt = "__reactFiber$" + yr, yi = "__reactProps$" + yr, qt = "__reactContainer$" + yr, $a = "__reactEvents$" + yr, e0 = "__reactListeners$" + yr, t0 = "__reactHandles$" + yr; function Bn(e) { var n = e[Bt]; if (n) return n; for (var o = e.parentNode; o;) { if (n = o[qt] || o[Bt]) { if (o = n.alternate, n.child !== null || o !== null && o.child !== null) for (e = ed(e); e !== null;) { if (o = e[Bt]) return o; e = ed(e) } return n } e = o, o = e.parentNode } return null } function gi(e) { return e = e[Bt] || e[qt], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function gr(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(i(33)) } function Ro(e) { return e[yi] || null } var Ha = [], vr = -1; function vn(e) { return { current: e } } function Ee(e) { 0 > vr || (e.current = Ha[vr], Ha[vr] = null, vr--) } function xe(e, n) { vr++, Ha[vr] = e.current, e.current = n } var wn = {}, We = vn(wn), it = vn(!1), zn = wn; function wr(e, n) { var o = e.type.contextTypes; if (!o) return wn; var a = e.stateNode; if (a && a.__reactInternalMemoizedUnmaskedChildContext === n) return a.__reactInternalMemoizedMaskedChildContext; var c = {}, d; for (d in o) c[d] = n[d]; return a && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = n, e.__reactInternalMemoizedMaskedChildContext = c), c } function ot(e) { return e = e.childContextTypes, e != null } function Ao() { Ee(it), Ee(We) } function td(e, n, o) { if (We.current !== wn) throw Error(i(168)); xe(We, n), xe(it, o) } function nd(e, n, o) { var a = e.stateNode; if (n = n.childContextTypes, typeof a.getChildContext != "function") return o; a = a.getChildContext(); for (var c in a) if (!(c in n)) throw Error(i(108, we(e) || "Unknown", c)); return K({}, o, a) } function Lo(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || wn, zn = We.current, xe(We, e), xe(it, it.current), !0 } function rd(e, n, o) { var a = e.stateNode; if (!a) throw Error(i(169)); o ? (e = nd(e, n, zn), a.__reactInternalMemoizedMergedChildContext = e, Ee(it), Ee(We), xe(We, e)) : Ee(it), xe(it, o) } var Gt = null, Do = !1, Wa = !1; function id(e) { Gt === null ? Gt = [e] : Gt.push(e) } function n0(e) { Do = !0, id(e) } function xn() { if (!Wa && Gt !== null) { Wa = !0; var e = 0, n = ge; try { var o = Gt; for (ge = 1; e < o.length; e++) { var a = o[e]; do a = a(!0); while (a !== null) } Gt = null, Do = !1 } catch (c) { throw Gt !== null && (Gt = Gt.slice(e + 1)), sf(ha, xn), c } finally { ge = n, Wa = !1 } } return null } var xr = [], Sr = 0, _o = null, Mo = 0, wt = [], xt = 0, Un = null, Qt = 1, Xt = ""; function bn(e, n) { xr[Sr++] = Mo, xr[Sr++] = _o, _o = e, Mo = n } function od(e, n, o) { wt[xt++] = Qt, wt[xt++] = Xt, wt[xt++] = Un, Un = e; var a = Qt; e = Xt; var c = 32 - At(a) - 1; a &= ~(1 << c), o += 1; var d = 32 - At(n) + c; if (30 < d) { var g = c - c % 5; d = (a & (1 << g) - 1).toString(32), a >>= g, c -= g, Qt = 1 << 32 - At(n) + c | o << c | a, Xt = d + e } else Qt = 1 << d | o << c | a, Xt = e } function Ka(e) { e.return !== null && (bn(e, 1), od(e, 1, 0)) } function qa(e) { for (; e === _o;)_o = xr[--Sr], xr[Sr] = null, Mo = xr[--Sr], xr[Sr] = null; for (; e === Un;)Un = wt[--xt], wt[xt] = null, Xt = wt[--xt], wt[xt] = null, Qt = wt[--xt], wt[xt] = null } var pt = null, mt = null, Ce = !1, Dt = null; function sd(e, n) { var o = Ct(5, null, null, 0); o.elementType = "DELETED", o.stateNode = n, o.return = e, n = e.deletions, n === null ? (e.deletions = [o], e.flags |= 16) : n.push(o) } function ad(e, n) { switch (e.tag) { case 5: var o = e.type; return n = n.nodeType !== 1 || o.toLowerCase() !== n.nodeName.toLowerCase() ? null : n, n !== null ? (e.stateNode = n, pt = e, mt = gn(n.firstChild), !0) : !1; case 6: return n = e.pendingProps === "" || n.nodeType !== 3 ? null : n, n !== null ? (e.stateNode = n, pt = e, mt = null, !0) : !1; case 13: return n = n.nodeType !== 8 ? null : n, n !== null ? (o = Un !== null ? { id: Qt, overflow: Xt } : null, e.memoizedState = { dehydrated: n, treeContext: o, retryLane: 1073741824 }, o = Ct(18, null, null, 0), o.stateNode = n, o.return = e, e.child = o, pt = e, mt = null, !0) : !1; default: return !1 } } function Ga(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function Qa(e) { if (Ce) { var n = mt; if (n) { var o = n; if (!ad(e, n)) { if (Ga(e)) throw Error(i(418)); n = gn(o.nextSibling); var a = pt; n && ad(e, n) ? sd(a, o) : (e.flags = e.flags & -4097 | 2, Ce = !1, pt = e) } } else { if (Ga(e)) throw Error(i(418)); e.flags = e.flags & -4097 | 2, Ce = !1, pt = e } } } function ld(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; pt = e } function Oo(e) { if (e !== pt) return !1; if (!Ce) return ld(e), Ce = !0, !1; var n; if ((n = e.tag !== 3) && !(n = e.tag !== 5) && (n = e.type, n = n !== "head" && n !== "body" && !za(e.type, e.memoizedProps)), n && (n = mt)) { if (Ga(e)) throw ud(), Error(i(418)); for (; n;)sd(e, n), n = gn(n.nextSibling) } if (ld(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(i(317)); e: { for (e = e.nextSibling, n = 0; e;) { if (e.nodeType === 8) { var o = e.data; if (o === "/$") { if (n === 0) { mt = gn(e.nextSibling); break e } n-- } else o !== "$" && o !== "$!" && o !== "$?" || n++ } e = e.nextSibling } mt = null } } else mt = pt ? gn(e.stateNode.nextSibling) : null; return !0 } function ud() { for (var e = mt; e;)e = gn(e.nextSibling) } function Er() { mt = pt = null, Ce = !1 } function Xa(e) { Dt === null ? Dt = [e] : Dt.push(e) } var r0 = b.ReactCurrentBatchConfig; function vi(e, n, o) { if (e = o.ref, e !== null && typeof e != "function" && typeof e != "object") { if (o._owner) { if (o = o._owner, o) { if (o.tag !== 1) throw Error(i(309)); var a = o.stateNode } if (!a) throw Error(i(147, e)); var c = a, d = "" + e; return n !== null && n.ref !== null && typeof n.ref == "function" && n.ref._stringRef === d ? n.ref : (n = function (g) { var x = c.refs; g === null ? delete x[d] : x[d] = g }, n._stringRef = d, n) } if (typeof e != "string") throw Error(i(284)); if (!o._owner) throw Error(i(290, e)) } return e } function No(e, n) { throw e = Object.prototype.toString.call(n), Error(i(31, e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e)) } function cd(e) { var n = e._init; return n(e._payload) } function fd(e) { function n(D, T) { if (e) { var _ = D.deletions; _ === null ? (D.deletions = [T], D.flags |= 16) : _.push(T) } } function o(D, T) { if (!e) return null; for (; T !== null;)n(D, T), T = T.sibling; return null } function a(D, T) { for (D = new Map; T !== null;)T.key !== null ? D.set(T.key, T) : D.set(T.index, T), T = T.sibling; return D } function c(D, T) { return D = An(D, T), D.index = 0, D.sibling = null, D } function d(D, T, _) { return D.index = _, e ? (_ = D.alternate, _ !== null ? (_ = _.index, _ < T ? (D.flags |= 2, T) : _) : (D.flags |= 2, T)) : (D.flags |= 1048576, T) } function g(D) { return e && D.alternate === null && (D.flags |= 2), D } function x(D, T, _, U) { return T === null || T.tag !== 6 ? (T = Ul(_, D.mode, U), T.return = D, T) : (T = c(T, _), T.return = D, T) } function E(D, T, _, U) { var J = _.type; return J === ne ? I(D, T, _.props.children, U, _.key) : T !== null && (T.elementType === J || typeof J == "object" && J !== null && J.$$typeof === et && cd(J) === T.type) ? (U = c(T, _.props), U.ref = vi(D, T, _), U.return = D, U) : (U = is(_.type, _.key, _.props, null, D.mode, U), U.ref = vi(D, T, _), U.return = D, U) } function M(D, T, _, U) { return T === null || T.tag !== 4 || T.stateNode.containerInfo !== _.containerInfo || T.stateNode.implementation !== _.implementation ? (T = bl(_, D.mode, U), T.return = D, T) : (T = c(T, _.children || []), T.return = D, T) } function I(D, T, _, U, J) { return T === null || T.tag !== 7 ? (T = Xn(_, D.mode, U, J), T.return = D, T) : (T = c(T, _), T.return = D, T) } function B(D, T, _) { if (typeof T == "string" && T !== "" || typeof T == "number") return T = Ul("" + T, D.mode, _), T.return = D, T; if (typeof T == "object" && T !== null) { switch (T.$$typeof) { case z: return _ = is(T.type, T.key, T.props, null, D.mode, _), _.ref = vi(D, null, T), _.return = D, _; case Y: return T = bl(T, D.mode, _), T.return = D, T; case et: var U = T._init; return B(D, U(T._payload), _) }if (qr(T) || Z(T)) return T = Xn(T, D.mode, _, null), T.return = D, T; No(D, T) } return null } function V(D, T, _, U) { var J = T !== null ? T.key : null; if (typeof _ == "string" && _ !== "" || typeof _ == "number") return J !== null ? null : x(D, T, "" + _, U); if (typeof _ == "object" && _ !== null) { switch (_.$$typeof) { case z: return _.key === J ? E(D, T, _, U) : null; case Y: return _.key === J ? M(D, T, _, U) : null; case et: return J = _._init, V(D, T, J(_._payload), U) }if (qr(_) || Z(_)) return J !== null ? null : I(D, T, _, U, null); No(D, _) } return null } function W(D, T, _, U, J) { if (typeof U == "string" && U !== "" || typeof U == "number") return D = D.get(_) || null, x(T, D, "" + U, J); if (typeof U == "object" && U !== null) { switch (U.$$typeof) { case z: return D = D.get(U.key === null ? _ : U.key) || null, E(T, D, U, J); case Y: return D = D.get(U.key === null ? _ : U.key) || null, M(T, D, U, J); case et: var ee = U._init; return W(D, T, _, ee(U._payload), J) }if (qr(U) || Z(U)) return D = D.get(_) || null, I(T, D, U, J, null); No(T, U) } return null } function G(D, T, _, U) { for (var J = null, ee = null, te = T, ie = T = 0, ze = null; te !== null && ie < _.length; ie++) { te.index > ie ? (ze = te, te = null) : ze = te.sibling; var pe = V(D, te, _[ie], U); if (pe === null) { te === null && (te = ze); break } e && te && pe.alternate === null && n(D, te), T = d(pe, T, ie), ee === null ? J = pe : ee.sibling = pe, ee = pe, te = ze } if (ie === _.length) return o(D, te), Ce && bn(D, ie), J; if (te === null) { for (; ie < _.length; ie++)te = B(D, _[ie], U), te !== null && (T = d(te, T, ie), ee === null ? J = te : ee.sibling = te, ee = te); return Ce && bn(D, ie), J } for (te = a(D, te); ie < _.length; ie++)ze = W(te, D, ie, _[ie], U), ze !== null && (e && ze.alternate !== null && te.delete(ze.key === null ? ie : ze.key), T = d(ze, T, ie), ee === null ? J = ze : ee.sibling = ze, ee = ze); return e && te.forEach(function (Ln) { return n(D, Ln) }), Ce && bn(D, ie), J } function X(D, T, _, U) { var J = Z(_); if (typeof J != "function") throw Error(i(150)); if (_ = J.call(_), _ == null) throw Error(i(151)); for (var ee = J = null, te = T, ie = T = 0, ze = null, pe = _.next(); te !== null && !pe.done; ie++, pe = _.next()) { te.index > ie ? (ze = te, te = null) : ze = te.sibling; var Ln = V(D, te, pe.value, U); if (Ln === null) { te === null && (te = ze); break } e && te && Ln.alternate === null && n(D, te), T = d(Ln, T, ie), ee === null ? J = Ln : ee.sibling = Ln, ee = Ln, te = ze } if (pe.done) return o(D, te), Ce && bn(D, ie), J; if (te === null) { for (; !pe.done; ie++, pe = _.next())pe = B(D, pe.value, U), pe !== null && (T = d(pe, T, ie), ee === null ? J = pe : ee.sibling = pe, ee = pe); return Ce && bn(D, ie), J } for (te = a(D, te); !pe.done; ie++, pe = _.next())pe = W(te, D, ie, pe.value, U), pe !== null && (e && pe.alternate !== null && te.delete(pe.key === null ? ie : pe.key), T = d(pe, T, ie), ee === null ? J = pe : ee.sibling = pe, ee = pe); return e && te.forEach(function (V0) { return n(D, V0) }), Ce && bn(D, ie), J } function Me(D, T, _, U) { if (typeof _ == "object" && _ !== null && _.type === ne && _.key === null && (_ = _.props.children), typeof _ == "object" && _ !== null) { switch (_.$$typeof) { case z: e: { for (var J = _.key, ee = T; ee !== null;) { if (ee.key === J) { if (J = _.type, J === ne) { if (ee.tag === 7) { o(D, ee.sibling), T = c(ee, _.props.children), T.return = D, D = T; break e } } else if (ee.elementType === J || typeof J == "object" && J !== null && J.$$typeof === et && cd(J) === ee.type) { o(D, ee.sibling), T = c(ee, _.props), T.ref = vi(D, ee, _), T.return = D, D = T; break e } o(D, ee); break } else n(D, ee); ee = ee.sibling } _.type === ne ? (T = Xn(_.props.children, D.mode, U, _.key), T.return = D, D = T) : (U = is(_.type, _.key, _.props, null, D.mode, U), U.ref = vi(D, T, _), U.return = D, D = U) } return g(D); case Y: e: { for (ee = _.key; T !== null;) { if (T.key === ee) if (T.tag === 4 && T.stateNode.containerInfo === _.containerInfo && T.stateNode.implementation === _.implementation) { o(D, T.sibling), T = c(T, _.children || []), T.return = D, D = T; break e } else { o(D, T); break } else n(D, T); T = T.sibling } T = bl(_, D.mode, U), T.return = D, D = T } return g(D); case et: return ee = _._init, Me(D, T, ee(_._payload), U) }if (qr(_)) return G(D, T, _, U); if (Z(_)) return X(D, T, _, U); No(D, _) } return typeof _ == "string" && _ !== "" || typeof _ == "number" ? (_ = "" + _, T !== null && T.tag === 6 ? (o(D, T.sibling), T = c(T, _), T.return = D, D = T) : (o(D, T), T = Ul(_, D.mode, U), T.return = D, D = T), g(D)) : o(D, T) } return Me } var Pr = fd(!0), dd = fd(!1), Fo = vn(null), Vo = null, Cr = null, Ya = null; function Ja() { Ya = Cr = Vo = null } function Za(e) { var n = Fo.current; Ee(Fo), e._currentValue = n } function el(e, n, o) { for (; e !== null;) { var a = e.alternate; if ((e.childLanes & n) !== n ? (e.childLanes |= n, a !== null && (a.childLanes |= n)) : a !== null && (a.childLanes & n) !== n && (a.childLanes |= n), e === o) break; e = e.return } } function Tr(e, n) { Vo = e, Ya = Cr = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & n && (st = !0), e.firstContext = null) } function St(e) { var n = e._currentValue; if (Ya !== e) if (e = { context: e, memoizedValue: n, next: null }, Cr === null) { if (Vo === null) throw Error(i(308)); Cr = e, Vo.dependencies = { lanes: 0, firstContext: e } } else Cr = Cr.next = e; return n } var $n = null; function tl(e) { $n === null ? $n = [e] : $n.push(e) } function hd(e, n, o, a) { var c = n.interleaved; return c === null ? (o.next = o, tl(n)) : (o.next = c.next, c.next = o), n.interleaved = o, Yt(e, a) } function Yt(e, n) { e.lanes |= n; var o = e.alternate; for (o !== null && (o.lanes |= n), o = e, e = e.return; e !== null;)e.childLanes |= n, o = e.alternate, o !== null && (o.childLanes |= n), o = e, e = e.return; return o.tag === 3 ? o.stateNode : null } var Sn = !1; function nl(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function pd(e, n) { e = e.updateQueue, n.updateQueue === e && (n.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Jt(e, n) { return { eventTime: e, lane: n, tag: 0, payload: null, callback: null, next: null } } function En(e, n, o) { var a = e.updateQueue; if (a === null) return null; if (a = a.shared, fe & 2) { var c = a.pending; return c === null ? n.next = n : (n.next = c.next, c.next = n), a.pending = n, Yt(e, o) } return c = a.interleaved, c === null ? (n.next = n, tl(a)) : (n.next = c.next, c.next = n), a.interleaved = n, Yt(e, o) } function jo(e, n, o) { if (n = n.updateQueue, n !== null && (n = n.shared, (o & 4194240) !== 0)) { var a = n.lanes; a &= e.pendingLanes, o |= a, n.lanes = o, ya(e, o) } } function md(e, n) { var o = e.updateQueue, a = e.alternate; if (a !== null && (a = a.updateQueue, o === a)) { var c = null, d = null; if (o = o.firstBaseUpdate, o !== null) { do { var g = { eventTime: o.eventTime, lane: o.lane, tag: o.tag, payload: o.payload, callback: o.callback, next: null }; d === null ? c = d = g : d = d.next = g, o = o.next } while (o !== null); d === null ? c = d = n : d = d.next = n } else c = d = n; o = { baseState: a.baseState, firstBaseUpdate: c, lastBaseUpdate: d, shared: a.shared, effects: a.effects }, e.updateQueue = o; return } e = o.lastBaseUpdate, e === null ? o.firstBaseUpdate = n : e.next = n, o.lastBaseUpdate = n } function Io(e, n, o, a) { var c = e.updateQueue; Sn = !1; var d = c.firstBaseUpdate, g = c.lastBaseUpdate, x = c.shared.pending; if (x !== null) { c.shared.pending = null; var E = x, M = E.next; E.next = null, g === null ? d = M : g.next = M, g = E; var I = e.alternate; I !== null && (I = I.updateQueue, x = I.lastBaseUpdate, x !== g && (x === null ? I.firstBaseUpdate = M : x.next = M, I.lastBaseUpdate = E)) } if (d !== null) { var B = c.baseState; g = 0, I = M = E = null, x = d; do { var V = x.lane, W = x.eventTime; if ((a & V) === V) { I !== null && (I = I.next = { eventTime: W, lane: 0, tag: x.tag, payload: x.payload, callback: x.callback, next: null }); e: { var G = e, X = x; switch (V = n, W = o, X.tag) { case 1: if (G = X.payload, typeof G == "function") { B = G.call(W, B, V); break e } B = G; break e; case 3: G.flags = G.flags & -65537 | 128; case 0: if (G = X.payload, V = typeof G == "function" ? G.call(W, B, V) : G, V == null) break e; B = K({}, B, V); break e; case 2: Sn = !0 } } x.callback !== null && x.lane !== 0 && (e.flags |= 64, V = c.effects, V === null ? c.effects = [x] : V.push(x)) } else W = { eventTime: W, lane: V, tag: x.tag, payload: x.payload, callback: x.callback, next: null }, I === null ? (M = I = W, E = B) : I = I.next = W, g |= V; if (x = x.next, x === null) { if (x = c.shared.pending, x === null) break; V = x, x = V.next, V.next = null, c.lastBaseUpdate = V, c.shared.pending = null } } while (!0); if (I === null && (E = B), c.baseState = E, c.firstBaseUpdate = M, c.lastBaseUpdate = I, n = c.shared.interleaved, n !== null) { c = n; do g |= c.lane, c = c.next; while (c !== n) } else d === null && (c.shared.lanes = 0); Kn |= g, e.lanes = g, e.memoizedState = B } } function yd(e, n, o) { if (e = n.effects, n.effects = null, e !== null) for (n = 0; n < e.length; n++) { var a = e[n], c = a.callback; if (c !== null) { if (a.callback = null, a = o, typeof c != "function") throw Error(i(191, c)); c.call(a) } } } var wi = {}, zt = vn(wi), xi = vn(wi), Si = vn(wi); function Hn(e) { if (e === wi) throw Error(i(174)); return e } function rl(e, n) { switch (xe(Si, n), xe(xi, e), xe(zt, wi), e = n.nodeType, e) { case 9: case 11: n = (n = n.documentElement) ? n.namespaceURI : ia(null, ""); break; default: e = e === 8 ? n.parentNode : n, n = e.namespaceURI || null, e = e.tagName, n = ia(n, e) }Ee(zt), xe(zt, n) } function kr() { Ee(zt), Ee(xi), Ee(Si) } function gd(e) { Hn(Si.current); var n = Hn(zt.current), o = ia(n, e.type); n !== o && (xe(xi, e), xe(zt, o)) } function il(e) { xi.current === e && (Ee(zt), Ee(xi)) } var ke = vn(0); function Bo(e) { for (var n = e; n !== null;) { if (n.tag === 13) { var o = n.memoizedState; if (o !== null && (o = o.dehydrated, o === null || o.data === "$?" || o.data === "$!")) return n } else if (n.tag === 19 && n.memoizedProps.revealOrder !== void 0) { if (n.flags & 128) return n } else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return null; n = n.return } n.sibling.return = n.return, n = n.sibling } return null } var ol = []; function sl() { for (var e = 0; e < ol.length; e++)ol[e]._workInProgressVersionPrimary = null; ol.length = 0 } var zo = b.ReactCurrentDispatcher, al = b.ReactCurrentBatchConfig, Wn = 0, Re = null, Ve = null, Ie = null, Uo = !1, Ei = !1, Pi = 0, i0 = 0; function Ke() { throw Error(i(321)) } function ll(e, n) { if (n === null) return !1; for (var o = 0; o < n.length && o < e.length; o++)if (!Lt(e[o], n[o])) return !1; return !0 } function ul(e, n, o, a, c, d) { if (Wn = d, Re = n, n.memoizedState = null, n.updateQueue = null, n.lanes = 0, zo.current = e === null || e.memoizedState === null ? l0 : u0, e = o(a, c), Ei) { d = 0; do { if (Ei = !1, Pi = 0, 25 <= d) throw Error(i(301)); d += 1, Ie = Ve = null, n.updateQueue = null, zo.current = c0, e = o(a, c) } while (Ei) } if (zo.current = Ho, n = Ve !== null && Ve.next !== null, Wn = 0, Ie = Ve = Re = null, Uo = !1, n) throw Error(i(300)); return e } function cl() { var e = Pi !== 0; return Pi = 0, e } function Ut() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ie === null ? Re.memoizedState = Ie = e : Ie = Ie.next = e, Ie } function Et() { if (Ve === null) { var e = Re.alternate; e = e !== null ? e.memoizedState : null } else e = Ve.next; var n = Ie === null ? Re.memoizedState : Ie.next; if (n !== null) Ie = n, Ve = e; else { if (e === null) throw Error(i(310)); Ve = e, e = { memoizedState: Ve.memoizedState, baseState: Ve.baseState, baseQueue: Ve.baseQueue, queue: Ve.queue, next: null }, Ie === null ? Re.memoizedState = Ie = e : Ie = Ie.next = e } return Ie } function Ci(e, n) { return typeof n == "function" ? n(e) : n } function fl(e) { var n = Et(), o = n.queue; if (o === null) throw Error(i(311)); o.lastRenderedReducer = e; var a = Ve, c = a.baseQueue, d = o.pending; if (d !== null) { if (c !== null) { var g = c.next; c.next = d.next, d.next = g } a.baseQueue = c = d, o.pending = null } if (c !== null) { d = c.next, a = a.baseState; var x = g = null, E = null, M = d; do { var I = M.lane; if ((Wn & I) === I) E !== null && (E = E.next = { lane: 0, action: M.action, hasEagerState: M.hasEagerState, eagerState: M.eagerState, next: null }), a = M.hasEagerState ? M.eagerState : e(a, M.action); else { var B = { lane: I, action: M.action, hasEagerState: M.hasEagerState, eagerState: M.eagerState, next: null }; E === null ? (x = E = B, g = a) : E = E.next = B, Re.lanes |= I, Kn |= I } M = M.next } while (M !== null && M !== d); E === null ? g = a : E.next = x, Lt(a, n.memoizedState) || (st = !0), n.memoizedState = a, n.baseState = g, n.baseQueue = E, o.lastRenderedState = a } if (e = o.interleaved, e !== null) { c = e; do d = c.lane, Re.lanes |= d, Kn |= d, c = c.next; while (c !== e) } else c === null && (o.lanes = 0); return [n.memoizedState, o.dispatch] } function dl(e) { var n = Et(), o = n.queue; if (o === null) throw Error(i(311)); o.lastRenderedReducer = e; var a = o.dispatch, c = o.pending, d = n.memoizedState; if (c !== null) { o.pending = null; var g = c = c.next; do d = e(d, g.action), g = g.next; while (g !== c); Lt(d, n.memoizedState) || (st = !0), n.memoizedState = d, n.baseQueue === null && (n.baseState = d), o.lastRenderedState = d } return [d, a] } function vd() { } function wd(e, n) { var o = Re, a = Et(), c = n(), d = !Lt(a.memoizedState, c); if (d && (a.memoizedState = c, st = !0), a = a.queue, hl(Ed.bind(null, o, a, e), [e]), a.getSnapshot !== n || d || Ie !== null && Ie.memoizedState.tag & 1) { if (o.flags |= 2048, Ti(9, Sd.bind(null, o, a, c, n), void 0, null), Be === null) throw Error(i(349)); Wn & 30 || xd(o, n, c) } return c } function xd(e, n, o) { e.flags |= 16384, e = { getSnapshot: n, value: o }, n = Re.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, Re.updateQueue = n, n.stores = [e]) : (o = n.stores, o === null ? n.stores = [e] : o.push(e)) } function Sd(e, n, o, a) { n.value = o, n.getSnapshot = a, Pd(n) && Cd(e) } function Ed(e, n, o) { return o(function () { Pd(n) && Cd(e) }) } function Pd(e) { var n = e.getSnapshot; e = e.value; try { var o = n(); return !Lt(e, o) } catch { return !0 } } function Cd(e) { var n = Yt(e, 1); n !== null && Nt(n, e, 1, -1) } function Td(e) { var n = Ut(); return typeof e == "function" && (e = e()), n.memoizedState = n.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ci, lastRenderedState: e }, n.queue = e, e = e.dispatch = a0.bind(null, Re, e), [n.memoizedState, e] } function Ti(e, n, o, a) { return e = { tag: e, create: n, destroy: o, deps: a, next: null }, n = Re.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, Re.updateQueue = n, n.lastEffect = e.next = e) : (o = n.lastEffect, o === null ? n.lastEffect = e.next = e : (a = o.next, o.next = e, e.next = a, n.lastEffect = e)), e } function kd() { return Et().memoizedState } function bo(e, n, o, a) { var c = Ut(); Re.flags |= e, c.memoizedState = Ti(1 | n, o, void 0, a === void 0 ? null : a) } function $o(e, n, o, a) { var c = Et(); a = a === void 0 ? null : a; var d = void 0; if (Ve !== null) { var g = Ve.memoizedState; if (d = g.destroy, a !== null && ll(a, g.deps)) { c.memoizedState = Ti(n, o, d, a); return } } Re.flags |= e, c.memoizedState = Ti(1 | n, o, d, a) } function Rd(e, n) { return bo(8390656, 8, e, n) } function hl(e, n) { return $o(2048, 8, e, n) } function Ad(e, n) { return $o(4, 2, e, n) } function Ld(e, n) { return $o(4, 4, e, n) } function Dd(e, n) { if (typeof n == "function") return e = e(), n(e), function () { n(null) }; if (n != null) return e = e(), n.current = e, function () { n.current = null } } function _d(e, n, o) { return o = o != null ? o.concat([e]) : null, $o(4, 4, Dd.bind(null, n, e), o) } function pl() { } function Md(e, n) { var o = Et(); n = n === void 0 ? null : n; var a = o.memoizedState; return a !== null && n !== null && ll(n, a[1]) ? a[0] : (o.memoizedState = [e, n], e) } function Od(e, n) { var o = Et(); n = n === void 0 ? null : n; var a = o.memoizedState; return a !== null && n !== null && ll(n, a[1]) ? a[0] : (e = e(), o.memoizedState = [e, n], e) } function Nd(e, n, o) { return Wn & 21 ? (Lt(o, n) || (o = cf(), Re.lanes |= o, Kn |= o, e.baseState = !0), n) : (e.baseState && (e.baseState = !1, st = !0), e.memoizedState = o) } function o0(e, n) { var o = ge; ge = o !== 0 && 4 > o ? o : 4, e(!0); var a = al.transition; al.transition = {}; try { e(!1), n() } finally { ge = o, al.transition = a } } function Fd() { return Et().memoizedState } function s0(e, n, o) { var a = kn(e); if (o = { lane: a, action: o, hasEagerState: !1, eagerState: null, next: null }, Vd(e)) jd(n, o); else if (o = hd(e, n, o, a), o !== null) { var c = nt(); Nt(o, e, a, c), Id(o, n, a) } } function a0(e, n, o) { var a = kn(e), c = { lane: a, action: o, hasEagerState: !1, eagerState: null, next: null }; if (Vd(e)) jd(n, c); else { var d = e.alternate; if (e.lanes === 0 && (d === null || d.lanes === 0) && (d = n.lastRenderedReducer, d !== null)) try { var g = n.lastRenderedState, x = d(g, o); if (c.hasEagerState = !0, c.eagerState = x, Lt(x, g)) { var E = n.interleaved; E === null ? (c.next = c, tl(n)) : (c.next = E.next, E.next = c), n.interleaved = c; return } } catch { } finally { } o = hd(e, n, c, a), o !== null && (c = nt(), Nt(o, e, a, c), Id(o, n, a)) } } function Vd(e) { var n = e.alternate; return e === Re || n !== null && n === Re } function jd(e, n) { Ei = Uo = !0; var o = e.pending; o === null ? n.next = n : (n.next = o.next, o.next = n), e.pending = n } function Id(e, n, o) { if (o & 4194240) { var a = n.lanes; a &= e.pendingLanes, o |= a, n.lanes = o, ya(e, o) } } var Ho = { readContext: St, useCallback: Ke, useContext: Ke, useEffect: Ke, useImperativeHandle: Ke, useInsertionEffect: Ke, useLayoutEffect: Ke, useMemo: Ke, useReducer: Ke, useRef: Ke, useState: Ke, useDebugValue: Ke, useDeferredValue: Ke, useTransition: Ke, useMutableSource: Ke, useSyncExternalStore: Ke, useId: Ke, unstable_isNewReconciler: !1 }, l0 = { readContext: St, useCallback: function (e, n) { return Ut().memoizedState = [e, n === void 0 ? null : n], e }, useContext: St, useEffect: Rd, useImperativeHandle: function (e, n, o) { return o = o != null ? o.concat([e]) : null, bo(4194308, 4, Dd.bind(null, n, e), o) }, useLayoutEffect: function (e, n) { return bo(4194308, 4, e, n) }, useInsertionEffect: function (e, n) { return bo(4, 2, e, n) }, useMemo: function (e, n) { var o = Ut(); return n = n === void 0 ? null : n, e = e(), o.memoizedState = [e, n], e }, useReducer: function (e, n, o) { var a = Ut(); return n = o !== void 0 ? o(n) : n, a.memoizedState = a.baseState = n, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: n }, a.queue = e, e = e.dispatch = s0.bind(null, Re, e), [a.memoizedState, e] }, useRef: function (e) { var n = Ut(); return e = { current: e }, n.memoizedState = e }, useState: Td, useDebugValue: pl, useDeferredValue: function (e) { return Ut().memoizedState = e }, useTransition: function () { var e = Td(!1), n = e[0]; return e = o0.bind(null, e[1]), Ut().memoizedState = e, [n, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, n, o) { var a = Re, c = Ut(); if (Ce) { if (o === void 0) throw Error(i(407)); o = o() } else { if (o = n(), Be === null) throw Error(i(349)); Wn & 30 || xd(a, n, o) } c.memoizedState = o; var d = { value: o, getSnapshot: n }; return c.queue = d, Rd(Ed.bind(null, a, d, e), [e]), a.flags |= 2048, Ti(9, Sd.bind(null, a, d, o, n), void 0, null), o }, useId: function () { var e = Ut(), n = Be.identifierPrefix; if (Ce) { var o = Xt, a = Qt; o = (a & ~(1 << 32 - At(a) - 1)).toString(32) + o, n = ":" + n + "R" + o, o = Pi++, 0 < o && (n += "H" + o.toString(32)), n += ":" } else o = i0++, n = ":" + n + "r" + o.toString(32) + ":"; return e.memoizedState = n }, unstable_isNewReconciler: !1 }, u0 = { readContext: St, useCallback: Md, useContext: St, useEffect: hl, useImperativeHandle: _d, useInsertionEffect: Ad, useLayoutEffect: Ld, useMemo: Od, useReducer: fl, useRef: kd, useState: function () { return fl(Ci) }, useDebugValue: pl, useDeferredValue: function (e) { var n = Et(); return Nd(n, Ve.memoizedState, e) }, useTransition: function () { var e = fl(Ci)[0], n = Et().memoizedState; return [e, n] }, useMutableSource: vd, useSyncExternalStore: wd, useId: Fd, unstable_isNewReconciler: !1 }, c0 = { readContext: St, useCallback: Md, useContext: St, useEffect: hl, useImperativeHandle: _d, useInsertionEffect: Ad, useLayoutEffect: Ld, useMemo: Od, useReducer: dl, useRef: kd, useState: function () { return dl(Ci) }, useDebugValue: pl, useDeferredValue: function (e) { var n = Et(); return Ve === null ? n.memoizedState = e : Nd(n, Ve.memoizedState, e) }, useTransition: function () { var e = dl(Ci)[0], n = Et().memoizedState; return [e, n] }, useMutableSource: vd, useSyncExternalStore: wd, useId: Fd, unstable_isNewReconciler: !1 }; function _t(e, n) { if (e && e.defaultProps) { n = K({}, n), e = e.defaultProps; for (var o in e) n[o] === void 0 && (n[o] = e[o]); return n } return n } function ml(e, n, o, a) { n = e.memoizedState, o = o(a, n), o = o == null ? n : K({}, n, o), e.memoizedState = o, e.lanes === 0 && (e.updateQueue.baseState = o) } var Wo = { isMounted: function (e) { return (e = e._reactInternals) ? In(e) === e : !1 }, enqueueSetState: function (e, n, o) { e = e._reactInternals; var a = nt(), c = kn(e), d = Jt(a, c); d.payload = n, o != null && (d.callback = o), n = En(e, d, c), n !== null && (Nt(n, e, c, a), jo(n, e, c)) }, enqueueReplaceState: function (e, n, o) { e = e._reactInternals; var a = nt(), c = kn(e), d = Jt(a, c); d.tag = 1, d.payload = n, o != null && (d.callback = o), n = En(e, d, c), n !== null && (Nt(n, e, c, a), jo(n, e, c)) }, enqueueForceUpdate: function (e, n) { e = e._reactInternals; var o = nt(), a = kn(e), c = Jt(o, a); c.tag = 2, n != null && (c.callback = n), n = En(e, c, a), n !== null && (Nt(n, e, a, o), jo(n, e, a)) } }; function Bd(e, n, o, a, c, d, g) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(a, d, g) : n.prototype && n.prototype.isPureReactComponent ? !fi(o, a) || !fi(c, d) : !0 } function zd(e, n, o) { var a = !1, c = wn, d = n.contextType; return typeof d == "object" && d !== null ? d = St(d) : (c = ot(n) ? zn : We.current, a = n.contextTypes, d = (a = a != null) ? wr(e, c) : wn), n = new n(o, d), e.memoizedState = n.state !== null && n.state !== void 0 ? n.state : null, n.updater = Wo, e.stateNode = n, n._reactInternals = e, a && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = c, e.__reactInternalMemoizedMaskedChildContext = d), n } function Ud(e, n, o, a) { e = n.state, typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps(o, a), typeof n.UNSAFE_componentWillReceiveProps == "function" && n.UNSAFE_componentWillReceiveProps(o, a), n.state !== e && Wo.enqueueReplaceState(n, n.state, null) } function yl(e, n, o, a) { var c = e.stateNode; c.props = o, c.state = e.memoizedState, c.refs = {}, nl(e); var d = n.contextType; typeof d == "object" && d !== null ? c.context = St(d) : (d = ot(n) ? zn : We.current, c.context = wr(e, d)), c.state = e.memoizedState, d = n.getDerivedStateFromProps, typeof d == "function" && (ml(e, n, d, o), c.state = e.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof c.getSnapshotBeforeUpdate == "function" || typeof c.UNSAFE_componentWillMount != "function" && typeof c.componentWillMount != "function" || (n = c.state, typeof c.componentWillMount == "function" && c.componentWillMount(), typeof c.UNSAFE_componentWillMount == "function" && c.UNSAFE_componentWillMount(), n !== c.state && Wo.enqueueReplaceState(c, c.state, null), Io(e, o, c, a), c.state = e.memoizedState), typeof c.componentDidMount == "function" && (e.flags |= 4194308) } function Rr(e, n) {
    try { var o = "", a = n; do o += de(a), a = a.return; while (a); var c = o } catch (d) {
      c = `
Error generating stack: `+ d.message + `
`+ d.stack
    } return { value: e, source: n, stack: c, digest: null }
  } function gl(e, n, o) { return { value: e, source: null, stack: o ?? null, digest: n ?? null } } function vl(e, n) { try { console.error(n.value) } catch (o) { setTimeout(function () { throw o }) } } var f0 = typeof WeakMap == "function" ? WeakMap : Map; function bd(e, n, o) { o = Jt(-1, o), o.tag = 3, o.payload = { element: null }; var a = n.value; return o.callback = function () { Jo || (Jo = !0, Ol = a), vl(e, n) }, o } function $d(e, n, o) { o = Jt(-1, o), o.tag = 3; var a = e.type.getDerivedStateFromError; if (typeof a == "function") { var c = n.value; o.payload = function () { return a(c) }, o.callback = function () { vl(e, n) } } var d = e.stateNode; return d !== null && typeof d.componentDidCatch == "function" && (o.callback = function () { vl(e, n), typeof a != "function" && (Cn === null ? Cn = new Set([this]) : Cn.add(this)); var g = n.stack; this.componentDidCatch(n.value, { componentStack: g !== null ? g : "" }) }), o } function Hd(e, n, o) { var a = e.pingCache; if (a === null) { a = e.pingCache = new f0; var c = new Set; a.set(n, c) } else c = a.get(n), c === void 0 && (c = new Set, a.set(n, c)); c.has(o) || (c.add(o), e = T0.bind(null, e, n, o), n.then(e, e)) } function Wd(e) { do { var n; if ((n = e.tag === 13) && (n = e.memoizedState, n = n !== null ? n.dehydrated !== null : !0), n) return e; e = e.return } while (e !== null); return null } function Kd(e, n, o, a, c) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = c, e) : (e === n ? e.flags |= 65536 : (e.flags |= 128, o.flags |= 131072, o.flags &= -52805, o.tag === 1 && (o.alternate === null ? o.tag = 17 : (n = Jt(-1, 1), n.tag = 2, En(o, n, 1))), o.lanes |= 1), e) } var d0 = b.ReactCurrentOwner, st = !1; function tt(e, n, o, a) { n.child = e === null ? dd(n, null, o, a) : Pr(n, e.child, o, a) } function qd(e, n, o, a, c) { o = o.render; var d = n.ref; return Tr(n, c), a = ul(e, n, o, a, d, c), o = cl(), e !== null && !st ? (n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~c, Zt(e, n, c)) : (Ce && o && Ka(n), n.flags |= 1, tt(e, n, a, c), n.child) } function Gd(e, n, o, a, c) { if (e === null) { var d = o.type; return typeof d == "function" && !zl(d) && d.defaultProps === void 0 && o.compare === null && o.defaultProps === void 0 ? (n.tag = 15, n.type = d, Qd(e, n, d, a, c)) : (e = is(o.type, null, a, n, n.mode, c), e.ref = n.ref, e.return = n, n.child = e) } if (d = e.child, !(e.lanes & c)) { var g = d.memoizedProps; if (o = o.compare, o = o !== null ? o : fi, o(g, a) && e.ref === n.ref) return Zt(e, n, c) } return n.flags |= 1, e = An(d, a), e.ref = n.ref, e.return = n, n.child = e } function Qd(e, n, o, a, c) { if (e !== null) { var d = e.memoizedProps; if (fi(d, a) && e.ref === n.ref) if (st = !1, n.pendingProps = a = d, (e.lanes & c) !== 0) e.flags & 131072 && (st = !0); else return n.lanes = e.lanes, Zt(e, n, c) } return wl(e, n, o, a, c) } function Xd(e, n, o) { var a = n.pendingProps, c = a.children, d = e !== null ? e.memoizedState : null; if (a.mode === "hidden") if (!(n.mode & 1)) n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, xe(Lr, yt), yt |= o; else { if (!(o & 1073741824)) return e = d !== null ? d.baseLanes | o : o, n.lanes = n.childLanes = 1073741824, n.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, n.updateQueue = null, xe(Lr, yt), yt |= e, null; n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, a = d !== null ? d.baseLanes : o, xe(Lr, yt), yt |= a } else d !== null ? (a = d.baseLanes | o, n.memoizedState = null) : a = o, xe(Lr, yt), yt |= a; return tt(e, n, c, o), n.child } function Yd(e, n) { var o = n.ref; (e === null && o !== null || e !== null && e.ref !== o) && (n.flags |= 512, n.flags |= 2097152) } function wl(e, n, o, a, c) { var d = ot(o) ? zn : We.current; return d = wr(n, d), Tr(n, c), o = ul(e, n, o, a, d, c), a = cl(), e !== null && !st ? (n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~c, Zt(e, n, c)) : (Ce && a && Ka(n), n.flags |= 1, tt(e, n, o, c), n.child) } function Jd(e, n, o, a, c) { if (ot(o)) { var d = !0; Lo(n) } else d = !1; if (Tr(n, c), n.stateNode === null) qo(e, n), zd(n, o, a), yl(n, o, a, c), a = !0; else if (e === null) { var g = n.stateNode, x = n.memoizedProps; g.props = x; var E = g.context, M = o.contextType; typeof M == "object" && M !== null ? M = St(M) : (M = ot(o) ? zn : We.current, M = wr(n, M)); var I = o.getDerivedStateFromProps, B = typeof I == "function" || typeof g.getSnapshotBeforeUpdate == "function"; B || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (x !== a || E !== M) && Ud(n, g, a, M), Sn = !1; var V = n.memoizedState; g.state = V, Io(n, a, g, c), E = n.memoizedState, x !== a || V !== E || it.current || Sn ? (typeof I == "function" && (ml(n, o, I, a), E = n.memoizedState), (x = Sn || Bd(n, o, x, a, V, E, M)) ? (B || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount == "function" && (n.flags |= 4194308)) : (typeof g.componentDidMount == "function" && (n.flags |= 4194308), n.memoizedProps = a, n.memoizedState = E), g.props = a, g.state = E, g.context = M, a = x) : (typeof g.componentDidMount == "function" && (n.flags |= 4194308), a = !1) } else { g = n.stateNode, pd(e, n), x = n.memoizedProps, M = n.type === n.elementType ? x : _t(n.type, x), g.props = M, B = n.pendingProps, V = g.context, E = o.contextType, typeof E == "object" && E !== null ? E = St(E) : (E = ot(o) ? zn : We.current, E = wr(n, E)); var W = o.getDerivedStateFromProps; (I = typeof W == "function" || typeof g.getSnapshotBeforeUpdate == "function") || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (x !== B || V !== E) && Ud(n, g, a, E), Sn = !1, V = n.memoizedState, g.state = V, Io(n, a, g, c); var G = n.memoizedState; x !== B || V !== G || it.current || Sn ? (typeof W == "function" && (ml(n, o, W, a), G = n.memoizedState), (M = Sn || Bd(n, o, M, a, V, G, E) || !1) ? (I || typeof g.UNSAFE_componentWillUpdate != "function" && typeof g.componentWillUpdate != "function" || (typeof g.componentWillUpdate == "function" && g.componentWillUpdate(a, G, E), typeof g.UNSAFE_componentWillUpdate == "function" && g.UNSAFE_componentWillUpdate(a, G, E)), typeof g.componentDidUpdate == "function" && (n.flags |= 4), typeof g.getSnapshotBeforeUpdate == "function" && (n.flags |= 1024)) : (typeof g.componentDidUpdate != "function" || x === e.memoizedProps && V === e.memoizedState || (n.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || x === e.memoizedProps && V === e.memoizedState || (n.flags |= 1024), n.memoizedProps = a, n.memoizedState = G), g.props = a, g.state = G, g.context = E, a = M) : (typeof g.componentDidUpdate != "function" || x === e.memoizedProps && V === e.memoizedState || (n.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || x === e.memoizedProps && V === e.memoizedState || (n.flags |= 1024), a = !1) } return xl(e, n, o, a, d, c) } function xl(e, n, o, a, c, d) { Yd(e, n); var g = (n.flags & 128) !== 0; if (!a && !g) return c && rd(n, o, !1), Zt(e, n, d); a = n.stateNode, d0.current = n; var x = g && typeof o.getDerivedStateFromError != "function" ? null : a.render(); return n.flags |= 1, e !== null && g ? (n.child = Pr(n, e.child, null, d), n.child = Pr(n, null, x, d)) : tt(e, n, x, d), n.memoizedState = a.state, c && rd(n, o, !0), n.child } function Zd(e) { var n = e.stateNode; n.pendingContext ? td(e, n.pendingContext, n.pendingContext !== n.context) : n.context && td(e, n.context, !1), rl(e, n.containerInfo) } function eh(e, n, o, a, c) { return Er(), Xa(c), n.flags |= 256, tt(e, n, o, a), n.child } var Sl = { dehydrated: null, treeContext: null, retryLane: 0 }; function El(e) { return { baseLanes: e, cachePool: null, transitions: null } } function th(e, n, o) { var a = n.pendingProps, c = ke.current, d = !1, g = (n.flags & 128) !== 0, x; if ((x = g) || (x = e !== null && e.memoizedState === null ? !1 : (c & 2) !== 0), x ? (d = !0, n.flags &= -129) : (e === null || e.memoizedState !== null) && (c |= 1), xe(ke, c & 1), e === null) return Qa(n), e = n.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (n.mode & 1 ? e.data === "$!" ? n.lanes = 8 : n.lanes = 1073741824 : n.lanes = 1, null) : (g = a.children, e = a.fallback, d ? (a = n.mode, d = n.child, g = { mode: "hidden", children: g }, !(a & 1) && d !== null ? (d.childLanes = 0, d.pendingProps = g) : d = os(g, a, 0, null), e = Xn(e, a, o, null), d.return = n, e.return = n, d.sibling = e, n.child = d, n.child.memoizedState = El(o), n.memoizedState = Sl, e) : Pl(n, g)); if (c = e.memoizedState, c !== null && (x = c.dehydrated, x !== null)) return h0(e, n, g, a, x, c, o); if (d) { d = a.fallback, g = n.mode, c = e.child, x = c.sibling; var E = { mode: "hidden", children: a.children }; return !(g & 1) && n.child !== c ? (a = n.child, a.childLanes = 0, a.pendingProps = E, n.deletions = null) : (a = An(c, E), a.subtreeFlags = c.subtreeFlags & 14680064), x !== null ? d = An(x, d) : (d = Xn(d, g, o, null), d.flags |= 2), d.return = n, a.return = n, a.sibling = d, n.child = a, a = d, d = n.child, g = e.child.memoizedState, g = g === null ? El(o) : { baseLanes: g.baseLanes | o, cachePool: null, transitions: g.transitions }, d.memoizedState = g, d.childLanes = e.childLanes & ~o, n.memoizedState = Sl, a } return d = e.child, e = d.sibling, a = An(d, { mode: "visible", children: a.children }), !(n.mode & 1) && (a.lanes = o), a.return = n, a.sibling = null, e !== null && (o = n.deletions, o === null ? (n.deletions = [e], n.flags |= 16) : o.push(e)), n.child = a, n.memoizedState = null, a } function Pl(e, n) { return n = os({ mode: "visible", children: n }, e.mode, 0, null), n.return = e, e.child = n } function Ko(e, n, o, a) { return a !== null && Xa(a), Pr(n, e.child, null, o), e = Pl(n, n.pendingProps.children), e.flags |= 2, n.memoizedState = null, e } function h0(e, n, o, a, c, d, g) { if (o) return n.flags & 256 ? (n.flags &= -257, a = gl(Error(i(422))), Ko(e, n, g, a)) : n.memoizedState !== null ? (n.child = e.child, n.flags |= 128, null) : (d = a.fallback, c = n.mode, a = os({ mode: "visible", children: a.children }, c, 0, null), d = Xn(d, c, g, null), d.flags |= 2, a.return = n, d.return = n, a.sibling = d, n.child = a, n.mode & 1 && Pr(n, e.child, null, g), n.child.memoizedState = El(g), n.memoizedState = Sl, d); if (!(n.mode & 1)) return Ko(e, n, g, null); if (c.data === "$!") { if (a = c.nextSibling && c.nextSibling.dataset, a) var x = a.dgst; return a = x, d = Error(i(419)), a = gl(d, a, void 0), Ko(e, n, g, a) } if (x = (g & e.childLanes) !== 0, st || x) { if (a = Be, a !== null) { switch (g & -g) { case 4: c = 2; break; case 16: c = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: c = 32; break; case 536870912: c = 268435456; break; default: c = 0 }c = c & (a.suspendedLanes | g) ? 0 : c, c !== 0 && c !== d.retryLane && (d.retryLane = c, Yt(e, c), Nt(a, e, c, -1)) } return Bl(), a = gl(Error(i(421))), Ko(e, n, g, a) } return c.data === "$?" ? (n.flags |= 128, n.child = e.child, n = k0.bind(null, e), c._reactRetry = n, null) : (e = d.treeContext, mt = gn(c.nextSibling), pt = n, Ce = !0, Dt = null, e !== null && (wt[xt++] = Qt, wt[xt++] = Xt, wt[xt++] = Un, Qt = e.id, Xt = e.overflow, Un = n), n = Pl(n, a.children), n.flags |= 4096, n) } function nh(e, n, o) { e.lanes |= n; var a = e.alternate; a !== null && (a.lanes |= n), el(e.return, n, o) } function Cl(e, n, o, a, c) { var d = e.memoizedState; d === null ? e.memoizedState = { isBackwards: n, rendering: null, renderingStartTime: 0, last: a, tail: o, tailMode: c } : (d.isBackwards = n, d.rendering = null, d.renderingStartTime = 0, d.last = a, d.tail = o, d.tailMode = c) } function rh(e, n, o) { var a = n.pendingProps, c = a.revealOrder, d = a.tail; if (tt(e, n, a.children, o), a = ke.current, a & 2) a = a & 1 | 2, n.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = n.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && nh(e, o, n); else if (e.tag === 19) nh(e, o, n); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === n) break e; for (; e.sibling === null;) { if (e.return === null || e.return === n) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } a &= 1 } if (xe(ke, a), !(n.mode & 1)) n.memoizedState = null; else switch (c) { case "forwards": for (o = n.child, c = null; o !== null;)e = o.alternate, e !== null && Bo(e) === null && (c = o), o = o.sibling; o = c, o === null ? (c = n.child, n.child = null) : (c = o.sibling, o.sibling = null), Cl(n, !1, c, o, d); break; case "backwards": for (o = null, c = n.child, n.child = null; c !== null;) { if (e = c.alternate, e !== null && Bo(e) === null) { n.child = c; break } e = c.sibling, c.sibling = o, o = c, c = e } Cl(n, !0, o, null, d); break; case "together": Cl(n, !1, null, null, void 0); break; default: n.memoizedState = null }return n.child } function qo(e, n) { !(n.mode & 1) && e !== null && (e.alternate = null, n.alternate = null, n.flags |= 2) } function Zt(e, n, o) { if (e !== null && (n.dependencies = e.dependencies), Kn |= n.lanes, !(o & n.childLanes)) return null; if (e !== null && n.child !== e.child) throw Error(i(153)); if (n.child !== null) { for (e = n.child, o = An(e, e.pendingProps), n.child = o, o.return = n; e.sibling !== null;)e = e.sibling, o = o.sibling = An(e, e.pendingProps), o.return = n; o.sibling = null } return n.child } function p0(e, n, o) { switch (n.tag) { case 3: Zd(n), Er(); break; case 5: gd(n); break; case 1: ot(n.type) && Lo(n); break; case 4: rl(n, n.stateNode.containerInfo); break; case 10: var a = n.type._context, c = n.memoizedProps.value; xe(Fo, a._currentValue), a._currentValue = c; break; case 13: if (a = n.memoizedState, a !== null) return a.dehydrated !== null ? (xe(ke, ke.current & 1), n.flags |= 128, null) : o & n.child.childLanes ? th(e, n, o) : (xe(ke, ke.current & 1), e = Zt(e, n, o), e !== null ? e.sibling : null); xe(ke, ke.current & 1); break; case 19: if (a = (o & n.childLanes) !== 0, e.flags & 128) { if (a) return rh(e, n, o); n.flags |= 128 } if (c = n.memoizedState, c !== null && (c.rendering = null, c.tail = null, c.lastEffect = null), xe(ke, ke.current), a) break; return null; case 22: case 23: return n.lanes = 0, Xd(e, n, o) }return Zt(e, n, o) } var ih, Tl, oh, sh; ih = function (e, n) { for (var o = n.child; o !== null;) { if (o.tag === 5 || o.tag === 6) e.appendChild(o.stateNode); else if (o.tag !== 4 && o.child !== null) { o.child.return = o, o = o.child; continue } if (o === n) break; for (; o.sibling === null;) { if (o.return === null || o.return === n) return; o = o.return } o.sibling.return = o.return, o = o.sibling } }, Tl = function () { }, oh = function (e, n, o, a) { var c = e.memoizedProps; if (c !== a) { e = n.stateNode, Hn(zt.current); var d = null; switch (o) { case "input": c = ea(e, c), a = ea(e, a), d = []; break; case "select": c = K({}, c, { value: void 0 }), a = K({}, a, { value: void 0 }), d = []; break; case "textarea": c = ra(e, c), a = ra(e, a), d = []; break; default: typeof c.onClick != "function" && typeof a.onClick == "function" && (e.onclick = ko) }oa(o, a); var g; o = null; for (M in c) if (!a.hasOwnProperty(M) && c.hasOwnProperty(M) && c[M] != null) if (M === "style") { var x = c[M]; for (g in x) x.hasOwnProperty(g) && (o || (o = {}), o[g] = "") } else M !== "dangerouslySetInnerHTML" && M !== "children" && M !== "suppressContentEditableWarning" && M !== "suppressHydrationWarning" && M !== "autoFocus" && (l.hasOwnProperty(M) ? d || (d = []) : (d = d || []).push(M, null)); for (M in a) { var E = a[M]; if (x = c != null ? c[M] : void 0, a.hasOwnProperty(M) && E !== x && (E != null || x != null)) if (M === "style") if (x) { for (g in x) !x.hasOwnProperty(g) || E && E.hasOwnProperty(g) || (o || (o = {}), o[g] = ""); for (g in E) E.hasOwnProperty(g) && x[g] !== E[g] && (o || (o = {}), o[g] = E[g]) } else o || (d || (d = []), d.push(M, o)), o = E; else M === "dangerouslySetInnerHTML" ? (E = E ? E.__html : void 0, x = x ? x.__html : void 0, E != null && x !== E && (d = d || []).push(M, E)) : M === "children" ? typeof E != "string" && typeof E != "number" || (d = d || []).push(M, "" + E) : M !== "suppressContentEditableWarning" && M !== "suppressHydrationWarning" && (l.hasOwnProperty(M) ? (E != null && M === "onScroll" && Se("scroll", e), d || x === E || (d = [])) : (d = d || []).push(M, E)) } o && (d = d || []).push("style", o); var M = d; (n.updateQueue = M) && (n.flags |= 4) } }, sh = function (e, n, o, a) { o !== a && (n.flags |= 4) }; function ki(e, n) { if (!Ce) switch (e.tailMode) { case "hidden": n = e.tail; for (var o = null; n !== null;)n.alternate !== null && (o = n), n = n.sibling; o === null ? e.tail = null : o.sibling = null; break; case "collapsed": o = e.tail; for (var a = null; o !== null;)o.alternate !== null && (a = o), o = o.sibling; a === null ? n || e.tail === null ? e.tail = null : e.tail.sibling = null : a.sibling = null } } function qe(e) { var n = e.alternate !== null && e.alternate.child === e.child, o = 0, a = 0; if (n) for (var c = e.child; c !== null;)o |= c.lanes | c.childLanes, a |= c.subtreeFlags & 14680064, a |= c.flags & 14680064, c.return = e, c = c.sibling; else for (c = e.child; c !== null;)o |= c.lanes | c.childLanes, a |= c.subtreeFlags, a |= c.flags, c.return = e, c = c.sibling; return e.subtreeFlags |= a, e.childLanes = o, n } function m0(e, n, o) { var a = n.pendingProps; switch (qa(n), n.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return qe(n), null; case 1: return ot(n.type) && Ao(), qe(n), null; case 3: return a = n.stateNode, kr(), Ee(it), Ee(We), sl(), a.pendingContext && (a.context = a.pendingContext, a.pendingContext = null), (e === null || e.child === null) && (Oo(n) ? n.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(n.flags & 256) || (n.flags |= 1024, Dt !== null && (Vl(Dt), Dt = null))), Tl(e, n), qe(n), null; case 5: il(n); var c = Hn(Si.current); if (o = n.type, e !== null && n.stateNode != null) oh(e, n, o, a, c), e.ref !== n.ref && (n.flags |= 512, n.flags |= 2097152); else { if (!a) { if (n.stateNode === null) throw Error(i(166)); return qe(n), null } if (e = Hn(zt.current), Oo(n)) { a = n.stateNode, o = n.type; var d = n.memoizedProps; switch (a[Bt] = n, a[yi] = d, e = (n.mode & 1) !== 0, o) { case "dialog": Se("cancel", a), Se("close", a); break; case "iframe": case "object": case "embed": Se("load", a); break; case "video": case "audio": for (c = 0; c < hi.length; c++)Se(hi[c], a); break; case "source": Se("error", a); break; case "img": case "image": case "link": Se("error", a), Se("load", a); break; case "details": Se("toggle", a); break; case "input": Bc(a, d), Se("invalid", a); break; case "select": a._wrapperState = { wasMultiple: !!d.multiple }, Se("invalid", a); break; case "textarea": bc(a, d), Se("invalid", a) }oa(o, d), c = null; for (var g in d) if (d.hasOwnProperty(g)) { var x = d[g]; g === "children" ? typeof x == "string" ? a.textContent !== x && (d.suppressHydrationWarning !== !0 && To(a.textContent, x, e), c = ["children", x]) : typeof x == "number" && a.textContent !== "" + x && (d.suppressHydrationWarning !== !0 && To(a.textContent, x, e), c = ["children", "" + x]) : l.hasOwnProperty(g) && x != null && g === "onScroll" && Se("scroll", a) } switch (o) { case "input": to(a), Uc(a, d, !0); break; case "textarea": to(a), Hc(a); break; case "select": case "option": break; default: typeof d.onClick == "function" && (a.onclick = ko) }a = c, n.updateQueue = a, a !== null && (n.flags |= 4) } else { g = c.nodeType === 9 ? c : c.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Wc(o)), e === "http://www.w3.org/1999/xhtml" ? o === "script" ? (e = g.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof a.is == "string" ? e = g.createElement(o, { is: a.is }) : (e = g.createElement(o), o === "select" && (g = e, a.multiple ? g.multiple = !0 : a.size && (g.size = a.size))) : e = g.createElementNS(e, o), e[Bt] = n, e[yi] = a, ih(e, n, !1, !1), n.stateNode = e; e: { switch (g = sa(o, a), o) { case "dialog": Se("cancel", e), Se("close", e), c = a; break; case "iframe": case "object": case "embed": Se("load", e), c = a; break; case "video": case "audio": for (c = 0; c < hi.length; c++)Se(hi[c], e); c = a; break; case "source": Se("error", e), c = a; break; case "img": case "image": case "link": Se("error", e), Se("load", e), c = a; break; case "details": Se("toggle", e), c = a; break; case "input": Bc(e, a), c = ea(e, a), Se("invalid", e); break; case "option": c = a; break; case "select": e._wrapperState = { wasMultiple: !!a.multiple }, c = K({}, a, { value: void 0 }), Se("invalid", e); break; case "textarea": bc(e, a), c = ra(e, a), Se("invalid", e); break; default: c = a }oa(o, c), x = c; for (d in x) if (x.hasOwnProperty(d)) { var E = x[d]; d === "style" ? Gc(e, E) : d === "dangerouslySetInnerHTML" ? (E = E ? E.__html : void 0, E != null && Kc(e, E)) : d === "children" ? typeof E == "string" ? (o !== "textarea" || E !== "") && Gr(e, E) : typeof E == "number" && Gr(e, "" + E) : d !== "suppressContentEditableWarning" && d !== "suppressHydrationWarning" && d !== "autoFocus" && (l.hasOwnProperty(d) ? E != null && d === "onScroll" && Se("scroll", e) : E != null && F(e, d, E, g)) } switch (o) { case "input": to(e), Uc(e, a, !1); break; case "textarea": to(e), Hc(e); break; case "option": a.value != null && e.setAttribute("value", "" + ye(a.value)); break; case "select": e.multiple = !!a.multiple, d = a.value, d != null ? ar(e, !!a.multiple, d, !1) : a.defaultValue != null && ar(e, !!a.multiple, a.defaultValue, !0); break; default: typeof c.onClick == "function" && (e.onclick = ko) }switch (o) { case "button": case "input": case "select": case "textarea": a = !!a.autoFocus; break e; case "img": a = !0; break e; default: a = !1 } } a && (n.flags |= 4) } n.ref !== null && (n.flags |= 512, n.flags |= 2097152) } return qe(n), null; case 6: if (e && n.stateNode != null) sh(e, n, e.memoizedProps, a); else { if (typeof a != "string" && n.stateNode === null) throw Error(i(166)); if (o = Hn(Si.current), Hn(zt.current), Oo(n)) { if (a = n.stateNode, o = n.memoizedProps, a[Bt] = n, (d = a.nodeValue !== o) && (e = pt, e !== null)) switch (e.tag) { case 3: To(a.nodeValue, o, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && To(a.nodeValue, o, (e.mode & 1) !== 0) }d && (n.flags |= 4) } else a = (o.nodeType === 9 ? o : o.ownerDocument).createTextNode(a), a[Bt] = n, n.stateNode = a } return qe(n), null; case 13: if (Ee(ke), a = n.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (Ce && mt !== null && n.mode & 1 && !(n.flags & 128)) ud(), Er(), n.flags |= 98560, d = !1; else if (d = Oo(n), a !== null && a.dehydrated !== null) { if (e === null) { if (!d) throw Error(i(318)); if (d = n.memoizedState, d = d !== null ? d.dehydrated : null, !d) throw Error(i(317)); d[Bt] = n } else Er(), !(n.flags & 128) && (n.memoizedState = null), n.flags |= 4; qe(n), d = !1 } else Dt !== null && (Vl(Dt), Dt = null), d = !0; if (!d) return n.flags & 65536 ? n : null } return n.flags & 128 ? (n.lanes = o, n) : (a = a !== null, a !== (e !== null && e.memoizedState !== null) && a && (n.child.flags |= 8192, n.mode & 1 && (e === null || ke.current & 1 ? je === 0 && (je = 3) : Bl())), n.updateQueue !== null && (n.flags |= 4), qe(n), null); case 4: return kr(), Tl(e, n), e === null && pi(n.stateNode.containerInfo), qe(n), null; case 10: return Za(n.type._context), qe(n), null; case 17: return ot(n.type) && Ao(), qe(n), null; case 19: if (Ee(ke), d = n.memoizedState, d === null) return qe(n), null; if (a = (n.flags & 128) !== 0, g = d.rendering, g === null) if (a) ki(d, !1); else { if (je !== 0 || e !== null && e.flags & 128) for (e = n.child; e !== null;) { if (g = Bo(e), g !== null) { for (n.flags |= 128, ki(d, !1), a = g.updateQueue, a !== null && (n.updateQueue = a, n.flags |= 4), n.subtreeFlags = 0, a = o, o = n.child; o !== null;)d = o, e = a, d.flags &= 14680066, g = d.alternate, g === null ? (d.childLanes = 0, d.lanes = e, d.child = null, d.subtreeFlags = 0, d.memoizedProps = null, d.memoizedState = null, d.updateQueue = null, d.dependencies = null, d.stateNode = null) : (d.childLanes = g.childLanes, d.lanes = g.lanes, d.child = g.child, d.subtreeFlags = 0, d.deletions = null, d.memoizedProps = g.memoizedProps, d.memoizedState = g.memoizedState, d.updateQueue = g.updateQueue, d.type = g.type, e = g.dependencies, d.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), o = o.sibling; return xe(ke, ke.current & 1 | 2), n.child } e = e.sibling } d.tail !== null && _e() > Dr && (n.flags |= 128, a = !0, ki(d, !1), n.lanes = 4194304) } else { if (!a) if (e = Bo(g), e !== null) { if (n.flags |= 128, a = !0, o = e.updateQueue, o !== null && (n.updateQueue = o, n.flags |= 4), ki(d, !0), d.tail === null && d.tailMode === "hidden" && !g.alternate && !Ce) return qe(n), null } else 2 * _e() - d.renderingStartTime > Dr && o !== 1073741824 && (n.flags |= 128, a = !0, ki(d, !1), n.lanes = 4194304); d.isBackwards ? (g.sibling = n.child, n.child = g) : (o = d.last, o !== null ? o.sibling = g : n.child = g, d.last = g) } return d.tail !== null ? (n = d.tail, d.rendering = n, d.tail = n.sibling, d.renderingStartTime = _e(), n.sibling = null, o = ke.current, xe(ke, a ? o & 1 | 2 : o & 1), n) : (qe(n), null); case 22: case 23: return Il(), a = n.memoizedState !== null, e !== null && e.memoizedState !== null !== a && (n.flags |= 8192), a && n.mode & 1 ? yt & 1073741824 && (qe(n), n.subtreeFlags & 6 && (n.flags |= 8192)) : qe(n), null; case 24: return null; case 25: return null }throw Error(i(156, n.tag)) } function y0(e, n) { switch (qa(n), n.tag) { case 1: return ot(n.type) && Ao(), e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 3: return kr(), Ee(it), Ee(We), sl(), e = n.flags, e & 65536 && !(e & 128) ? (n.flags = e & -65537 | 128, n) : null; case 5: return il(n), null; case 13: if (Ee(ke), e = n.memoizedState, e !== null && e.dehydrated !== null) { if (n.alternate === null) throw Error(i(340)); Er() } return e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 19: return Ee(ke), null; case 4: return kr(), null; case 10: return Za(n.type._context), null; case 22: case 23: return Il(), null; case 24: return null; default: return null } } var Go = !1, Ge = !1, g0 = typeof WeakSet == "function" ? WeakSet : Set, q = null; function Ar(e, n) { var o = e.ref; if (o !== null) if (typeof o == "function") try { o(null) } catch (a) { Le(e, n, a) } else o.current = null } function kl(e, n, o) { try { o() } catch (a) { Le(e, n, a) } } var ah = !1; function v0(e, n) { if (Ia = po, e = Bf(), Da(e)) { if ("selectionStart" in e) var o = { start: e.selectionStart, end: e.selectionEnd }; else e: { o = (o = e.ownerDocument) && o.defaultView || window; var a = o.getSelection && o.getSelection(); if (a && a.rangeCount !== 0) { o = a.anchorNode; var c = a.anchorOffset, d = a.focusNode; a = a.focusOffset; try { o.nodeType, d.nodeType } catch { o = null; break e } var g = 0, x = -1, E = -1, M = 0, I = 0, B = e, V = null; t: for (; ;) { for (var W; B !== o || c !== 0 && B.nodeType !== 3 || (x = g + c), B !== d || a !== 0 && B.nodeType !== 3 || (E = g + a), B.nodeType === 3 && (g += B.nodeValue.length), (W = B.firstChild) !== null;)V = B, B = W; for (; ;) { if (B === e) break t; if (V === o && ++M === c && (x = g), V === d && ++I === a && (E = g), (W = B.nextSibling) !== null) break; B = V, V = B.parentNode } B = W } o = x === -1 || E === -1 ? null : { start: x, end: E } } else o = null } o = o || { start: 0, end: 0 } } else o = null; for (Ba = { focusedElem: e, selectionRange: o }, po = !1, q = n; q !== null;)if (n = q, e = n.child, (n.subtreeFlags & 1028) !== 0 && e !== null) e.return = n, q = e; else for (; q !== null;) { n = q; try { var G = n.alternate; if (n.flags & 1024) switch (n.tag) { case 0: case 11: case 15: break; case 1: if (G !== null) { var X = G.memoizedProps, Me = G.memoizedState, D = n.stateNode, T = D.getSnapshotBeforeUpdate(n.elementType === n.type ? X : _t(n.type, X), Me); D.__reactInternalSnapshotBeforeUpdate = T } break; case 3: var _ = n.stateNode.containerInfo; _.nodeType === 1 ? _.textContent = "" : _.nodeType === 9 && _.documentElement && _.removeChild(_.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(i(163)) } } catch (U) { Le(n, n.return, U) } if (e = n.sibling, e !== null) { e.return = n.return, q = e; break } q = n.return } return G = ah, ah = !1, G } function Ri(e, n, o) { var a = n.updateQueue; if (a = a !== null ? a.lastEffect : null, a !== null) { var c = a = a.next; do { if ((c.tag & e) === e) { var d = c.destroy; c.destroy = void 0, d !== void 0 && kl(n, o, d) } c = c.next } while (c !== a) } } function Qo(e, n) { if (n = n.updateQueue, n = n !== null ? n.lastEffect : null, n !== null) { var o = n = n.next; do { if ((o.tag & e) === e) { var a = o.create; o.destroy = a() } o = o.next } while (o !== n) } } function Rl(e) { var n = e.ref; if (n !== null) { var o = e.stateNode; switch (e.tag) { case 5: e = o; break; default: e = o }typeof n == "function" ? n(e) : n.current = e } } function lh(e) { var n = e.alternate; n !== null && (e.alternate = null, lh(n)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (n = e.stateNode, n !== null && (delete n[Bt], delete n[yi], delete n[$a], delete n[e0], delete n[t0])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function uh(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function ch(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || uh(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function Al(e, n, o) { var a = e.tag; if (a === 5 || a === 6) e = e.stateNode, n ? o.nodeType === 8 ? o.parentNode.insertBefore(e, n) : o.insertBefore(e, n) : (o.nodeType === 8 ? (n = o.parentNode, n.insertBefore(e, o)) : (n = o, n.appendChild(e)), o = o._reactRootContainer, o != null || n.onclick !== null || (n.onclick = ko)); else if (a !== 4 && (e = e.child, e !== null)) for (Al(e, n, o), e = e.sibling; e !== null;)Al(e, n, o), e = e.sibling } function Ll(e, n, o) { var a = e.tag; if (a === 5 || a === 6) e = e.stateNode, n ? o.insertBefore(e, n) : o.appendChild(e); else if (a !== 4 && (e = e.child, e !== null)) for (Ll(e, n, o), e = e.sibling; e !== null;)Ll(e, n, o), e = e.sibling } var be = null, Mt = !1; function Pn(e, n, o) { for (o = o.child; o !== null;)fh(e, n, o), o = o.sibling } function fh(e, n, o) { if (It && typeof It.onCommitFiberUnmount == "function") try { It.onCommitFiberUnmount(ao, o) } catch { } switch (o.tag) { case 5: Ge || Ar(o, n); case 6: var a = be, c = Mt; be = null, Pn(e, n, o), be = a, Mt = c, be !== null && (Mt ? (e = be, o = o.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(o) : e.removeChild(o)) : be.removeChild(o.stateNode)); break; case 18: be !== null && (Mt ? (e = be, o = o.stateNode, e.nodeType === 8 ? ba(e.parentNode, o) : e.nodeType === 1 && ba(e, o), oi(e)) : ba(be, o.stateNode)); break; case 4: a = be, c = Mt, be = o.stateNode.containerInfo, Mt = !0, Pn(e, n, o), be = a, Mt = c; break; case 0: case 11: case 14: case 15: if (!Ge && (a = o.updateQueue, a !== null && (a = a.lastEffect, a !== null))) { c = a = a.next; do { var d = c, g = d.destroy; d = d.tag, g !== void 0 && (d & 2 || d & 4) && kl(o, n, g), c = c.next } while (c !== a) } Pn(e, n, o); break; case 1: if (!Ge && (Ar(o, n), a = o.stateNode, typeof a.componentWillUnmount == "function")) try { a.props = o.memoizedProps, a.state = o.memoizedState, a.componentWillUnmount() } catch (x) { Le(o, n, x) } Pn(e, n, o); break; case 21: Pn(e, n, o); break; case 22: o.mode & 1 ? (Ge = (a = Ge) || o.memoizedState !== null, Pn(e, n, o), Ge = a) : Pn(e, n, o); break; default: Pn(e, n, o) } } function dh(e) { var n = e.updateQueue; if (n !== null) { e.updateQueue = null; var o = e.stateNode; o === null && (o = e.stateNode = new g0), n.forEach(function (a) { var c = R0.bind(null, e, a); o.has(a) || (o.add(a), a.then(c, c)) }) } } function Ot(e, n) { var o = n.deletions; if (o !== null) for (var a = 0; a < o.length; a++) { var c = o[a]; try { var d = e, g = n, x = g; e: for (; x !== null;) { switch (x.tag) { case 5: be = x.stateNode, Mt = !1; break e; case 3: be = x.stateNode.containerInfo, Mt = !0; break e; case 4: be = x.stateNode.containerInfo, Mt = !0; break e }x = x.return } if (be === null) throw Error(i(160)); fh(d, g, c), be = null, Mt = !1; var E = c.alternate; E !== null && (E.return = null), c.return = null } catch (M) { Le(c, n, M) } } if (n.subtreeFlags & 12854) for (n = n.child; n !== null;)hh(n, e), n = n.sibling } function hh(e, n) { var o = e.alternate, a = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Ot(n, e), bt(e), a & 4) { try { Ri(3, e, e.return), Qo(3, e) } catch (X) { Le(e, e.return, X) } try { Ri(5, e, e.return) } catch (X) { Le(e, e.return, X) } } break; case 1: Ot(n, e), bt(e), a & 512 && o !== null && Ar(o, o.return); break; case 5: if (Ot(n, e), bt(e), a & 512 && o !== null && Ar(o, o.return), e.flags & 32) { var c = e.stateNode; try { Gr(c, "") } catch (X) { Le(e, e.return, X) } } if (a & 4 && (c = e.stateNode, c != null)) { var d = e.memoizedProps, g = o !== null ? o.memoizedProps : d, x = e.type, E = e.updateQueue; if (e.updateQueue = null, E !== null) try { x === "input" && d.type === "radio" && d.name != null && zc(c, d), sa(x, g); var M = sa(x, d); for (g = 0; g < E.length; g += 2) { var I = E[g], B = E[g + 1]; I === "style" ? Gc(c, B) : I === "dangerouslySetInnerHTML" ? Kc(c, B) : I === "children" ? Gr(c, B) : F(c, I, B, M) } switch (x) { case "input": ta(c, d); break; case "textarea": $c(c, d); break; case "select": var V = c._wrapperState.wasMultiple; c._wrapperState.wasMultiple = !!d.multiple; var W = d.value; W != null ? ar(c, !!d.multiple, W, !1) : V !== !!d.multiple && (d.defaultValue != null ? ar(c, !!d.multiple, d.defaultValue, !0) : ar(c, !!d.multiple, d.multiple ? [] : "", !1)) }c[yi] = d } catch (X) { Le(e, e.return, X) } } break; case 6: if (Ot(n, e), bt(e), a & 4) { if (e.stateNode === null) throw Error(i(162)); c = e.stateNode, d = e.memoizedProps; try { c.nodeValue = d } catch (X) { Le(e, e.return, X) } } break; case 3: if (Ot(n, e), bt(e), a & 4 && o !== null && o.memoizedState.isDehydrated) try { oi(n.containerInfo) } catch (X) { Le(e, e.return, X) } break; case 4: Ot(n, e), bt(e); break; case 13: Ot(n, e), bt(e), c = e.child, c.flags & 8192 && (d = c.memoizedState !== null, c.stateNode.isHidden = d, !d || c.alternate !== null && c.alternate.memoizedState !== null || (Ml = _e())), a & 4 && dh(e); break; case 22: if (I = o !== null && o.memoizedState !== null, e.mode & 1 ? (Ge = (M = Ge) || I, Ot(n, e), Ge = M) : Ot(n, e), bt(e), a & 8192) { if (M = e.memoizedState !== null, (e.stateNode.isHidden = M) && !I && e.mode & 1) for (q = e, I = e.child; I !== null;) { for (B = q = I; q !== null;) { switch (V = q, W = V.child, V.tag) { case 0: case 11: case 14: case 15: Ri(4, V, V.return); break; case 1: Ar(V, V.return); var G = V.stateNode; if (typeof G.componentWillUnmount == "function") { a = V, o = V.return; try { n = a, G.props = n.memoizedProps, G.state = n.memoizedState, G.componentWillUnmount() } catch (X) { Le(a, o, X) } } break; case 5: Ar(V, V.return); break; case 22: if (V.memoizedState !== null) { yh(B); continue } }W !== null ? (W.return = V, q = W) : yh(B) } I = I.sibling } e: for (I = null, B = e; ;) { if (B.tag === 5) { if (I === null) { I = B; try { c = B.stateNode, M ? (d = c.style, typeof d.setProperty == "function" ? d.setProperty("display", "none", "important") : d.display = "none") : (x = B.stateNode, E = B.memoizedProps.style, g = E != null && E.hasOwnProperty("display") ? E.display : null, x.style.display = qc("display", g)) } catch (X) { Le(e, e.return, X) } } } else if (B.tag === 6) { if (I === null) try { B.stateNode.nodeValue = M ? "" : B.memoizedProps } catch (X) { Le(e, e.return, X) } } else if ((B.tag !== 22 && B.tag !== 23 || B.memoizedState === null || B === e) && B.child !== null) { B.child.return = B, B = B.child; continue } if (B === e) break e; for (; B.sibling === null;) { if (B.return === null || B.return === e) break e; I === B && (I = null), B = B.return } I === B && (I = null), B.sibling.return = B.return, B = B.sibling } } break; case 19: Ot(n, e), bt(e), a & 4 && dh(e); break; case 21: break; default: Ot(n, e), bt(e) } } function bt(e) { var n = e.flags; if (n & 2) { try { e: { for (var o = e.return; o !== null;) { if (uh(o)) { var a = o; break e } o = o.return } throw Error(i(160)) } switch (a.tag) { case 5: var c = a.stateNode; a.flags & 32 && (Gr(c, ""), a.flags &= -33); var d = ch(e); Ll(e, d, c); break; case 3: case 4: var g = a.stateNode.containerInfo, x = ch(e); Al(e, x, g); break; default: throw Error(i(161)) } } catch (E) { Le(e, e.return, E) } e.flags &= -3 } n & 4096 && (e.flags &= -4097) } function w0(e, n, o) { q = e, ph(e) } function ph(e, n, o) { for (var a = (e.mode & 1) !== 0; q !== null;) { var c = q, d = c.child; if (c.tag === 22 && a) { var g = c.memoizedState !== null || Go; if (!g) { var x = c.alternate, E = x !== null && x.memoizedState !== null || Ge; x = Go; var M = Ge; if (Go = g, (Ge = E) && !M) for (q = c; q !== null;)g = q, E = g.child, g.tag === 22 && g.memoizedState !== null ? gh(c) : E !== null ? (E.return = g, q = E) : gh(c); for (; d !== null;)q = d, ph(d), d = d.sibling; q = c, Go = x, Ge = M } mh(e) } else c.subtreeFlags & 8772 && d !== null ? (d.return = c, q = d) : mh(e) } } function mh(e) { for (; q !== null;) { var n = q; if (n.flags & 8772) { var o = n.alternate; try { if (n.flags & 8772) switch (n.tag) { case 0: case 11: case 15: Ge || Qo(5, n); break; case 1: var a = n.stateNode; if (n.flags & 4 && !Ge) if (o === null) a.componentDidMount(); else { var c = n.elementType === n.type ? o.memoizedProps : _t(n.type, o.memoizedProps); a.componentDidUpdate(c, o.memoizedState, a.__reactInternalSnapshotBeforeUpdate) } var d = n.updateQueue; d !== null && yd(n, d, a); break; case 3: var g = n.updateQueue; if (g !== null) { if (o = null, n.child !== null) switch (n.child.tag) { case 5: o = n.child.stateNode; break; case 1: o = n.child.stateNode }yd(n, g, o) } break; case 5: var x = n.stateNode; if (o === null && n.flags & 4) { o = x; var E = n.memoizedProps; switch (n.type) { case "button": case "input": case "select": case "textarea": E.autoFocus && o.focus(); break; case "img": E.src && (o.src = E.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (n.memoizedState === null) { var M = n.alternate; if (M !== null) { var I = M.memoizedState; if (I !== null) { var B = I.dehydrated; B !== null && oi(B) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(i(163)) }Ge || n.flags & 512 && Rl(n) } catch (V) { Le(n, n.return, V) } } if (n === e) { q = null; break } if (o = n.sibling, o !== null) { o.return = n.return, q = o; break } q = n.return } } function yh(e) { for (; q !== null;) { var n = q; if (n === e) { q = null; break } var o = n.sibling; if (o !== null) { o.return = n.return, q = o; break } q = n.return } } function gh(e) { for (; q !== null;) { var n = q; try { switch (n.tag) { case 0: case 11: case 15: var o = n.return; try { Qo(4, n) } catch (E) { Le(n, o, E) } break; case 1: var a = n.stateNode; if (typeof a.componentDidMount == "function") { var c = n.return; try { a.componentDidMount() } catch (E) { Le(n, c, E) } } var d = n.return; try { Rl(n) } catch (E) { Le(n, d, E) } break; case 5: var g = n.return; try { Rl(n) } catch (E) { Le(n, g, E) } } } catch (E) { Le(n, n.return, E) } if (n === e) { q = null; break } var x = n.sibling; if (x !== null) { x.return = n.return, q = x; break } q = n.return } } var x0 = Math.ceil, Xo = b.ReactCurrentDispatcher, Dl = b.ReactCurrentOwner, Pt = b.ReactCurrentBatchConfig, fe = 0, Be = null, Ne = null, $e = 0, yt = 0, Lr = vn(0), je = 0, Ai = null, Kn = 0, Yo = 0, _l = 0, Li = null, at = null, Ml = 0, Dr = 1 / 0, en = null, Jo = !1, Ol = null, Cn = null, Zo = !1, Tn = null, es = 0, Di = 0, Nl = null, ts = -1, ns = 0; function nt() { return fe & 6 ? _e() : ts !== -1 ? ts : ts = _e() } function kn(e) { return e.mode & 1 ? fe & 2 && $e !== 0 ? $e & -$e : r0.transition !== null ? (ns === 0 && (ns = cf()), ns) : (e = ge, e !== 0 || (e = window.event, e = e === void 0 ? 16 : wf(e.type)), e) : 1 } function Nt(e, n, o, a) { if (50 < Di) throw Di = 0, Nl = null, Error(i(185)); ei(e, o, a), (!(fe & 2) || e !== Be) && (e === Be && (!(fe & 2) && (Yo |= o), je === 4 && Rn(e, $e)), lt(e, a), o === 1 && fe === 0 && !(n.mode & 1) && (Dr = _e() + 500, Do && xn())) } function lt(e, n) { var o = e.callbackNode; rv(e, n); var a = co(e, e === Be ? $e : 0); if (a === 0) o !== null && af(o), e.callbackNode = null, e.callbackPriority = 0; else if (n = a & -a, e.callbackPriority !== n) { if (o != null && af(o), n === 1) e.tag === 0 ? n0(wh.bind(null, e)) : id(wh.bind(null, e)), Jv(function () { !(fe & 6) && xn() }), o = null; else { switch (ff(a)) { case 1: o = ha; break; case 4: o = lf; break; case 16: o = so; break; case 536870912: o = uf; break; default: o = so }o = Rh(o, vh.bind(null, e)) } e.callbackPriority = n, e.callbackNode = o } } function vh(e, n) { if (ts = -1, ns = 0, fe & 6) throw Error(i(327)); var o = e.callbackNode; if (_r() && e.callbackNode !== o) return null; var a = co(e, e === Be ? $e : 0); if (a === 0) return null; if (a & 30 || a & e.expiredLanes || n) n = rs(e, a); else { n = a; var c = fe; fe |= 2; var d = Sh(); (Be !== e || $e !== n) && (en = null, Dr = _e() + 500, Gn(e, n)); do try { P0(); break } catch (x) { xh(e, x) } while (!0); Ja(), Xo.current = d, fe = c, Ne !== null ? n = 0 : (Be = null, $e = 0, n = je) } if (n !== 0) { if (n === 2 && (c = pa(e), c !== 0 && (a = c, n = Fl(e, c))), n === 1) throw o = Ai, Gn(e, 0), Rn(e, a), lt(e, _e()), o; if (n === 6) Rn(e, a); else { if (c = e.current.alternate, !(a & 30) && !S0(c) && (n = rs(e, a), n === 2 && (d = pa(e), d !== 0 && (a = d, n = Fl(e, d))), n === 1)) throw o = Ai, Gn(e, 0), Rn(e, a), lt(e, _e()), o; switch (e.finishedWork = c, e.finishedLanes = a, n) { case 0: case 1: throw Error(i(345)); case 2: Qn(e, at, en); break; case 3: if (Rn(e, a), (a & 130023424) === a && (n = Ml + 500 - _e(), 10 < n)) { if (co(e, 0) !== 0) break; if (c = e.suspendedLanes, (c & a) !== a) { nt(), e.pingedLanes |= e.suspendedLanes & c; break } e.timeoutHandle = Ua(Qn.bind(null, e, at, en), n); break } Qn(e, at, en); break; case 4: if (Rn(e, a), (a & 4194240) === a) break; for (n = e.eventTimes, c = -1; 0 < a;) { var g = 31 - At(a); d = 1 << g, g = n[g], g > c && (c = g), a &= ~d } if (a = c, a = _e() - a, a = (120 > a ? 120 : 480 > a ? 480 : 1080 > a ? 1080 : 1920 > a ? 1920 : 3e3 > a ? 3e3 : 4320 > a ? 4320 : 1960 * x0(a / 1960)) - a, 10 < a) { e.timeoutHandle = Ua(Qn.bind(null, e, at, en), a); break } Qn(e, at, en); break; case 5: Qn(e, at, en); break; default: throw Error(i(329)) } } } return lt(e, _e()), e.callbackNode === o ? vh.bind(null, e) : null } function Fl(e, n) { var o = Li; return e.current.memoizedState.isDehydrated && (Gn(e, n).flags |= 256), e = rs(e, n), e !== 2 && (n = at, at = o, n !== null && Vl(n)), e } function Vl(e) { at === null ? at = e : at.push.apply(at, e) } function S0(e) { for (var n = e; ;) { if (n.flags & 16384) { var o = n.updateQueue; if (o !== null && (o = o.stores, o !== null)) for (var a = 0; a < o.length; a++) { var c = o[a], d = c.getSnapshot; c = c.value; try { if (!Lt(d(), c)) return !1 } catch { return !1 } } } if (o = n.child, n.subtreeFlags & 16384 && o !== null) o.return = n, n = o; else { if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return !0; n = n.return } n.sibling.return = n.return, n = n.sibling } } return !0 } function Rn(e, n) { for (n &= ~_l, n &= ~Yo, e.suspendedLanes |= n, e.pingedLanes &= ~n, e = e.expirationTimes; 0 < n;) { var o = 31 - At(n), a = 1 << o; e[o] = -1, n &= ~a } } function wh(e) { if (fe & 6) throw Error(i(327)); _r(); var n = co(e, 0); if (!(n & 1)) return lt(e, _e()), null; var o = rs(e, n); if (e.tag !== 0 && o === 2) { var a = pa(e); a !== 0 && (n = a, o = Fl(e, a)) } if (o === 1) throw o = Ai, Gn(e, 0), Rn(e, n), lt(e, _e()), o; if (o === 6) throw Error(i(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = n, Qn(e, at, en), lt(e, _e()), null } function jl(e, n) { var o = fe; fe |= 1; try { return e(n) } finally { fe = o, fe === 0 && (Dr = _e() + 500, Do && xn()) } } function qn(e) { Tn !== null && Tn.tag === 0 && !(fe & 6) && _r(); var n = fe; fe |= 1; var o = Pt.transition, a = ge; try { if (Pt.transition = null, ge = 1, e) return e() } finally { ge = a, Pt.transition = o, fe = n, !(fe & 6) && xn() } } function Il() { yt = Lr.current, Ee(Lr) } function Gn(e, n) { e.finishedWork = null, e.finishedLanes = 0; var o = e.timeoutHandle; if (o !== -1 && (e.timeoutHandle = -1, Yv(o)), Ne !== null) for (o = Ne.return; o !== null;) { var a = o; switch (qa(a), a.tag) { case 1: a = a.type.childContextTypes, a != null && Ao(); break; case 3: kr(), Ee(it), Ee(We), sl(); break; case 5: il(a); break; case 4: kr(); break; case 13: Ee(ke); break; case 19: Ee(ke); break; case 10: Za(a.type._context); break; case 22: case 23: Il() }o = o.return } if (Be = e, Ne = e = An(e.current, null), $e = yt = n, je = 0, Ai = null, _l = Yo = Kn = 0, at = Li = null, $n !== null) { for (n = 0; n < $n.length; n++)if (o = $n[n], a = o.interleaved, a !== null) { o.interleaved = null; var c = a.next, d = o.pending; if (d !== null) { var g = d.next; d.next = c, a.next = g } o.pending = a } $n = null } return e } function xh(e, n) { do { var o = Ne; try { if (Ja(), zo.current = Ho, Uo) { for (var a = Re.memoizedState; a !== null;) { var c = a.queue; c !== null && (c.pending = null), a = a.next } Uo = !1 } if (Wn = 0, Ie = Ve = Re = null, Ei = !1, Pi = 0, Dl.current = null, o === null || o.return === null) { je = 1, Ai = n, Ne = null; break } e: { var d = e, g = o.return, x = o, E = n; if (n = $e, x.flags |= 32768, E !== null && typeof E == "object" && typeof E.then == "function") { var M = E, I = x, B = I.tag; if (!(I.mode & 1) && (B === 0 || B === 11 || B === 15)) { var V = I.alternate; V ? (I.updateQueue = V.updateQueue, I.memoizedState = V.memoizedState, I.lanes = V.lanes) : (I.updateQueue = null, I.memoizedState = null) } var W = Wd(g); if (W !== null) { W.flags &= -257, Kd(W, g, x, d, n), W.mode & 1 && Hd(d, M, n), n = W, E = M; var G = n.updateQueue; if (G === null) { var X = new Set; X.add(E), n.updateQueue = X } else G.add(E); break e } else { if (!(n & 1)) { Hd(d, M, n), Bl(); break e } E = Error(i(426)) } } else if (Ce && x.mode & 1) { var Me = Wd(g); if (Me !== null) { !(Me.flags & 65536) && (Me.flags |= 256), Kd(Me, g, x, d, n), Xa(Rr(E, x)); break e } } d = E = Rr(E, x), je !== 4 && (je = 2), Li === null ? Li = [d] : Li.push(d), d = g; do { switch (d.tag) { case 3: d.flags |= 65536, n &= -n, d.lanes |= n; var D = bd(d, E, n); md(d, D); break e; case 1: x = E; var T = d.type, _ = d.stateNode; if (!(d.flags & 128) && (typeof T.getDerivedStateFromError == "function" || _ !== null && typeof _.componentDidCatch == "function" && (Cn === null || !Cn.has(_)))) { d.flags |= 65536, n &= -n, d.lanes |= n; var U = $d(d, x, n); md(d, U); break e } }d = d.return } while (d !== null) } Ph(o) } catch (J) { n = J, Ne === o && o !== null && (Ne = o = o.return); continue } break } while (!0) } function Sh() { var e = Xo.current; return Xo.current = Ho, e === null ? Ho : e } function Bl() { (je === 0 || je === 3 || je === 2) && (je = 4), Be === null || !(Kn & 268435455) && !(Yo & 268435455) || Rn(Be, $e) } function rs(e, n) { var o = fe; fe |= 2; var a = Sh(); (Be !== e || $e !== n) && (en = null, Gn(e, n)); do try { E0(); break } catch (c) { xh(e, c) } while (!0); if (Ja(), fe = o, Xo.current = a, Ne !== null) throw Error(i(261)); return Be = null, $e = 0, je } function E0() { for (; Ne !== null;)Eh(Ne) } function P0() { for (; Ne !== null && !Gg();)Eh(Ne) } function Eh(e) { var n = kh(e.alternate, e, yt); e.memoizedProps = e.pendingProps, n === null ? Ph(e) : Ne = n, Dl.current = null } function Ph(e) { var n = e; do { var o = n.alternate; if (e = n.return, n.flags & 32768) { if (o = y0(o, n), o !== null) { o.flags &= 32767, Ne = o; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { je = 6, Ne = null; return } } else if (o = m0(o, n, yt), o !== null) { Ne = o; return } if (n = n.sibling, n !== null) { Ne = n; return } Ne = n = e } while (n !== null); je === 0 && (je = 5) } function Qn(e, n, o) { var a = ge, c = Pt.transition; try { Pt.transition = null, ge = 1, C0(e, n, o, a) } finally { Pt.transition = c, ge = a } return null } function C0(e, n, o, a) { do _r(); while (Tn !== null); if (fe & 6) throw Error(i(327)); o = e.finishedWork; var c = e.finishedLanes; if (o === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, o === e.current) throw Error(i(177)); e.callbackNode = null, e.callbackPriority = 0; var d = o.lanes | o.childLanes; if (iv(e, d), e === Be && (Ne = Be = null, $e = 0), !(o.subtreeFlags & 2064) && !(o.flags & 2064) || Zo || (Zo = !0, Rh(so, function () { return _r(), null })), d = (o.flags & 15990) !== 0, o.subtreeFlags & 15990 || d) { d = Pt.transition, Pt.transition = null; var g = ge; ge = 1; var x = fe; fe |= 4, Dl.current = null, v0(e, o), hh(o, e), Hv(Ba), po = !!Ia, Ba = Ia = null, e.current = o, w0(o), Qg(), fe = x, ge = g, Pt.transition = d } else e.current = o; if (Zo && (Zo = !1, Tn = e, es = c), d = e.pendingLanes, d === 0 && (Cn = null), Jg(o.stateNode), lt(e, _e()), n !== null) for (a = e.onRecoverableError, o = 0; o < n.length; o++)c = n[o], a(c.value, { componentStack: c.stack, digest: c.digest }); if (Jo) throw Jo = !1, e = Ol, Ol = null, e; return es & 1 && e.tag !== 0 && _r(), d = e.pendingLanes, d & 1 ? e === Nl ? Di++ : (Di = 0, Nl = e) : Di = 0, xn(), null } function _r() { if (Tn !== null) { var e = ff(es), n = Pt.transition, o = ge; try { if (Pt.transition = null, ge = 16 > e ? 16 : e, Tn === null) var a = !1; else { if (e = Tn, Tn = null, es = 0, fe & 6) throw Error(i(331)); var c = fe; for (fe |= 4, q = e.current; q !== null;) { var d = q, g = d.child; if (q.flags & 16) { var x = d.deletions; if (x !== null) { for (var E = 0; E < x.length; E++) { var M = x[E]; for (q = M; q !== null;) { var I = q; switch (I.tag) { case 0: case 11: case 15: Ri(8, I, d) }var B = I.child; if (B !== null) B.return = I, q = B; else for (; q !== null;) { I = q; var V = I.sibling, W = I.return; if (lh(I), I === M) { q = null; break } if (V !== null) { V.return = W, q = V; break } q = W } } } var G = d.alternate; if (G !== null) { var X = G.child; if (X !== null) { G.child = null; do { var Me = X.sibling; X.sibling = null, X = Me } while (X !== null) } } q = d } } if (d.subtreeFlags & 2064 && g !== null) g.return = d, q = g; else e: for (; q !== null;) { if (d = q, d.flags & 2048) switch (d.tag) { case 0: case 11: case 15: Ri(9, d, d.return) }var D = d.sibling; if (D !== null) { D.return = d.return, q = D; break e } q = d.return } } var T = e.current; for (q = T; q !== null;) { g = q; var _ = g.child; if (g.subtreeFlags & 2064 && _ !== null) _.return = g, q = _; else e: for (g = T; q !== null;) { if (x = q, x.flags & 2048) try { switch (x.tag) { case 0: case 11: case 15: Qo(9, x) } } catch (J) { Le(x, x.return, J) } if (x === g) { q = null; break e } var U = x.sibling; if (U !== null) { U.return = x.return, q = U; break e } q = x.return } } if (fe = c, xn(), It && typeof It.onPostCommitFiberRoot == "function") try { It.onPostCommitFiberRoot(ao, e) } catch { } a = !0 } return a } finally { ge = o, Pt.transition = n } } return !1 } function Ch(e, n, o) { n = Rr(o, n), n = bd(e, n, 1), e = En(e, n, 1), n = nt(), e !== null && (ei(e, 1, n), lt(e, n)) } function Le(e, n, o) { if (e.tag === 3) Ch(e, e, o); else for (; n !== null;) { if (n.tag === 3) { Ch(n, e, o); break } else if (n.tag === 1) { var a = n.stateNode; if (typeof n.type.getDerivedStateFromError == "function" || typeof a.componentDidCatch == "function" && (Cn === null || !Cn.has(a))) { e = Rr(o, e), e = $d(n, e, 1), n = En(n, e, 1), e = nt(), n !== null && (ei(n, 1, e), lt(n, e)); break } } n = n.return } } function T0(e, n, o) { var a = e.pingCache; a !== null && a.delete(n), n = nt(), e.pingedLanes |= e.suspendedLanes & o, Be === e && ($e & o) === o && (je === 4 || je === 3 && ($e & 130023424) === $e && 500 > _e() - Ml ? Gn(e, 0) : _l |= o), lt(e, n) } function Th(e, n) { n === 0 && (e.mode & 1 ? (n = uo, uo <<= 1, !(uo & 130023424) && (uo = 4194304)) : n = 1); var o = nt(); e = Yt(e, n), e !== null && (ei(e, n, o), lt(e, o)) } function k0(e) { var n = e.memoizedState, o = 0; n !== null && (o = n.retryLane), Th(e, o) } function R0(e, n) { var o = 0; switch (e.tag) { case 13: var a = e.stateNode, c = e.memoizedState; c !== null && (o = c.retryLane); break; case 19: a = e.stateNode; break; default: throw Error(i(314)) }a !== null && a.delete(n), Th(e, o) } var kh; kh = function (e, n, o) { if (e !== null) if (e.memoizedProps !== n.pendingProps || it.current) st = !0; else { if (!(e.lanes & o) && !(n.flags & 128)) return st = !1, p0(e, n, o); st = !!(e.flags & 131072) } else st = !1, Ce && n.flags & 1048576 && od(n, Mo, n.index); switch (n.lanes = 0, n.tag) { case 2: var a = n.type; qo(e, n), e = n.pendingProps; var c = wr(n, We.current); Tr(n, o), c = ul(null, n, a, e, c, o); var d = cl(); return n.flags |= 1, typeof c == "object" && c !== null && typeof c.render == "function" && c.$$typeof === void 0 ? (n.tag = 1, n.memoizedState = null, n.updateQueue = null, ot(a) ? (d = !0, Lo(n)) : d = !1, n.memoizedState = c.state !== null && c.state !== void 0 ? c.state : null, nl(n), c.updater = Wo, n.stateNode = c, c._reactInternals = n, yl(n, a, e, o), n = xl(null, n, a, !0, d, o)) : (n.tag = 0, Ce && d && Ka(n), tt(null, n, c, o), n = n.child), n; case 16: a = n.elementType; e: { switch (qo(e, n), e = n.pendingProps, c = a._init, a = c(a._payload), n.type = a, c = n.tag = L0(a), e = _t(a, e), c) { case 0: n = wl(null, n, a, e, o); break e; case 1: n = Jd(null, n, a, e, o); break e; case 11: n = qd(null, n, a, e, o); break e; case 14: n = Gd(null, n, a, _t(a.type, e), o); break e }throw Error(i(306, a, "")) } return n; case 0: return a = n.type, c = n.pendingProps, c = n.elementType === a ? c : _t(a, c), wl(e, n, a, c, o); case 1: return a = n.type, c = n.pendingProps, c = n.elementType === a ? c : _t(a, c), Jd(e, n, a, c, o); case 3: e: { if (Zd(n), e === null) throw Error(i(387)); a = n.pendingProps, d = n.memoizedState, c = d.element, pd(e, n), Io(n, a, null, o); var g = n.memoizedState; if (a = g.element, d.isDehydrated) if (d = { element: a, isDehydrated: !1, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, n.updateQueue.baseState = d, n.memoizedState = d, n.flags & 256) { c = Rr(Error(i(423)), n), n = eh(e, n, a, o, c); break e } else if (a !== c) { c = Rr(Error(i(424)), n), n = eh(e, n, a, o, c); break e } else for (mt = gn(n.stateNode.containerInfo.firstChild), pt = n, Ce = !0, Dt = null, o = dd(n, null, a, o), n.child = o; o;)o.flags = o.flags & -3 | 4096, o = o.sibling; else { if (Er(), a === c) { n = Zt(e, n, o); break e } tt(e, n, a, o) } n = n.child } return n; case 5: return gd(n), e === null && Qa(n), a = n.type, c = n.pendingProps, d = e !== null ? e.memoizedProps : null, g = c.children, za(a, c) ? g = null : d !== null && za(a, d) && (n.flags |= 32), Yd(e, n), tt(e, n, g, o), n.child; case 6: return e === null && Qa(n), null; case 13: return th(e, n, o); case 4: return rl(n, n.stateNode.containerInfo), a = n.pendingProps, e === null ? n.child = Pr(n, null, a, o) : tt(e, n, a, o), n.child; case 11: return a = n.type, c = n.pendingProps, c = n.elementType === a ? c : _t(a, c), qd(e, n, a, c, o); case 7: return tt(e, n, n.pendingProps, o), n.child; case 8: return tt(e, n, n.pendingProps.children, o), n.child; case 12: return tt(e, n, n.pendingProps.children, o), n.child; case 10: e: { if (a = n.type._context, c = n.pendingProps, d = n.memoizedProps, g = c.value, xe(Fo, a._currentValue), a._currentValue = g, d !== null) if (Lt(d.value, g)) { if (d.children === c.children && !it.current) { n = Zt(e, n, o); break e } } else for (d = n.child, d !== null && (d.return = n); d !== null;) { var x = d.dependencies; if (x !== null) { g = d.child; for (var E = x.firstContext; E !== null;) { if (E.context === a) { if (d.tag === 1) { E = Jt(-1, o & -o), E.tag = 2; var M = d.updateQueue; if (M !== null) { M = M.shared; var I = M.pending; I === null ? E.next = E : (E.next = I.next, I.next = E), M.pending = E } } d.lanes |= o, E = d.alternate, E !== null && (E.lanes |= o), el(d.return, o, n), x.lanes |= o; break } E = E.next } } else if (d.tag === 10) g = d.type === n.type ? null : d.child; else if (d.tag === 18) { if (g = d.return, g === null) throw Error(i(341)); g.lanes |= o, x = g.alternate, x !== null && (x.lanes |= o), el(g, o, n), g = d.sibling } else g = d.child; if (g !== null) g.return = d; else for (g = d; g !== null;) { if (g === n) { g = null; break } if (d = g.sibling, d !== null) { d.return = g.return, g = d; break } g = g.return } d = g } tt(e, n, c.children, o), n = n.child } return n; case 9: return c = n.type, a = n.pendingProps.children, Tr(n, o), c = St(c), a = a(c), n.flags |= 1, tt(e, n, a, o), n.child; case 14: return a = n.type, c = _t(a, n.pendingProps), c = _t(a.type, c), Gd(e, n, a, c, o); case 15: return Qd(e, n, n.type, n.pendingProps, o); case 17: return a = n.type, c = n.pendingProps, c = n.elementType === a ? c : _t(a, c), qo(e, n), n.tag = 1, ot(a) ? (e = !0, Lo(n)) : e = !1, Tr(n, o), zd(n, a, c), yl(n, a, c, o), xl(null, n, a, !0, e, o); case 19: return rh(e, n, o); case 22: return Xd(e, n, o) }throw Error(i(156, n.tag)) }; function Rh(e, n) { return sf(e, n) } function A0(e, n, o, a) { this.tag = e, this.key = o, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = n, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = a, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Ct(e, n, o, a) { return new A0(e, n, o, a) } function zl(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function L0(e) { if (typeof e == "function") return zl(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === ft) return 11; if (e === Rt) return 14 } return 2 } function An(e, n) { var o = e.alternate; return o === null ? (o = Ct(e.tag, n, e.key, e.mode), o.elementType = e.elementType, o.type = e.type, o.stateNode = e.stateNode, o.alternate = e, e.alternate = o) : (o.pendingProps = n, o.type = e.type, o.flags = 0, o.subtreeFlags = 0, o.deletions = null), o.flags = e.flags & 14680064, o.childLanes = e.childLanes, o.lanes = e.lanes, o.child = e.child, o.memoizedProps = e.memoizedProps, o.memoizedState = e.memoizedState, o.updateQueue = e.updateQueue, n = e.dependencies, o.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }, o.sibling = e.sibling, o.index = e.index, o.ref = e.ref, o } function is(e, n, o, a, c, d) { var g = 2; if (a = e, typeof e == "function") zl(e) && (g = 1); else if (typeof e == "string") g = 5; else e: switch (e) { case ne: return Xn(o.children, c, d, n); case Q: g = 8, c |= 8; break; case se: return e = Ct(12, o, n, c | 2), e.elementType = se, e.lanes = d, e; case Ze: return e = Ct(13, o, n, c), e.elementType = Ze, e.lanes = d, e; case rt: return e = Ct(19, o, n, c), e.elementType = rt, e.lanes = d, e; case le: return os(o, c, d, n); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case me: g = 10; break e; case Ue: g = 9; break e; case ft: g = 11; break e; case Rt: g = 14; break e; case et: g = 16, a = null; break e }throw Error(i(130, e == null ? e : typeof e, "")) }return n = Ct(g, o, n, c), n.elementType = e, n.type = a, n.lanes = d, n } function Xn(e, n, o, a) { return e = Ct(7, e, a, n), e.lanes = o, e } function os(e, n, o, a) { return e = Ct(22, e, a, n), e.elementType = le, e.lanes = o, e.stateNode = { isHidden: !1 }, e } function Ul(e, n, o) { return e = Ct(6, e, null, n), e.lanes = o, e } function bl(e, n, o) { return n = Ct(4, e.children !== null ? e.children : [], e.key, n), n.lanes = o, n.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, n } function D0(e, n, o, a, c) { this.tag = n, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ma(0), this.expirationTimes = ma(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ma(0), this.identifierPrefix = a, this.onRecoverableError = c, this.mutableSourceEagerHydrationData = null } function $l(e, n, o, a, c, d, g, x, E) { return e = new D0(e, n, o, x, E), n === 1 ? (n = 1, d === !0 && (n |= 8)) : n = 0, d = Ct(3, null, null, n), e.current = d, d.stateNode = e, d.memoizedState = { element: a, isDehydrated: o, cache: null, transitions: null, pendingSuspenseBoundaries: null }, nl(d), e } function _0(e, n, o) { var a = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Y, key: a == null ? null : "" + a, children: e, containerInfo: n, implementation: o } } function Ah(e) { if (!e) return wn; e = e._reactInternals; e: { if (In(e) !== e || e.tag !== 1) throw Error(i(170)); var n = e; do { switch (n.tag) { case 3: n = n.stateNode.context; break e; case 1: if (ot(n.type)) { n = n.stateNode.__reactInternalMemoizedMergedChildContext; break e } }n = n.return } while (n !== null); throw Error(i(171)) } if (e.tag === 1) { var o = e.type; if (ot(o)) return nd(e, o, n) } return n } function Lh(e, n, o, a, c, d, g, x, E) { return e = $l(o, a, !0, e, c, d, g, x, E), e.context = Ah(null), o = e.current, a = nt(), c = kn(o), d = Jt(a, c), d.callback = n ?? null, En(o, d, c), e.current.lanes = c, ei(e, c, a), lt(e, a), e } function ss(e, n, o, a) { var c = n.current, d = nt(), g = kn(c); return o = Ah(o), n.context === null ? n.context = o : n.pendingContext = o, n = Jt(d, g), n.payload = { element: e }, a = a === void 0 ? null : a, a !== null && (n.callback = a), e = En(c, n, g), e !== null && (Nt(e, c, g, d), jo(e, c, g)), g } function as(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function Dh(e, n) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var o = e.retryLane; e.retryLane = o !== 0 && o < n ? o : n } } function Hl(e, n) { Dh(e, n), (e = e.alternate) && Dh(e, n) } function M0() { return null } var _h = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function Wl(e) { this._internalRoot = e } ls.prototype.render = Wl.prototype.render = function (e) { var n = this._internalRoot; if (n === null) throw Error(i(409)); ss(e, n, null, null) }, ls.prototype.unmount = Wl.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var n = e.containerInfo; qn(function () { ss(null, e, null, null) }), n[qt] = null } }; function ls(e) { this._internalRoot = e } ls.prototype.unstable_scheduleHydration = function (e) { if (e) { var n = pf(); e = { blockedOn: null, target: e, priority: n }; for (var o = 0; o < pn.length && n !== 0 && n < pn[o].priority; o++); pn.splice(o, 0, e), o === 0 && gf(e) } }; function Kl(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function us(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function Mh() { } function O0(e, n, o, a, c) { if (c) { if (typeof a == "function") { var d = a; a = function () { var M = as(g); d.call(M) } } var g = Lh(n, a, e, 0, null, !1, !1, "", Mh); return e._reactRootContainer = g, e[qt] = g.current, pi(e.nodeType === 8 ? e.parentNode : e), qn(), g } for (; c = e.lastChild;)e.removeChild(c); if (typeof a == "function") { var x = a; a = function () { var M = as(E); x.call(M) } } var E = $l(e, 0, !1, null, null, !1, !1, "", Mh); return e._reactRootContainer = E, e[qt] = E.current, pi(e.nodeType === 8 ? e.parentNode : e), qn(function () { ss(n, E, o, a) }), E } function cs(e, n, o, a, c) { var d = o._reactRootContainer; if (d) { var g = d; if (typeof c == "function") { var x = c; c = function () { var E = as(g); x.call(E) } } ss(n, g, e, c) } else g = O0(o, n, e, c, a); return as(g) } df = function (e) { switch (e.tag) { case 3: var n = e.stateNode; if (n.current.memoizedState.isDehydrated) { var o = Zr(n.pendingLanes); o !== 0 && (ya(n, o | 1), lt(n, _e()), !(fe & 6) && (Dr = _e() + 500, xn())) } break; case 13: qn(function () { var a = Yt(e, 1); if (a !== null) { var c = nt(); Nt(a, e, 1, c) } }), Hl(e, 1) } }, ga = function (e) { if (e.tag === 13) { var n = Yt(e, 134217728); if (n !== null) { var o = nt(); Nt(n, e, 134217728, o) } Hl(e, 134217728) } }, hf = function (e) { if (e.tag === 13) { var n = kn(e), o = Yt(e, n); if (o !== null) { var a = nt(); Nt(o, e, n, a) } Hl(e, n) } }, pf = function () { return ge }, mf = function (e, n) { var o = ge; try { return ge = e, n() } finally { ge = o } }, ua = function (e, n, o) { switch (n) { case "input": if (ta(e, o), n = o.name, o.type === "radio" && n != null) { for (o = e; o.parentNode;)o = o.parentNode; for (o = o.querySelectorAll("input[name=" + JSON.stringify("" + n) + '][type="radio"]'), n = 0; n < o.length; n++) { var a = o[n]; if (a !== e && a.form === e.form) { var c = Ro(a); if (!c) throw Error(i(90)); Ic(a), ta(a, c) } } } break; case "textarea": $c(e, o); break; case "select": n = o.value, n != null && ar(e, !!o.multiple, n, !1) } }, Jc = jl, Zc = qn; var N0 = { usingClientEntryPoint: !1, Events: [gi, gr, Ro, Xc, Yc, jl] }, _i = { findFiberByHostInstance: Bn, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, F0 = { bundleType: _i.bundleType, version: _i.version, rendererPackageName: _i.rendererPackageName, rendererConfig: _i.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: b.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = rf(e), e === null ? null : e.stateNode }, findFiberByHostInstance: _i.findFiberByHostInstance || M0, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var fs = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!fs.isDisabled && fs.supportsFiber) try { ao = fs.inject(F0), It = fs } catch { } } return ut.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = N0, ut.createPortal = function (e, n) { var o = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Kl(n)) throw Error(i(200)); return _0(e, n, null, o) }, ut.createRoot = function (e, n) { if (!Kl(e)) throw Error(i(299)); var o = !1, a = "", c = _h; return n != null && (n.unstable_strictMode === !0 && (o = !0), n.identifierPrefix !== void 0 && (a = n.identifierPrefix), n.onRecoverableError !== void 0 && (c = n.onRecoverableError)), n = $l(e, 1, !1, null, null, o, !1, a, c), e[qt] = n.current, pi(e.nodeType === 8 ? e.parentNode : e), new Wl(n) }, ut.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var n = e._reactInternals; if (n === void 0) throw typeof e.render == "function" ? Error(i(188)) : (e = Object.keys(e).join(","), Error(i(268, e))); return e = rf(n), e = e === null ? null : e.stateNode, e }, ut.flushSync = function (e) { return qn(e) }, ut.hydrate = function (e, n, o) { if (!us(n)) throw Error(i(200)); return cs(null, e, n, !0, o) }, ut.hydrateRoot = function (e, n, o) { if (!Kl(e)) throw Error(i(405)); var a = o != null && o.hydratedSources || null, c = !1, d = "", g = _h; if (o != null && (o.unstable_strictMode === !0 && (c = !0), o.identifierPrefix !== void 0 && (d = o.identifierPrefix), o.onRecoverableError !== void 0 && (g = o.onRecoverableError)), n = Lh(n, null, e, 1, o ?? null, c, !1, d, g), e[qt] = n.current, pi(e), a) for (e = 0; e < a.length; e++)o = a[e], c = o._getVersion, c = c(o._source), n.mutableSourceEagerHydrationData == null ? n.mutableSourceEagerHydrationData = [o, c] : n.mutableSourceEagerHydrationData.push(o, c); return new ls(n) }, ut.render = function (e, n, o) { if (!us(n)) throw Error(i(200)); return cs(null, e, n, !1, o) }, ut.unmountComponentAtNode = function (e) { if (!us(e)) throw Error(i(40)); return e._reactRootContainer ? (qn(function () { cs(null, null, e, !1, function () { e._reactRootContainer = null, e[qt] = null }) }), !0) : !1 }, ut.unstable_batchedUpdates = jl, ut.unstable_renderSubtreeIntoContainer = function (e, n, o, a) { if (!us(o)) throw Error(i(200)); if (e == null || e._reactInternals === void 0) throw Error(i(38)); return cs(e, n, o, !1, a) }, ut.version = "18.3.1-next-f1338f8080-20240426", ut
} var Uh; function K0() { if (Uh) return Ql.exports; Uh = 1; function t() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t) } catch (r) { console.error(r) } } return t(), Ql.exports = W0(), Ql.exports } var bh; function q0() { if (bh) return ds; bh = 1; var t = K0(); return ds.createRoot = t.createRoot, ds.hydrateRoot = t.hydrateRoot, ds } var G0 = q0(); const Q0 = "modulepreload", X0 = function (t) { return "/" + t }, $h = {}, or = function (r, i, s) { let l = Promise.resolve(); if (i && i.length > 0) { document.getElementsByTagName("link"); const u = document.querySelector("meta[property=csp-nonce]"), h = (u == null ? void 0 : u.nonce) || (u == null ? void 0 : u.getAttribute("nonce")); l = Promise.allSettled(i.map(p => { if (p = X0(p), p in $h) return; $h[p] = !0; const m = p.endsWith(".css"), y = m ? '[rel="stylesheet"]' : ""; if (document.querySelector(`link[href="${p}"]${y}`)) return; const v = document.createElement("link"); if (v.rel = m ? "stylesheet" : Q0, m || (v.as = "script"), v.crossOrigin = "", v.href = p, h && v.setAttribute("nonce", h), document.head.appendChild(v), m) return new Promise((w, C) => { v.addEventListener("load", w), v.addEventListener("error", () => C(new Error(`Unable to preload CSS for ${p}`))) }) })) } function f(u) { const h = new Event("vite:preloadError", { cancelable: !0 }); if (h.payload = u, window.dispatchEvent(h), !h.defaultPrevented) throw u } return l.then(u => { for (const h of u || []) h.status === "rejected" && f(h.reason); return r().catch(f) }) }; var Oi = {}, Hh; function Y0() { if (Hh) return Oi; Hh = 1, Object.defineProperty(Oi, "__esModule", { value: !0 }), Oi.parse = u, Oi.serialize = m; const t = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, r = /^[\u0021-\u003A\u003C-\u007E]*$/, i = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, s = /^[\u0020-\u003A\u003D-\u007E]*$/, l = Object.prototype.toString, f = (() => { const w = function () { }; return w.prototype = Object.create(null), w })(); function u(w, C) { const S = new f, R = w.length; if (R < 2) return S; const P = (C == null ? void 0 : C.decode) || y; let A = 0; do { const N = w.indexOf("=", A); if (N === -1) break; const F = w.indexOf(";", A), b = F === -1 ? R : F; if (N > b) { A = w.lastIndexOf(";", N - 1) + 1; continue } const z = h(w, A, N), Y = p(w, N, z), ne = w.slice(z, Y); if (S[ne] === void 0) { let Q = h(w, N + 1, b), se = p(w, b, Q); const me = P(w.slice(Q, se)); S[ne] = me } A = b + 1 } while (A < R); return S } function h(w, C, S) { do { const R = w.charCodeAt(C); if (R !== 32 && R !== 9) return C } while (++C < S); return S } function p(w, C, S) { for (; C > S;) { const R = w.charCodeAt(--C); if (R !== 32 && R !== 9) return C + 1 } return S } function m(w, C, S) { const R = (S == null ? void 0 : S.encode) || encodeURIComponent; if (!t.test(w)) throw new TypeError(`argument name is invalid: ${w}`); const P = R(C); if (!r.test(P)) throw new TypeError(`argument val is invalid: ${C}`); let A = w + "=" + P; if (!S) return A; if (S.maxAge !== void 0) { if (!Number.isInteger(S.maxAge)) throw new TypeError(`option maxAge is invalid: ${S.maxAge}`); A += "; Max-Age=" + S.maxAge } if (S.domain) { if (!i.test(S.domain)) throw new TypeError(`option domain is invalid: ${S.domain}`); A += "; Domain=" + S.domain } if (S.path) { if (!s.test(S.path)) throw new TypeError(`option path is invalid: ${S.path}`); A += "; Path=" + S.path } if (S.expires) { if (!v(S.expires) || !Number.isFinite(S.expires.valueOf())) throw new TypeError(`option expires is invalid: ${S.expires}`); A += "; Expires=" + S.expires.toUTCString() } if (S.httpOnly && (A += "; HttpOnly"), S.secure && (A += "; Secure"), S.partitioned && (A += "; Partitioned"), S.priority) switch (typeof S.priority == "string" ? S.priority.toLowerCase() : void 0) { case "low": A += "; Priority=Low"; break; case "medium": A += "; Priority=Medium"; break; case "high": A += "; Priority=High"; break; default: throw new TypeError(`option priority is invalid: ${S.priority}`) }if (S.sameSite) switch (typeof S.sameSite == "string" ? S.sameSite.toLowerCase() : S.sameSite) { case !0: case "strict": A += "; SameSite=Strict"; break; case "lax": A += "; SameSite=Lax"; break; case "none": A += "; SameSite=None"; break; default: throw new TypeError(`option sameSite is invalid: ${S.sameSite}`) }return A } function y(w) { if (w.indexOf("%") === -1) return w; try { return decodeURIComponent(w) } catch { return w } } function v(w) { return l.call(w) === "[object Date]" } return Oi } Y0();/**
 * react-router v7.0.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */var Wh = "popstate"; function J0(t = {}) { function r(s, l) { let { pathname: f, search: u, hash: h } = s.location; return xu("", { pathname: f, search: u, hash: h }, l.state && l.state.usr || null, l.state && l.state.key || "default") } function i(s, l) { return typeof l == "string" ? l : bi(l) } return e1(r, i, null, t) } function Te(t, r) { if (t === !1 || t === null || typeof t > "u") throw new Error(r) } function cn(t, r) { if (!t) { typeof console < "u" && console.warn(r); try { throw new Error(r) } catch { } } } function Z0() { return Math.random().toString(36).substring(2, 10) } function Kh(t, r) { return { usr: t.state, key: t.key, idx: r } } function xu(t, r, i = null, s) { return { pathname: typeof t == "string" ? t : t.pathname, search: "", hash: "", ...typeof r == "string" ? Ur(r) : r, state: i, key: r && r.key || s || Z0() } } function bi({ pathname: t = "/", search: r = "", hash: i = "" }) { return r && r !== "?" && (t += r.charAt(0) === "?" ? r : "?" + r), i && i !== "#" && (t += i.charAt(0) === "#" ? i : "#" + i), t } function Ur(t) { let r = {}; if (t) { let i = t.indexOf("#"); i >= 0 && (r.hash = t.substring(i), t = t.substring(0, i)); let s = t.indexOf("?"); s >= 0 && (r.search = t.substring(s), t = t.substring(0, s)), t && (r.pathname = t) } return r } function e1(t, r, i, s = {}) { let { window: l = document.defaultView, v5Compat: f = !1 } = s, u = l.history, h = "POP", p = null, m = y(); m == null && (m = 0, u.replaceState({ ...u.state, idx: m }, "")); function y() { return (u.state || { idx: null }).idx } function v() { h = "POP"; let P = y(), A = P == null ? null : P - m; m = P, p && p({ action: h, location: R.location, delta: A }) } function w(P, A) { h = "PUSH"; let N = xu(R.location, P, A); m = y() + 1; let F = Kh(N, m), b = R.createHref(N); try { u.pushState(F, "", b) } catch (z) { if (z instanceof DOMException && z.name === "DataCloneError") throw z; l.location.assign(b) } f && p && p({ action: h, location: R.location, delta: 1 }) } function C(P, A) { h = "REPLACE"; let N = xu(R.location, P, A); m = y(); let F = Kh(N, m), b = R.createHref(N); u.replaceState(F, "", b), f && p && p({ action: h, location: R.location, delta: 0 }) } function S(P) { let A = l.location.origin !== "null" ? l.location.origin : l.location.href, N = typeof P == "string" ? P : bi(P); return N = N.replace(/ $/, "%20"), Te(A, `No window.location.(origin|href) available to create URL for href: ${N}`), new URL(N, A) } let R = { get action() { return h }, get location() { return t(l, u) }, listen(P) { if (p) throw new Error("A history only accepts one active listener"); return l.addEventListener(Wh, v), p = P, () => { l.removeEventListener(Wh, v), p = null } }, createHref(P) { return r(l, P) }, createURL: S, encodeLocation(P) { let A = S(P); return { pathname: A.pathname, search: A.search, hash: A.hash } }, push: w, replace: C, go(P) { return u.go(P) } }; return R } function Rm(t, r, i = "/") { return t1(t, r, i, !1) } function t1(t, r, i, s) { let l = typeof r == "string" ? Ur(r) : r, f = On(l.pathname || "/", i); if (f == null) return null; let u = Am(t); n1(u); let h = null; for (let p = 0; h == null && p < u.length; ++p) { let m = h1(f); h = f1(u[p], m, s) } return h } function Am(t, r = [], i = [], s = "") { let l = (f, u, h) => { let p = { relativePath: h === void 0 ? f.path || "" : h, caseSensitive: f.caseSensitive === !0, childrenIndex: u, route: f }; p.relativePath.startsWith("/") && (Te(p.relativePath.startsWith(s), `Absolute route path "${p.relativePath}" nested under path "${s}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`), p.relativePath = p.relativePath.slice(s.length)); let m = rn([s, p.relativePath]), y = i.concat(p); f.children && f.children.length > 0 && (Te(f.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${m}".`), Am(f.children, r, y, m)), !(f.path == null && !f.index) && r.push({ path: m, score: u1(m, f.index), routesMeta: y }) }; return t.forEach((f, u) => { var h; if (f.path === "" || !((h = f.path) != null && h.includes("?"))) l(f, u); else for (let p of Lm(f.path)) l(f, u, p) }), r } function Lm(t) { let r = t.split("/"); if (r.length === 0) return []; let [i, ...s] = r, l = i.endsWith("?"), f = i.replace(/\?$/, ""); if (s.length === 0) return l ? [f, ""] : [f]; let u = Lm(s.join("/")), h = []; return h.push(...u.map(p => p === "" ? f : [f, p].join("/"))), l && h.push(...u), h.map(p => t.startsWith("/") && p === "" ? "/" : p) } function n1(t) { t.sort((r, i) => r.score !== i.score ? i.score - r.score : c1(r.routesMeta.map(s => s.childrenIndex), i.routesMeta.map(s => s.childrenIndex))) } var r1 = /^:[\w-]+$/, i1 = 3, o1 = 2, s1 = 1, a1 = 10, l1 = -2, qh = t => t === "*"; function u1(t, r) { let i = t.split("/"), s = i.length; return i.some(qh) && (s += l1), r && (s += o1), i.filter(l => !qh(l)).reduce((l, f) => l + (r1.test(f) ? i1 : f === "" ? s1 : a1), s) } function c1(t, r) { return t.length === r.length && t.slice(0, -1).every((s, l) => s === r[l]) ? t[t.length - 1] - r[r.length - 1] : 0 } function f1(t, r, i = !1) { let { routesMeta: s } = t, l = {}, f = "/", u = []; for (let h = 0; h < s.length; ++h) { let p = s[h], m = h === s.length - 1, y = f === "/" ? r : r.slice(f.length) || "/", v = Rs({ path: p.relativePath, caseSensitive: p.caseSensitive, end: m }, y), w = p.route; if (!v && m && i && !s[s.length - 1].route.index && (v = Rs({ path: p.relativePath, caseSensitive: p.caseSensitive, end: !1 }, y)), !v) return null; Object.assign(l, v.params), u.push({ params: l, pathname: rn([f, v.pathname]), pathnameBase: g1(rn([f, v.pathnameBase])), route: w }), v.pathnameBase !== "/" && (f = rn([f, v.pathnameBase])) } return u } function Rs(t, r) { typeof t == "string" && (t = { path: t, caseSensitive: !1, end: !0 }); let [i, s] = d1(t.path, t.caseSensitive, t.end), l = r.match(i); if (!l) return null; let f = l[0], u = f.replace(/(.)\/+$/, "$1"), h = l.slice(1); return { params: s.reduce((m, { paramName: y, isOptional: v }, w) => { if (y === "*") { let S = h[w] || ""; u = f.slice(0, f.length - S.length).replace(/(.)\/+$/, "$1") } const C = h[w]; return v && !C ? m[y] = void 0 : m[y] = (C || "").replace(/%2F/g, "/"), m }, {}), pathname: f, pathnameBase: u, pattern: t } } function d1(t, r = !1, i = !0) { cn(t === "*" || !t.endsWith("*") || t.endsWith("/*"), `Route path "${t}" will be treated as if it were "${t.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${t.replace(/\*$/, "/*")}".`); let s = [], l = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (u, h, p) => (s.push({ paramName: h, isOptional: p != null }), p ? "/?([^\\/]+)?" : "/([^\\/]+)")); return t.endsWith("*") ? (s.push({ paramName: "*" }), l += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : i ? l += "\\/*$" : t !== "" && t !== "/" && (l += "(?:(?=\\/|$))"), [new RegExp(l, r ? void 0 : "i"), s] } function h1(t) { try { return t.split("/").map(r => decodeURIComponent(r).replace(/\//g, "%2F")).join("/") } catch (r) { return cn(!1, `The URL path "${t}" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (${r}).`), t } } function On(t, r) { if (r === "/") return t; if (!t.toLowerCase().startsWith(r.toLowerCase())) return null; let i = r.endsWith("/") ? r.length - 1 : r.length, s = t.charAt(i); return s && s !== "/" ? null : t.slice(i) || "/" } function p1(t, r = "/") { let { pathname: i, search: s = "", hash: l = "" } = typeof t == "string" ? Ur(t) : t; return { pathname: i ? i.startsWith("/") ? i : m1(i, r) : r, search: v1(s), hash: w1(l) } } function m1(t, r) { let i = r.replace(/\/+$/, "").split("/"); return t.split("/").forEach(l => { l === ".." ? i.length > 1 && i.pop() : l !== "." && i.push(l) }), i.length > 1 ? i.join("/") : "/" } function Jl(t, r, i, s) { return `Cannot include a '${t}' character in a manually specified \`to.${r}\` field [${JSON.stringify(s)}].  Please separate it out to the \`to.${i}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.` } function y1(t) { return t.filter((r, i) => i === 0 || r.route.path && r.route.path.length > 0) } function Ku(t) { let r = y1(t); return r.map((i, s) => s === r.length - 1 ? i.pathname : i.pathnameBase) } function qu(t, r, i, s = !1) { let l; typeof t == "string" ? l = Ur(t) : (l = { ...t }, Te(!l.pathname || !l.pathname.includes("?"), Jl("?", "pathname", "search", l)), Te(!l.pathname || !l.pathname.includes("#"), Jl("#", "pathname", "hash", l)), Te(!l.search || !l.search.includes("#"), Jl("#", "search", "hash", l))); let f = t === "" || l.pathname === "", u = f ? "/" : l.pathname, h; if (u == null) h = i; else { let v = r.length - 1; if (!s && u.startsWith("..")) { let w = u.split("/"); for (; w[0] === "..";)w.shift(), v -= 1; l.pathname = w.join("/") } h = v >= 0 ? r[v] : "/" } let p = p1(l, h), m = u && u !== "/" && u.endsWith("/"), y = (f || u === ".") && i.endsWith("/"); return !p.pathname.endsWith("/") && (m || y) && (p.pathname += "/"), p } var rn = t => t.join("/").replace(/\/\/+/g, "/"), g1 = t => t.replace(/\/+$/, "").replace(/^\/*/, "/"), v1 = t => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t, w1 = t => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t; function x1(t) { return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.internal == "boolean" && "data" in t } var Dm = ["POST", "PUT", "PATCH", "DELETE"]; new Set(Dm); var S1 = ["GET", ...Dm]; new Set(S1); var br = k.createContext(null); br.displayName = "DataRouter"; var Bs = k.createContext(null); Bs.displayName = "DataRouterState"; var _m = k.createContext({ isTransitioning: !1 }); _m.displayName = "ViewTransition"; var E1 = k.createContext(new Map); E1.displayName = "Fetchers"; var P1 = k.createContext(null); P1.displayName = "Await"; var Ft = k.createContext(null); Ft.displayName = "Navigation"; var Gi = k.createContext(null); Gi.displayName = "Location"; var Vt = k.createContext({ outlet: null, matches: [], isDataRoute: !1 }); Vt.displayName = "Route"; var Gu = k.createContext(null); Gu.displayName = "RouteError"; function C1(t, { relative: r } = {}) { Te($r(), "useHref() may be used only in the context of a <Router> component."); let { basename: i, navigator: s } = k.useContext(Ft), { hash: l, pathname: f, search: u } = Qi(t, { relative: r }), h = f; return i !== "/" && (h = f === "/" ? i : rn([i, f])), s.createHref({ pathname: h, search: u, hash: l }) } function $r() { return k.useContext(Gi) != null } function Vn() { return Te($r(), "useLocation() may be used only in the context of a <Router> component."), k.useContext(Gi).location } var Mm = "You should call navigate() in a React.useEffect(), not when your component is first rendered."; function Om(t) { k.useContext(Ft).static || k.useLayoutEffect(t) } function Qu() { let { isDataRoute: t } = k.useContext(Vt); return t ? j1() : T1() } function T1() { Te($r(), "useNavigate() may be used only in the context of a <Router> component."); let t = k.useContext(br), { basename: r, navigator: i } = k.useContext(Ft), { matches: s } = k.useContext(Vt), { pathname: l } = Vn(), f = JSON.stringify(Ku(s)), u = k.useRef(!1); return Om(() => { u.current = !0 }), k.useCallback((p, m = {}) => { if (cn(u.current, Mm), !u.current) return; if (typeof p == "number") { i.go(p); return } let y = qu(p, JSON.parse(f), l, m.relative === "path"); t == null && r !== "/" && (y.pathname = y.pathname === "/" ? r : rn([r, y.pathname])), (m.replace ? i.replace : i.push)(y, m.state, m) }, [r, i, f, l, t]) } k.createContext(null); function bT() { let { matches: t } = k.useContext(Vt), r = t[t.length - 1]; return r ? r.params : {} } function Qi(t, { relative: r } = {}) { let { matches: i } = k.useContext(Vt), { pathname: s } = Vn(), l = JSON.stringify(Ku(i)); return k.useMemo(() => qu(t, JSON.parse(l), s, r === "path"), [t, l, s, r]) } function k1(t, r) { return Nm(t, r) } function Nm(t, r, i, s) { var R; Te($r(), "useRoutes() may be used only in the context of a <Router> component."); let { navigator: l } = k.useContext(Ft), { matches: f } = k.useContext(Vt), u = f[f.length - 1], h = u ? u.params : {}; u && u.pathname; let p = u ? u.pathnameBase : "/"; u && u.route; let m = Vn(), y; if (r) { let P = typeof r == "string" ? Ur(r) : r; Te(p === "/" || ((R = P.pathname) == null ? void 0 : R.startsWith(p)), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${p}" but pathname "${P.pathname}" was given in the \`location\` prop.`), y = P } else y = m; let v = y.pathname || "/", w = v; if (p !== "/") { let P = p.replace(/^\//, "").split("/"); w = "/" + v.replace(/^\//, "").split("/").slice(P.length).join("/") } let C = Rm(t, { pathname: w }), S = _1(C && C.map(P => Object.assign({}, P, { params: Object.assign({}, h, P.params), pathname: rn([p, l.encodeLocation ? l.encodeLocation(P.pathname).pathname : P.pathname]), pathnameBase: P.pathnameBase === "/" ? p : rn([p, l.encodeLocation ? l.encodeLocation(P.pathnameBase).pathname : P.pathnameBase]) })), f, i, s); return r && S ? k.createElement(Gi.Provider, { value: { location: { pathname: "/", search: "", hash: "", state: null, key: "default", ...y }, navigationType: "POP" } }, S) : S } function R1() { let t = V1(), r = x1(t) ? `${t.status} ${t.statusText}` : t instanceof Error ? t.message : JSON.stringify(t), i = t instanceof Error ? t.stack : null, l = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return k.createElement(k.Fragment, null, k.createElement("h2", null, "Unexpected Application Error!"), k.createElement("h3", { style: { fontStyle: "italic" } }, r), i ? k.createElement("pre", { style: l }, i) : null, null) } var A1 = k.createElement(R1, null), L1 = class extends k.Component { constructor(t) { super(t), this.state = { location: t.location, revalidation: t.revalidation, error: t.error } } static getDerivedStateFromError(t) { return { error: t } } static getDerivedStateFromProps(t, r) { return r.location !== t.location || r.revalidation !== "idle" && t.revalidation === "idle" ? { error: t.error, location: t.location, revalidation: t.revalidation } : { error: t.error !== void 0 ? t.error : r.error, location: r.location, revalidation: t.revalidation || r.revalidation } } componentDidCatch(t, r) { console.error("React Router caught the following error during render", t, r) } render() { return this.state.error !== void 0 ? k.createElement(Vt.Provider, { value: this.props.routeContext }, k.createElement(Gu.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } }; function D1({ routeContext: t, match: r, children: i }) { let s = k.useContext(br); return s && s.static && s.staticContext && (r.route.errorElement || r.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = r.route.id), k.createElement(Vt.Provider, { value: t }, i) } function _1(t, r = [], i = null, s = null) { if (t == null) { if (!i) return null; if (i.errors) t = i.matches; else if (r.length === 0 && !i.initialized && i.matches.length > 0) t = i.matches; else return null } let l = t, f = i == null ? void 0 : i.errors; if (f != null) { let p = l.findIndex(m => m.route.id && (f == null ? void 0 : f[m.route.id]) !== void 0); Te(p >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(f).join(",")}`), l = l.slice(0, Math.min(l.length, p + 1)) } let u = !1, h = -1; if (i) for (let p = 0; p < l.length; p++) { let m = l[p]; if ((m.route.HydrateFallback || m.route.hydrateFallbackElement) && (h = p), m.route.id) { let { loaderData: y, errors: v } = i, w = m.route.loader && !y.hasOwnProperty(m.route.id) && (!v || v[m.route.id] === void 0); if (m.route.lazy || w) { u = !0, h >= 0 ? l = l.slice(0, h + 1) : l = [l[0]]; break } } } return l.reduceRight((p, m, y) => { let v, w = !1, C = null, S = null; i && (v = f && m.route.id ? f[m.route.id] : void 0, C = m.route.errorElement || A1, u && (h < 0 && y === 0 ? (I1("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), w = !0, S = null) : h === y && (w = !0, S = m.route.hydrateFallbackElement || null))); let R = r.concat(l.slice(0, y + 1)), P = () => { let A; return v ? A = C : w ? A = S : m.route.Component ? A = k.createElement(m.route.Component, null) : m.route.element ? A = m.route.element : A = p, k.createElement(D1, { match: m, routeContext: { outlet: p, matches: R, isDataRoute: i != null }, children: A }) }; return i && (m.route.ErrorBoundary || m.route.errorElement || y === 0) ? k.createElement(L1, { location: i.location, revalidation: i.revalidation, component: C, error: v, children: P(), routeContext: { outlet: null, matches: R, isDataRoute: !0 } }) : P() }, null) } function Xu(t) { return `${t} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function M1(t) { let r = k.useContext(br); return Te(r, Xu(t)), r } function O1(t) { let r = k.useContext(Bs); return Te(r, Xu(t)), r } function N1(t) { let r = k.useContext(Vt); return Te(r, Xu(t)), r } function Yu(t) { let r = N1(t), i = r.matches[r.matches.length - 1]; return Te(i.route.id, `${t} can only be used on routes that contain a unique "id"`), i.route.id } function F1() { return Yu("useRouteId") } function V1() { var s; let t = k.useContext(Gu), r = O1("useRouteError"), i = Yu("useRouteError"); return t !== void 0 ? t : (s = r.errors) == null ? void 0 : s[i] } function j1() { let { router: t } = M1("useNavigate"), r = Yu("useNavigate"), i = k.useRef(!1); return Om(() => { i.current = !0 }), k.useCallback(async (l, f = {}) => { cn(i.current, Mm), i.current && (typeof l == "number" ? t.navigate(l) : await t.navigate(l, { fromRouteId: r, ...f })) }, [t, r]) } var Gh = {}; function I1(t, r, i) { Gh[t] || (Gh[t] = !0, cn(!1, i)) } k.memo(B1); function B1({ routes: t, future: r, state: i }) { return Nm(t, void 0, i, r) } function z1({ to: t, replace: r, state: i, relative: s }) { Te($r(), "<Navigate> may be used only in the context of a <Router> component."); let { static: l } = k.useContext(Ft); cn(!l, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."); let { matches: f } = k.useContext(Vt), { pathname: u } = Vn(), h = Qu(), p = qu(t, Ku(f), u, s === "path"), m = JSON.stringify(p); return k.useEffect(() => { h(JSON.parse(m), { replace: r, state: i, relative: s }) }, [h, m, s, r, i]), null } function _n(t) { Te(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") } function U1({ basename: t = "/", children: r = null, location: i, navigationType: s = "POP", navigator: l, static: f = !1 }) { Te(!$r(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."); let u = t.replace(/^\/*/, "/"), h = k.useMemo(() => ({ basename: u, navigator: l, static: f, future: {} }), [u, l, f]); typeof i == "string" && (i = Ur(i)); let { pathname: p = "/", search: m = "", hash: y = "", state: v = null, key: w = "default" } = i, C = k.useMemo(() => { let S = On(p, u); return S == null ? null : { location: { pathname: S, search: m, hash: y, state: v, key: w }, navigationType: s } }, [u, p, m, y, v, w, s]); return cn(C != null, `<Router basename="${u}"> is not able to match the URL "${p}${m}${y}" because it does not start with the basename, so the <Router> won't render anything.`), C == null ? null : k.createElement(Ft.Provider, { value: h }, k.createElement(Gi.Provider, { children: r, value: C })) } function b1({ children: t, location: r }) { return k1(Su(t), r) } function Su(t, r = []) { let i = []; return k.Children.forEach(t, (s, l) => { if (!k.isValidElement(s)) return; let f = [...r, l]; if (s.type === k.Fragment) { i.push.apply(i, Su(s.props.children, f)); return } Te(s.type === _n, `[${typeof s.type == "string" ? s.type : s.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`), Te(!s.props.index || !s.props.children, "An index route cannot have child routes."); let u = { id: s.props.id || f.join("-"), caseSensitive: s.props.caseSensitive, element: s.props.element, Component: s.props.Component, index: s.props.index, path: s.props.path, loader: s.props.loader, action: s.props.action, hydrateFallbackElement: s.props.hydrateFallbackElement, HydrateFallback: s.props.HydrateFallback, errorElement: s.props.errorElement, ErrorBoundary: s.props.ErrorBoundary, hasErrorBoundary: s.props.hasErrorBoundary === !0 || s.props.ErrorBoundary != null || s.props.errorElement != null, shouldRevalidate: s.props.shouldRevalidate, handle: s.props.handle, lazy: s.props.lazy }; s.props.children && (u.children = Su(s.props.children, f)), i.push(u) }), i } var ws = "get", xs = "application/x-www-form-urlencoded"; function zs(t) { return t != null && typeof t.tagName == "string" } function $1(t) { return zs(t) && t.tagName.toLowerCase() === "button" } function H1(t) { return zs(t) && t.tagName.toLowerCase() === "form" } function W1(t) { return zs(t) && t.tagName.toLowerCase() === "input" } function K1(t) { return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) } function q1(t, r) { return t.button === 0 && (!r || r === "_self") && !K1(t) } var hs = null; function G1() { if (hs === null) try { new FormData(document.createElement("form"), 0), hs = !1 } catch { hs = !0 } return hs } var Q1 = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]); function Zl(t) { return t != null && !Q1.has(t) ? (cn(!1, `"${t}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${xs}"`), null) : t } function X1(t, r) { let i, s, l, f, u; if (H1(t)) { let h = t.getAttribute("action"); s = h ? On(h, r) : null, i = t.getAttribute("method") || ws, l = Zl(t.getAttribute("enctype")) || xs, f = new FormData(t) } else if ($1(t) || W1(t) && (t.type === "submit" || t.type === "image")) { let h = t.form; if (h == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>'); let p = t.getAttribute("formaction") || h.getAttribute("action"); if (s = p ? On(p, r) : null, i = t.getAttribute("formmethod") || h.getAttribute("method") || ws, l = Zl(t.getAttribute("formenctype")) || Zl(h.getAttribute("enctype")) || xs, f = new FormData(h, t), !G1()) { let { name: m, type: y, value: v } = t; if (y === "image") { let w = m ? `${m}.` : ""; f.append(`${w}x`, "0"), f.append(`${w}y`, "0") } else m && f.append(m, v) } } else { if (zs(t)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">'); i = ws, s = null, l = xs, u = t } return f && l === "text/plain" && (u = f, f = void 0), { action: s, method: i.toLowerCase(), encType: l, formData: f, body: u } } function Ju(t, r) { if (t === !1 || t === null || typeof t > "u") throw new Error(r) } async function Y1(t, r) { if (t.id in r) return r[t.id]; try { let i = await import(t.module); return r[t.id] = i, i } catch (i) { return console.error(`Error loading route module \`${t.module}\`, reloading page...`), console.error(i), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => { }) } } function J1(t) { return t == null ? !1 : t.href == null ? t.rel === "preload" && typeof t.imageSrcSet == "string" && typeof t.imageSizes == "string" : typeof t.rel == "string" && typeof t.href == "string" } async function Z1(t, r, i) { let s = await Promise.all(t.map(async l => { let f = r.routes[l.route.id]; if (f) { let u = await Y1(f, i); return u.links ? u.links() : [] } return [] })); return rw(s.flat(1).filter(J1).filter(l => l.rel === "stylesheet" || l.rel === "preload").map(l => l.rel === "stylesheet" ? { ...l, rel: "prefetch", as: "style" } : { ...l, rel: "prefetch" })) } function Qh(t, r, i, s, l, f) { let u = (p, m) => i[m] ? p.route.id !== i[m].route.id : !0, h = (p, m) => { var y; return i[m].pathname !== p.pathname || ((y = i[m].route.path) == null ? void 0 : y.endsWith("*")) && i[m].params["*"] !== p.params["*"] }; return f === "assets" ? r.filter((p, m) => u(p, m) || h(p, m)) : f === "data" ? r.filter((p, m) => { var v; let y = s.routes[p.route.id]; if (!y || !y.hasLoader) return !1; if (u(p, m) || h(p, m)) return !0; if (p.route.shouldRevalidate) { let w = p.route.shouldRevalidate({ currentUrl: new URL(l.pathname + l.search + l.hash, window.origin), currentParams: ((v = i[0]) == null ? void 0 : v.params) || {}, nextUrl: new URL(t, window.origin), nextParams: p.params, defaultShouldRevalidate: !0 }); if (typeof w == "boolean") return w } return !0 }) : [] } function ew(t, r) { return tw(t.map(i => { let s = r.routes[i.route.id]; if (!s) return []; let l = [s.module]; return s.imports && (l = l.concat(s.imports)), l }).flat(1)) } function tw(t) { return [...new Set(t)] } function nw(t) { let r = {}, i = Object.keys(t).sort(); for (let s of i) r[s] = t[s]; return r } function rw(t, r) { let i = new Set; return new Set(r), t.reduce((s, l) => { let f = JSON.stringify(nw(l)); return i.has(f) || (i.add(f), s.push({ key: f, link: l })), s }, []) } function iw(t) { let r = typeof t == "string" ? new URL(t, typeof window > "u" ? "server://singlefetch/" : window.location.origin) : t; return r.pathname === "/" ? r.pathname = "_root.data" : r.pathname = `${r.pathname.replace(/\/$/, "")}.data`, r } function ow() { let t = k.useContext(br); return Ju(t, "You must render this element inside a <DataRouterContext.Provider> element"), t } function sw() { let t = k.useContext(Bs); return Ju(t, "You must render this element inside a <DataRouterStateContext.Provider> element"), t } var Zu = k.createContext(void 0); Zu.displayName = "FrameworkContext"; function Fm() { let t = k.useContext(Zu); return Ju(t, "You must render this element inside a <HydratedRouter> element"), t } function aw(t, r) { let i = k.useContext(Zu), [s, l] = k.useState(!1), [f, u] = k.useState(!1), { onFocus: h, onBlur: p, onMouseEnter: m, onMouseLeave: y, onTouchStart: v } = r, w = k.useRef(null); k.useEffect(() => { if (t === "render" && u(!0), t === "viewport") { let R = A => { A.forEach(N => { u(N.isIntersecting) }) }, P = new IntersectionObserver(R, { threshold: .5 }); return w.current && P.observe(w.current), () => { P.disconnect() } } }, [t]), k.useEffect(() => { if (s) { let R = setTimeout(() => { u(!0) }, 100); return () => { clearTimeout(R) } } }, [s]); let C = () => { l(!0) }, S = () => { l(!1), u(!1) }; return i ? t !== "intent" ? [f, w, {}] : [f, w, { onFocus: Ni(h, C), onBlur: Ni(p, S), onMouseEnter: Ni(m, C), onMouseLeave: Ni(y, S), onTouchStart: Ni(v, C) }] : [!1, w, {}] } function Ni(t, r) { return i => { t && t(i), i.defaultPrevented || r(i) } } function lw({ page: t, ...r }) { let { router: i } = ow(), s = k.useMemo(() => Rm(i.routes, t, i.basename), [i.routes, t, i.basename]); return s ? k.createElement(cw, { page: t, matches: s, ...r }) : (console.warn(`Tried to prefetch ${t} but no routes matched.`), null) } function uw(t) { let { manifest: r, routeModules: i } = Fm(), [s, l] = k.useState([]); return k.useEffect(() => { let f = !1; return Z1(t, r, i).then(u => { f || l(u) }), () => { f = !0 } }, [t, r, i]), s } function cw({ page: t, matches: r, ...i }) { let s = Vn(), { manifest: l, routeModules: f } = Fm(), { loaderData: u, matches: h } = sw(), p = k.useMemo(() => Qh(t, r, h, l, s, "data"), [t, r, h, l, s]), m = k.useMemo(() => Qh(t, r, h, l, s, "assets"), [t, r, h, l, s]), y = k.useMemo(() => { if (t === s.pathname + s.search + s.hash) return []; let C = new Set, S = !1; if (r.forEach(P => { var N; let A = l.routes[P.route.id]; !A || !A.hasLoader || (!p.some(F => F.route.id === P.route.id) && P.route.id in u && ((N = f[P.route.id]) != null && N.shouldRevalidate) || A.hasClientLoader ? S = !0 : C.add(P.route.id)) }), C.size === 0) return []; let R = iw(t); return S && C.size > 0 && R.searchParams.set("_routes", r.filter(P => C.has(P.route.id)).map(P => P.route.id).join(",")), [R.pathname + R.search] }, [u, s, l, p, r, t, f]), v = k.useMemo(() => ew(m, l), [m, l]), w = uw(m); return k.createElement(k.Fragment, null, y.map(C => k.createElement("link", { key: C, rel: "prefetch", as: "fetch", href: C, ...i })), v.map(C => k.createElement("link", { key: C, rel: "modulepreload", href: C, ...i })), w.map(({ key: C, link: S }) => k.createElement("link", { key: C, ...S }))) } function fw(...t) { return r => { t.forEach(i => { typeof i == "function" ? i(r) : i != null && (i.current = r) }) } } var Vm = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"; try { Vm && (window.__reactRouterVersion = "7.0.1") } catch { } function dw({ basename: t, children: r, window: i }) { let s = k.useRef(); s.current == null && (s.current = J0({ window: i, v5Compat: !0 })); let l = s.current, [f, u] = k.useState({ action: l.action, location: l.location }), h = k.useCallback(p => { k.startTransition(() => u(p)) }, [u]); return k.useLayoutEffect(() => l.listen(h), [l, h]), k.createElement(U1, { basename: t, children: r, location: f.location, navigationType: f.action, navigator: l }) } var jm = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, As = k.forwardRef(function ({ onClick: r, discover: i = "render", prefetch: s = "none", relative: l, reloadDocument: f, replace: u, state: h, target: p, to: m, preventScrollReset: y, viewTransition: v, ...w }, C) { let { basename: S } = k.useContext(Ft), R = typeof m == "string" && jm.test(m), P, A = !1; if (typeof m == "string" && R && (P = m, Vm)) try { let se = new URL(window.location.href), me = m.startsWith("//") ? new URL(se.protocol + m) : new URL(m), Ue = On(me.pathname, S); me.origin === se.origin && Ue != null ? m = Ue + me.search + me.hash : A = !0 } catch { cn(!1, `<Link to="${m}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`) } let N = C1(m, { relative: l }), [F, b, z] = aw(s, w), Y = yw(m, { replace: u, state: h, target: p, preventScrollReset: y, relative: l, viewTransition: v }); function ne(se) { r && r(se), se.defaultPrevented || Y(se) } let Q = k.createElement("a", { ...w, ...z, href: P || N, onClick: A || f ? r : ne, ref: fw(C, b), target: p, "data-discover": !R && i === "render" ? "true" : void 0 }); return F && !R ? k.createElement(k.Fragment, null, Q, k.createElement(lw, { page: N })) : Q }); As.displayName = "Link"; var hw = k.forwardRef(function ({ "aria-current": r = "page", caseSensitive: i = !1, className: s = "", end: l = !1, style: f, to: u, viewTransition: h, children: p, ...m }, y) { let v = Qi(u, { relative: m.relative }), w = Vn(), C = k.useContext(Bs), { navigator: S, basename: R } = k.useContext(Ft), P = C != null && Sw(v) && h === !0, A = S.encodeLocation ? S.encodeLocation(v).pathname : v.pathname, N = w.pathname, F = C && C.navigation && C.navigation.location ? C.navigation.location.pathname : null; i || (N = N.toLowerCase(), F = F ? F.toLowerCase() : null, A = A.toLowerCase()), F && R && (F = On(F, R) || F); const b = A !== "/" && A.endsWith("/") ? A.length - 1 : A.length; let z = N === A || !l && N.startsWith(A) && N.charAt(b) === "/", Y = F != null && (F === A || !l && F.startsWith(A) && F.charAt(A.length) === "/"), ne = { isActive: z, isPending: Y, isTransitioning: P }, Q = z ? r : void 0, se; typeof s == "function" ? se = s(ne) : se = [s, z ? "active" : null, Y ? "pending" : null, P ? "transitioning" : null].filter(Boolean).join(" "); let me = typeof f == "function" ? f(ne) : f; return k.createElement(As, { ...m, "aria-current": Q, className: se, ref: y, style: me, to: u, viewTransition: h }, typeof p == "function" ? p(ne) : p) }); hw.displayName = "NavLink"; var pw = k.forwardRef(({ discover: t = "render", fetcherKey: r, navigate: i, reloadDocument: s, replace: l, state: f, method: u = ws, action: h, onSubmit: p, relative: m, preventScrollReset: y, viewTransition: v, ...w }, C) => { let S = ww(), R = xw(h, { relative: m }), P = u.toLowerCase() === "get" ? "get" : "post", A = typeof h == "string" && jm.test(h), N = F => { if (p && p(F), F.defaultPrevented) return; F.preventDefault(); let b = F.nativeEvent.submitter, z = (b == null ? void 0 : b.getAttribute("formmethod")) || u; S(b || F.currentTarget, { fetcherKey: r, method: z, navigate: i, replace: l, state: f, relative: m, preventScrollReset: y, viewTransition: v }) }; return k.createElement("form", { ref: C, method: P, action: R, onSubmit: s ? p : N, ...w, "data-discover": !A && t === "render" ? "true" : void 0 }) }); pw.displayName = "Form"; function mw(t) { return `${t} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function Im(t) { let r = k.useContext(br); return Te(r, mw(t)), r } function yw(t, { target: r, replace: i, state: s, preventScrollReset: l, relative: f, viewTransition: u } = {}) { let h = Qu(), p = Vn(), m = Qi(t, { relative: f }); return k.useCallback(y => { if (q1(y, r)) { y.preventDefault(); let v = i !== void 0 ? i : bi(p) === bi(m); h(t, { replace: v, state: s, preventScrollReset: l, relative: f, viewTransition: u }) } }, [p, h, m, i, s, r, t, l, f, u]) } var gw = 0, vw = () => `__${String(++gw)}__`; function ww() { let { router: t } = Im("useSubmit"), { basename: r } = k.useContext(Ft), i = F1(); return k.useCallback(async (s, l = {}) => { let { action: f, method: u, encType: h, formData: p, body: m } = X1(s, r); if (l.navigate === !1) { let y = l.fetcherKey || vw(); await t.fetch(y, i, l.action || f, { preventScrollReset: l.preventScrollReset, formData: p, body: m, formMethod: l.method || u, formEncType: l.encType || h, flushSync: l.flushSync }) } else await t.navigate(l.action || f, { preventScrollReset: l.preventScrollReset, formData: p, body: m, formMethod: l.method || u, formEncType: l.encType || h, replace: l.replace, state: l.state, fromRouteId: i, flushSync: l.flushSync, viewTransition: l.viewTransition }) }, [t, r, i]) } function xw(t, { relative: r } = {}) { let { basename: i } = k.useContext(Ft), s = k.useContext(Vt); Te(s, "useFormAction must be used inside a RouteContext"); let [l] = s.matches.slice(-1), f = { ...Qi(t || ".", { relative: r }) }, u = Vn(); if (t == null) { f.search = u.search; let h = new URLSearchParams(f.search), p = h.getAll("index"); if (p.some(y => y === "")) { h.delete("index"), p.filter(v => v).forEach(v => h.append("index", v)); let y = h.toString(); f.search = y ? `?${y}` : "" } } return (!t || t === ".") && l.route.index && (f.search = f.search ? f.search.replace(/^\?/, "?index&") : "?index"), i !== "/" && (f.pathname = f.pathname === "/" ? i : rn([i, f.pathname])), bi(f) } function Sw(t, r = {}) { let i = k.useContext(_m); Te(i != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"); let { basename: s } = Im("useViewTransitionState"), l = Qi(t, { relative: r.relative }); if (!i.isTransitioning) return !1; let f = On(i.currentLocation.pathname, s) || i.currentLocation.pathname, u = On(i.nextLocation.pathname, s) || i.nextLocation.pathname; return Rs(l.pathname, u) != null || Rs(l.pathname, f) != null } new TextEncoder; var eu = { exports: {} }, tu, Xh; function Ew() { if (Xh) return tu; Xh = 1; var t = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"; return tu = t, tu } var nu, Yh; function Pw() { if (Yh) return nu; Yh = 1; var t = Ew(); function r() { } function i() { } return i.resetWarningCache = r, nu = function () { function s(u, h, p, m, y, v) { if (v !== t) { var w = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw w.name = "Invariant Violation", w } } s.isRequired = s; function l() { return s } var f = { array: s, bigint: s, bool: s, func: s, number: s, object: s, string: s, symbol: s, any: s, arrayOf: l, element: s, elementType: s, instanceOf: l, node: s, objectOf: l, oneOf: l, oneOfType: l, shape: l, exact: l, checkPropTypes: i, resetWarningCache: r }; return f.PropTypes = f, f }, nu } var Jh; function Cw() { return Jh || (Jh = 1, eu.exports = Pw()()), eu.exports } var Tw = Cw(); const Ls = km(Tw); class tn extends b0.Component { constructor(i) { super(i); Oh(this, "resetErrorBoundary", () => { this.setState({ hasError: !1, error: null }) }); this.state = { hasError: !1, error: null } } static getDerivedStateFromError(i) { return { hasError: !0, error: i } } componentDidCatch(i, s) { console.error("Uncaught error:", i, s) } render() { return this.state.hasError ? this.props.FallbackComponent ? this.props.FallbackComponent({ error: this.state.error, resetErrorBoundary: this.resetErrorBoundary }) : null : this.props.children } } tn.propTypes = { children: Ls.node.isRequired, FallbackComponent: Ls.elementType };/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const kw = t => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Bm = (...t) => t.filter((r, i, s) => !!r && r.trim() !== "" && s.indexOf(r) === i).join(" ").trim();/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var Rw = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Aw = k.forwardRef(({ color: t = "currentColor", size: r = 24, strokeWidth: i = 2, absoluteStrokeWidth: s, className: l = "", children: f, iconNode: u, ...h }, p) => k.createElement("svg", { ref: p, ...Rw, width: r, height: r, stroke: t, strokeWidth: s ? Number(i) * 24 / Number(r) : i, className: Bm("lucide", l), ...h }, [...u.map(([m, y]) => k.createElement(m, y)), ...Array.isArray(f) ? f : [f]]));/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Kt = (t, r) => { const i = k.forwardRef(({ className: s, ...l }, f) => k.createElement(Aw, { ref: f, iconNode: r, className: Bm(`lucide-${kw(t)}`, s), ...l })); return i.displayName = `${t}`, i };/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Lw = Kt("CirclePlus", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M8 12h8", key: "1wcyev" }], ["path", { d: "M12 8v8", key: "napkw2" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Dw = Kt("House", [["path", { d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8", key: "5wwlr5" }], ["path", { d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z", key: "1d0kgt" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const zm = Kt("LoaderCircle", [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _w = Kt("LogIn", [["path", { d: "M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4", key: "u53s6r" }], ["polyline", { points: "10 17 15 12 10 7", key: "1ail0h" }], ["line", { x1: "15", x2: "3", y1: "12", y2: "12", key: "v6grx8" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Mw = Kt("LogOut", [["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }], ["polyline", { points: "16 17 21 12 16 7", key: "1gabdz" }], ["line", { x1: "21", x2: "9", y1: "12", y2: "12", key: "1uyos4" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ow = Kt("Menu", [["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }], ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }], ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Nw = Kt("ShieldCheck", [["path", { d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z", key: "oel41y" }], ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Fw = Kt("UserPlus", [["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }], ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }], ["line", { x1: "19", x2: "19", y1: "8", y2: "14", key: "1bvyxn" }], ["line", { x1: "22", x2: "16", y1: "11", y2: "11", key: "1shjgl" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Vw = Kt("User", [["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }], ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const jw = Kt("X", [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]]), Um = () => H.jsx("div", { className: "min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 flex items-center justify-center", children: H.jsxs("div", { className: "text-center", children: [H.jsx(zm, { className: "mx-auto h-12 w-12 text-blue-500 animate-spin" }), H.jsx("p", { className: "mt-4 text-gray-600 text-lg", children: "Loading..." })] }) }); function Iw(t) { if (typeof Proxy > "u") return t; const r = new Map, i = (...s) => t(...s); return new Proxy(i, { get: (s, l) => l === "create" ? t : (r.has(l) || r.set(l, t(l)), r.get(l)) }) } function Us(t) { return t !== null && typeof t == "object" && typeof t.start == "function" } const Eu = t => Array.isArray(t); function bm(t, r) { if (!Array.isArray(r)) return !1; const i = r.length; if (i !== t.length) return !1; for (let s = 0; s < i; s++)if (r[s] !== t[s]) return !1; return !0 } function $i(t) { return typeof t == "string" || Array.isArray(t) } function Zh(t) { const r = [{}, {}]; return t == null || t.values.forEach((i, s) => { r[0][s] = i.get(), r[1][s] = i.getVelocity() }), r } function ec(t, r, i, s) { if (typeof r == "function") { const [l, f] = Zh(s); r = r(i !== void 0 ? i : t.custom, l, f) } if (typeof r == "string" && (r = t.variants && t.variants[r]), typeof r == "function") { const [l, f] = Zh(s); r = r(i !== void 0 ? i : t.custom, l, f) } return r } function bs(t, r, i) { const s = t.getProps(); return ec(s, r, i !== void 0 ? i : s.custom, t) } const tc = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], nc = ["initial", ...tc], Xi = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], sr = new Set(Xi), on = t => t * 1e3, sn = t => t / 1e3, Bw = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, zw = t => ({ type: "spring", stiffness: 550, damping: t === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), Uw = { type: "keyframes", duration: .8 }, bw = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, $w = (t, { keyframes: r }) => r.length > 2 ? Uw : sr.has(t) ? t.startsWith("scale") ? zw(r[1]) : Bw : bw; function rc(t, r) { return t ? t[r] || t.default || t : void 0 } const Hw = { skipAnimations: !1, useManualTiming: !1 }, Ww = t => t !== null; function $s(t, { repeat: r, repeatType: i = "loop" }, s) { const l = t.filter(Ww), f = r && i !== "loop" && r % 2 === 1 ? 0 : l.length - 1; return !f || s === void 0 ? l[f] : s } const Je = t => t; function Kw(t) { let r = new Set, i = new Set, s = !1, l = !1; const f = new WeakSet; let u = { delta: 0, timestamp: 0, isProcessing: !1 }; function h(m) { f.has(m) && (p.schedule(m), t()), m(u) } const p = { schedule: (m, y = !1, v = !1) => { const C = v && s ? r : i; return y && f.add(m), C.has(m) || C.add(m), m }, cancel: m => { i.delete(m), f.delete(m) }, process: m => { if (u = m, s) { l = !0; return } s = !0, [r, i] = [i, r], i.clear(), r.forEach(h), s = !1, l && (l = !1, p.process(m)) } }; return p } const ps = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], qw = 40; function $m(t, r) { let i = !1, s = !0; const l = { delta: 0, timestamp: 0, isProcessing: !1 }, f = () => i = !0, u = ps.reduce((A, N) => (A[N] = Kw(f), A), {}), { read: h, resolveKeyframes: p, update: m, preRender: y, render: v, postRender: w } = u, C = () => { const A = performance.now(); i = !1, l.delta = s ? 1e3 / 60 : Math.max(Math.min(A - l.timestamp, qw), 1), l.timestamp = A, l.isProcessing = !0, h.process(l), p.process(l), m.process(l), y.process(l), v.process(l), w.process(l), l.isProcessing = !1, i && r && (s = !1, t(C)) }, S = () => { i = !0, s = !0, l.isProcessing || t(C) }; return { schedule: ps.reduce((A, N) => { const F = u[N]; return A[N] = (b, z = !1, Y = !1) => (i || S(), F.schedule(b, z, Y)), A }, {}), cancel: A => { for (let N = 0; N < ps.length; N++)u[ps[N]].cancel(A) }, state: l, steps: u } } const { schedule: ve, cancel: Nn, state: He, steps: ru } = $m(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Je, !0), Hm = (t, r, i) => (((1 - 3 * i + 3 * r) * t + (3 * i - 6 * r)) * t + 3 * r) * t, Gw = 1e-7, Qw = 12; function Xw(t, r, i, s, l) { let f, u, h = 0; do u = r + (i - r) / 2, f = Hm(u, s, l) - t, f > 0 ? i = u : r = u; while (Math.abs(f) > Gw && ++h < Qw); return u } function Yi(t, r, i, s) { if (t === r && i === s) return Je; const l = f => Xw(f, 0, 1, t, i); return f => f === 0 || f === 1 ? f : Hm(l(f), r, s) } const Wm = t => r => r <= .5 ? t(2 * r) / 2 : (2 - t(2 * (1 - r))) / 2, Km = t => r => 1 - t(1 - r), qm = Yi(.33, 1.53, .69, .99), ic = Km(qm), Gm = Wm(ic), Qm = t => (t *= 2) < 1 ? .5 * ic(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))), oc = t => 1 - Math.sin(Math.acos(t)), Xm = Km(oc), Ym = Wm(oc), Jm = t => /^0[^.\s]+$/u.test(t); function Yw(t) { return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || Jm(t) : !0 } let Pu = Je; const Zm = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), ey = t => r => typeof r == "string" && r.startsWith(t), ty = ey("--"), Jw = ey("var(--"), sc = t => Jw(t) ? Zw.test(t.split("/*")[0].trim()) : !1, Zw = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, ex = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function tx(t) { const r = ex.exec(t); if (!r) return [,]; const [, i, s, l] = r; return [`--${i ?? s}`, l] } function ny(t, r, i = 1) { const [s, l] = tx(t); if (!s) return; const f = window.getComputedStyle(r).getPropertyValue(s); if (f) { const u = f.trim(); return Zm(u) ? parseFloat(u) : u } return sc(l) ? ny(l, r, i + 1) : l } const un = (t, r, i) => i > r ? r : i < t ? t : i, Hr = { test: t => typeof t == "number", parse: parseFloat, transform: t => t }, Hi = { ...Hr, transform: t => un(0, 1, t) }, ms = { ...Hr, default: 1 }, Ji = t => ({ test: r => typeof r == "string" && r.endsWith(t) && r.split(" ").length === 1, parse: parseFloat, transform: r => `${r}${t}` }), Mn = Ji("deg"), Ht = Ji("%"), re = Ji("px"), nx = Ji("vh"), rx = Ji("vw"), ep = { ...Ht, parse: t => Ht.parse(t) / 100, transform: t => Ht.transform(t * 100) }, ix = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), tp = t => t === Hr || t === re, np = (t, r) => parseFloat(t.split(", ")[r]), rp = (t, r) => (i, { transform: s }) => { if (s === "none" || !s) return 0; const l = s.match(/^matrix3d\((.+)\)$/u); if (l) return np(l[1], r); { const f = s.match(/^matrix\((.+)\)$/u); return f ? np(f[1], t) : 0 } }, ox = new Set(["x", "y", "z"]), sx = Xi.filter(t => !ox.has(t)); function ax(t) { const r = []; return sx.forEach(i => { const s = t.getValue(i); s !== void 0 && (r.push([i, s.get()]), s.set(i.startsWith("scale") ? 1 : 0)) }), r } const Ir = { width: ({ x: t }, { paddingLeft: r = "0", paddingRight: i = "0" }) => t.max - t.min - parseFloat(r) - parseFloat(i), height: ({ y: t }, { paddingTop: r = "0", paddingBottom: i = "0" }) => t.max - t.min - parseFloat(r) - parseFloat(i), top: (t, { top: r }) => parseFloat(r), left: (t, { left: r }) => parseFloat(r), bottom: ({ y: t }, { top: r }) => parseFloat(r) + (t.max - t.min), right: ({ x: t }, { left: r }) => parseFloat(r) + (t.max - t.min), x: rp(4, 13), y: rp(5, 14) }; Ir.translateX = Ir.x; Ir.translateY = Ir.y; const ry = t => r => r.test(t), lx = { test: t => t === "auto", parse: t => t }, iy = [Hr, re, Ht, Mn, rx, nx, lx], ip = t => iy.find(ry(t)), nr = new Set; let Cu = !1, Tu = !1; function oy() { if (Tu) { const t = Array.from(nr).filter(s => s.needsMeasurement), r = new Set(t.map(s => s.element)), i = new Map; r.forEach(s => { const l = ax(s); l.length && (i.set(s, l), s.render()) }), t.forEach(s => s.measureInitialState()), r.forEach(s => { s.render(); const l = i.get(s); l && l.forEach(([f, u]) => { var h; (h = s.getValue(f)) === null || h === void 0 || h.set(u) }) }), t.forEach(s => s.measureEndState()), t.forEach(s => { s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY) }) } Tu = !1, Cu = !1, nr.forEach(t => t.complete()), nr.clear() } function sy() { nr.forEach(t => { t.readKeyframes(), t.needsMeasurement && (Tu = !0) }) } function ux() { sy(), oy() } class ac { constructor(r, i, s, l, f, u = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...r], this.onComplete = i, this.name = s, this.motionValue = l, this.element = f, this.isAsync = u } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (nr.add(this), Cu || (Cu = !0, ve.read(sy), ve.resolveKeyframes(oy))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: r, name: i, element: s, motionValue: l } = this; for (let f = 0; f < r.length; f++)if (r[f] === null) if (f === 0) { const u = l == null ? void 0 : l.get(), h = r[r.length - 1]; if (u !== void 0) r[0] = u; else if (s && i) { const p = s.readValue(i, h); p != null && (r[0] = p) } r[0] === void 0 && (r[0] = h), l && u === void 0 && l.set(r[0]) } else r[f] = r[f - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), nr.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, nr.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } const Bi = t => Math.round(t * 1e5) / 1e5, lc = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function cx(t) { return t == null } const fx = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, uc = (t, r) => i => !!(typeof i == "string" && fx.test(i) && i.startsWith(t) || r && !cx(i) && Object.prototype.hasOwnProperty.call(i, r)), ay = (t, r, i) => s => { if (typeof s != "string") return s; const [l, f, u, h] = s.match(lc); return { [t]: parseFloat(l), [r]: parseFloat(f), [i]: parseFloat(u), alpha: h !== void 0 ? parseFloat(h) : 1 } }, dx = t => un(0, 255, t), iu = { ...Hr, transform: t => Math.round(dx(t)) }, er = { test: uc("rgb", "red"), parse: ay("red", "green", "blue"), transform: ({ red: t, green: r, blue: i, alpha: s = 1 }) => "rgba(" + iu.transform(t) + ", " + iu.transform(r) + ", " + iu.transform(i) + ", " + Bi(Hi.transform(s)) + ")" }; function hx(t) { let r = "", i = "", s = "", l = ""; return t.length > 5 ? (r = t.substring(1, 3), i = t.substring(3, 5), s = t.substring(5, 7), l = t.substring(7, 9)) : (r = t.substring(1, 2), i = t.substring(2, 3), s = t.substring(3, 4), l = t.substring(4, 5), r += r, i += i, s += s, l += l), { red: parseInt(r, 16), green: parseInt(i, 16), blue: parseInt(s, 16), alpha: l ? parseInt(l, 16) / 255 : 1 } } const ku = { test: uc("#"), parse: hx, transform: er.transform }, Or = { test: uc("hsl", "hue"), parse: ay("hue", "saturation", "lightness"), transform: ({ hue: t, saturation: r, lightness: i, alpha: s = 1 }) => "hsla(" + Math.round(t) + ", " + Ht.transform(Bi(r)) + ", " + Ht.transform(Bi(i)) + ", " + Bi(Hi.transform(s)) + ")" }, Qe = { test: t => er.test(t) || ku.test(t) || Or.test(t), parse: t => er.test(t) ? er.parse(t) : Or.test(t) ? Or.parse(t) : ku.parse(t), transform: t => typeof t == "string" ? t : t.hasOwnProperty("red") ? er.transform(t) : Or.transform(t) }, px = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function mx(t) { var r, i; return isNaN(t) && typeof t == "string" && (((r = t.match(lc)) === null || r === void 0 ? void 0 : r.length) || 0) + (((i = t.match(px)) === null || i === void 0 ? void 0 : i.length) || 0) > 0 } const ly = "number", uy = "color", yx = "var", gx = "var(", op = "${}", vx = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Wi(t) { const r = t.toString(), i = [], s = { color: [], number: [], var: [] }, l = []; let f = 0; const h = r.replace(vx, p => (Qe.test(p) ? (s.color.push(f), l.push(uy), i.push(Qe.parse(p))) : p.startsWith(gx) ? (s.var.push(f), l.push(yx), i.push(p)) : (s.number.push(f), l.push(ly), i.push(parseFloat(p))), ++f, op)).split(op); return { values: i, split: h, indexes: s, types: l } } function cy(t) { return Wi(t).values } function fy(t) { const { split: r, types: i } = Wi(t), s = r.length; return l => { let f = ""; for (let u = 0; u < s; u++)if (f += r[u], l[u] !== void 0) { const h = i[u]; h === ly ? f += Bi(l[u]) : h === uy ? f += Qe.transform(l[u]) : f += l[u] } return f } } const wx = t => typeof t == "number" ? 0 : t; function xx(t) { const r = cy(t); return fy(t)(r.map(wx)) } const Fn = { test: mx, parse: cy, createTransformer: fy, getAnimatableNone: xx }, Sx = new Set(["brightness", "contrast", "saturate", "opacity"]); function Ex(t) { const [r, i] = t.slice(0, -1).split("("); if (r === "drop-shadow") return t; const [s] = i.match(lc) || []; if (!s) return t; const l = i.replace(s, ""); let f = Sx.has(r) ? 1 : 0; return s !== i && (f *= 100), r + "(" + f + l + ")" } const Px = /\b([a-z-]*)\(.*?\)/gu, Ru = { ...Fn, getAnimatableNone: t => { const r = t.match(Px); return r ? r.map(Ex).join(" ") : t } }, Cx = { borderWidth: re, borderTopWidth: re, borderRightWidth: re, borderBottomWidth: re, borderLeftWidth: re, borderRadius: re, radius: re, borderTopLeftRadius: re, borderTopRightRadius: re, borderBottomRightRadius: re, borderBottomLeftRadius: re, width: re, maxWidth: re, height: re, maxHeight: re, top: re, right: re, bottom: re, left: re, padding: re, paddingTop: re, paddingRight: re, paddingBottom: re, paddingLeft: re, margin: re, marginTop: re, marginRight: re, marginBottom: re, marginLeft: re, backgroundPositionX: re, backgroundPositionY: re }, Tx = { rotate: Mn, rotateX: Mn, rotateY: Mn, rotateZ: Mn, scale: ms, scaleX: ms, scaleY: ms, scaleZ: ms, skew: Mn, skewX: Mn, skewY: Mn, distance: re, translateX: re, translateY: re, translateZ: re, x: re, y: re, z: re, perspective: re, transformPerspective: re, opacity: Hi, originX: ep, originY: ep, originZ: re }, sp = { ...Hr, transform: Math.round }, cc = { ...Cx, ...Tx, zIndex: sp, size: re, fillOpacity: Hi, strokeOpacity: Hi, numOctaves: sp }, kx = { ...cc, color: Qe, backgroundColor: Qe, outlineColor: Qe, fill: Qe, stroke: Qe, borderColor: Qe, borderTopColor: Qe, borderRightColor: Qe, borderBottomColor: Qe, borderLeftColor: Qe, filter: Ru, WebkitFilter: Ru }, fc = t => kx[t]; function dy(t, r) { let i = fc(t); return i !== Ru && (i = Fn), i.getAnimatableNone ? i.getAnimatableNone(r) : void 0 } const Rx = new Set(["auto", "none", "0"]); function Ax(t, r, i) { let s = 0, l; for (; s < t.length && !l;) { const f = t[s]; typeof f == "string" && !Rx.has(f) && Wi(f).values.length && (l = t[s]), s++ } if (l && i) for (const f of r) t[f] = dy(i, l) } class hy extends ac { constructor(r, i, s, l, f) { super(r, i, s, l, f, !0) } readKeyframes() { const { unresolvedKeyframes: r, element: i, name: s } = this; if (!i || !i.current) return; super.readKeyframes(); for (let p = 0; p < r.length; p++) { let m = r[p]; if (typeof m == "string" && (m = m.trim(), sc(m))) { const y = ny(m, i.current); y !== void 0 && (r[p] = y), p === r.length - 1 && (this.finalKeyframe = m) } } if (this.resolveNoneKeyframes(), !ix.has(s) || r.length !== 2) return; const [l, f] = r, u = ip(l), h = ip(f); if (u !== h) if (tp(u) && tp(h)) for (let p = 0; p < r.length; p++) { const m = r[p]; typeof m == "string" && (r[p] = parseFloat(m)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: r, name: i } = this, s = []; for (let l = 0; l < r.length; l++)Yw(r[l]) && s.push(l); s.length && Ax(r, s, i) } measureInitialState() { const { element: r, unresolvedKeyframes: i, name: s } = this; if (!r || !r.current) return; s === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Ir[s](r.measureViewportBox(), window.getComputedStyle(r.current)), i[0] = this.measuredOrigin; const l = i[i.length - 1]; l !== void 0 && r.getValue(s, l).jump(l, !1) } measureEndState() { var r; const { element: i, name: s, unresolvedKeyframes: l } = this; if (!i || !i.current) return; const f = i.getValue(s); f && f.jump(this.measuredOrigin, !1); const u = l.length - 1, h = l[u]; l[u] = Ir[s](i.measureViewportBox(), window.getComputedStyle(i.current)), h !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = h), !((r = this.removedTransforms) === null || r === void 0) && r.length && this.removedTransforms.forEach(([p, m]) => { i.getValue(p).set(m) }), this.resolveNoneKeyframes() } } function dc(t) { return typeof t == "function" } let Ss; function Lx() { Ss = void 0 } const Wt = { now: () => (Ss === void 0 && Wt.set(He.isProcessing || Hw.useManualTiming ? He.timestamp : performance.now()), Ss), set: t => { Ss = t, queueMicrotask(Lx) } }, ap = (t, r) => r === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (Fn.test(t) || t === "0") && !t.startsWith("url(")); function Dx(t) { const r = t[0]; if (t.length === 1) return !0; for (let i = 0; i < t.length; i++)if (t[i] !== r) return !0 } function _x(t, r, i, s) { const l = t[0]; if (l === null) return !1; if (r === "display" || r === "visibility") return !0; const f = t[t.length - 1], u = ap(l, r), h = ap(f, r); return !u || !h ? !1 : Dx(t) || (i === "spring" || dc(i)) && s } const Mx = 40; class py { constructor({ autoplay: r = !0, delay: i = 0, type: s = "keyframes", repeat: l = 0, repeatDelay: f = 0, repeatType: u = "loop", ...h }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Wt.now(), this.options = { autoplay: r, delay: i, type: s, repeat: l, repeatDelay: f, repeatType: u, ...h }, this.updateFinishedPromise() } calcStartTime() { return this.resolvedAt ? this.resolvedAt - this.createdAt > Mx ? this.resolvedAt : this.createdAt : this.createdAt } get resolved() { return !this._resolved && !this.hasAttemptedResolve && ux(), this._resolved } onKeyframesResolved(r, i) { this.resolvedAt = Wt.now(), this.hasAttemptedResolve = !0; const { name: s, type: l, velocity: f, delay: u, onComplete: h, onUpdate: p, isGenerator: m } = this.options; if (!m && !_x(r, s, l, f)) if (u) this.options.duration = 0; else { p == null || p($s(r, this.options, i)), h == null || h(), this.resolveFinishedPromise(); return } const y = this.initPlayback(r, i); y !== !1 && (this._resolved = { keyframes: r, finalKeyframe: i, ...y }, this.onPostResolved()) } onPostResolved() { } then(r, i) { return this.currentFinishedPromise.then(r, i) } flatten() { this.options.type = "keyframes", this.options.ease = "linear" } updateFinishedPromise() { this.currentFinishedPromise = new Promise(r => { this.resolveFinishedPromise = r }) } } const Br = (t, r, i) => { const s = r - t; return s === 0 ? 1 : (i - t) / s }, my = (t, r, i = 10) => { let s = ""; const l = Math.max(Math.round(r / i), 2); for (let f = 0; f < l; f++)s += t(Br(0, l - 1, f)) + ", "; return `linear(${s.substring(0, s.length - 2)})` }; function yy(t, r) { return r ? t * (1e3 / r) : 0 } const Ox = 5; function gy(t, r, i) { const s = Math.max(r - Ox, 0); return yy(i - t(s), r - s) } const De = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, ou = .001; function Nx({ duration: t = De.duration, bounce: r = De.bounce, velocity: i = De.velocity, mass: s = De.mass }) { let l, f, u = 1 - r; u = un(De.minDamping, De.maxDamping, u), t = un(De.minDuration, De.maxDuration, sn(t)), u < 1 ? (l = m => { const y = m * u, v = y * t, w = y - i, C = Au(m, u), S = Math.exp(-v); return ou - w / C * S }, f = m => { const v = m * u * t, w = v * i + i, C = Math.pow(u, 2) * Math.pow(m, 2) * t, S = Math.exp(-v), R = Au(Math.pow(m, 2), u); return (-l(m) + ou > 0 ? -1 : 1) * ((w - C) * S) / R }) : (l = m => { const y = Math.exp(-m * t), v = (m - i) * t + 1; return -ou + y * v }, f = m => { const y = Math.exp(-m * t), v = (i - m) * (t * t); return y * v }); const h = 5 / t, p = Vx(l, f, h); if (t = on(t), isNaN(p)) return { stiffness: De.stiffness, damping: De.damping, duration: t }; { const m = Math.pow(p, 2) * s; return { stiffness: m, damping: u * 2 * Math.sqrt(s * m), duration: t } } } const Fx = 12; function Vx(t, r, i) { let s = i; for (let l = 1; l < Fx; l++)s = s - t(s) / r(s); return s } function Au(t, r) { return t * Math.sqrt(1 - r * r) } const Lu = 2e4; function vy(t) { let r = 0; const i = 50; let s = t.next(r); for (; !s.done && r < Lu;)r += i, s = t.next(r); return r >= Lu ? 1 / 0 : r } const jx = ["duration", "bounce"], Ix = ["stiffness", "damping", "mass"]; function lp(t, r) { return r.some(i => t[i] !== void 0) } function Bx(t) { let r = { velocity: De.velocity, stiffness: De.stiffness, damping: De.damping, mass: De.mass, isResolvedFromDuration: !1, ...t }; if (!lp(t, Ix) && lp(t, jx)) if (t.visualDuration) { const i = t.visualDuration, s = 2 * Math.PI / (i * 1.2), l = s * s, f = 2 * un(.05, 1, 1 - t.bounce) * Math.sqrt(l); r = { ...r, mass: De.mass, stiffness: l, damping: f } } else { const i = Nx(t); r = { ...r, ...i, mass: De.mass }, r.isResolvedFromDuration = !0 } return r } function wy(t = De.visualDuration, r = De.bounce) { const i = typeof t != "object" ? { visualDuration: t, keyframes: [0, 1], bounce: r } : t; let { restSpeed: s, restDelta: l } = i; const f = i.keyframes[0], u = i.keyframes[i.keyframes.length - 1], h = { done: !1, value: f }, { stiffness: p, damping: m, mass: y, duration: v, velocity: w, isResolvedFromDuration: C } = Bx({ ...i, velocity: -sn(i.velocity || 0) }), S = w || 0, R = m / (2 * Math.sqrt(p * y)), P = u - f, A = sn(Math.sqrt(p / y)), N = Math.abs(P) < 5; s || (s = N ? De.restSpeed.granular : De.restSpeed.default), l || (l = N ? De.restDelta.granular : De.restDelta.default); let F; if (R < 1) { const z = Au(A, R); F = Y => { const ne = Math.exp(-R * A * Y); return u - ne * ((S + R * A * P) / z * Math.sin(z * Y) + P * Math.cos(z * Y)) } } else if (R === 1) F = z => u - Math.exp(-A * z) * (P + (S + A * P) * z); else { const z = A * Math.sqrt(R * R - 1); F = Y => { const ne = Math.exp(-R * A * Y), Q = Math.min(z * Y, 300); return u - ne * ((S + R * A * P) * Math.sinh(Q) + z * P * Math.cosh(Q)) / z } } const b = { calculatedDuration: C && v || null, next: z => { const Y = F(z); if (C) h.done = z >= v; else { let ne = 0; R < 1 && (ne = z === 0 ? on(S) : gy(F, z, Y)); const Q = Math.abs(ne) <= s, se = Math.abs(u - Y) <= l; h.done = Q && se } return h.value = h.done ? u : Y, h }, toString: () => { const z = Math.min(vy(b), Lu), Y = my(ne => b.next(z * ne).value, z, 30); return z + "ms " + Y } }; return b } function up({ keyframes: t, velocity: r = 0, power: i = .8, timeConstant: s = 325, bounceDamping: l = 10, bounceStiffness: f = 500, modifyTarget: u, min: h, max: p, restDelta: m = .5, restSpeed: y }) { const v = t[0], w = { done: !1, value: v }, C = Q => h !== void 0 && Q < h || p !== void 0 && Q > p, S = Q => h === void 0 ? p : p === void 0 || Math.abs(h - Q) < Math.abs(p - Q) ? h : p; let R = i * r; const P = v + R, A = u === void 0 ? P : u(P); A !== P && (R = A - v); const N = Q => -R * Math.exp(-Q / s), F = Q => A + N(Q), b = Q => { const se = N(Q), me = F(Q); w.done = Math.abs(se) <= m, w.value = w.done ? A : me }; let z, Y; const ne = Q => { C(w.value) && (z = Q, Y = wy({ keyframes: [w.value, S(w.value)], velocity: gy(F, Q, w.value), damping: l, stiffness: f, restDelta: m, restSpeed: y })) }; return ne(0), { calculatedDuration: null, next: Q => { let se = !1; return !Y && z === void 0 && (se = !0, b(Q), ne(Q)), z !== void 0 && Q >= z ? Y.next(Q - z) : (!se && b(Q), w) } } } const zx = Yi(.42, 0, 1, 1), Ux = Yi(0, 0, .58, 1), xy = Yi(.42, 0, .58, 1), bx = t => Array.isArray(t) && typeof t[0] != "number", hc = t => Array.isArray(t) && typeof t[0] == "number", cp = { linear: Je, easeIn: zx, easeInOut: xy, easeOut: Ux, circIn: oc, circInOut: Ym, circOut: Xm, backIn: ic, backInOut: Gm, backOut: qm, anticipate: Qm }, fp = t => { if (hc(t)) { Pu(t.length === 4); const [r, i, s, l] = t; return Yi(r, i, s, l) } else if (typeof t == "string") return Pu(cp[t] !== void 0), cp[t]; return t }, $x = (t, r) => i => r(t(i)), an = (...t) => t.reduce($x), Ae = (t, r, i) => t + (r - t) * i; function su(t, r, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + (r - t) * 6 * i : i < 1 / 2 ? r : i < 2 / 3 ? t + (r - t) * (2 / 3 - i) * 6 : t } function Hx({ hue: t, saturation: r, lightness: i, alpha: s }) { t /= 360, r /= 100, i /= 100; let l = 0, f = 0, u = 0; if (!r) l = f = u = i; else { const h = i < .5 ? i * (1 + r) : i + r - i * r, p = 2 * i - h; l = su(p, h, t + 1 / 3), f = su(p, h, t), u = su(p, h, t - 1 / 3) } return { red: Math.round(l * 255), green: Math.round(f * 255), blue: Math.round(u * 255), alpha: s } } function Ds(t, r) { return i => i > 0 ? r : t } const au = (t, r, i) => { const s = t * t, l = i * (r * r - s) + s; return l < 0 ? 0 : Math.sqrt(l) }, Wx = [ku, er, Or], Kx = t => Wx.find(r => r.test(t)); function dp(t) { const r = Kx(t); if (!r) return !1; let i = r.parse(t); return r === Or && (i = Hx(i)), i } const hp = (t, r) => { const i = dp(t), s = dp(r); if (!i || !s) return Ds(t, r); const l = { ...i }; return f => (l.red = au(i.red, s.red, f), l.green = au(i.green, s.green, f), l.blue = au(i.blue, s.blue, f), l.alpha = Ae(i.alpha, s.alpha, f), er.transform(l)) }, Du = new Set(["none", "hidden"]); function qx(t, r) { return Du.has(t) ? i => i <= 0 ? t : r : i => i >= 1 ? r : t } function Gx(t, r) { return i => Ae(t, r, i) } function pc(t) { return typeof t == "number" ? Gx : typeof t == "string" ? sc(t) ? Ds : Qe.test(t) ? hp : Yx : Array.isArray(t) ? Sy : typeof t == "object" ? Qe.test(t) ? hp : Qx : Ds } function Sy(t, r) { const i = [...t], s = i.length, l = t.map((f, u) => pc(f)(f, r[u])); return f => { for (let u = 0; u < s; u++)i[u] = l[u](f); return i } } function Qx(t, r) { const i = { ...t, ...r }, s = {}; for (const l in i) t[l] !== void 0 && r[l] !== void 0 && (s[l] = pc(t[l])(t[l], r[l])); return l => { for (const f in s) i[f] = s[f](l); return i } } function Xx(t, r) { var i; const s = [], l = { color: 0, var: 0, number: 0 }; for (let f = 0; f < r.values.length; f++) { const u = r.types[f], h = t.indexes[u][l[u]], p = (i = t.values[h]) !== null && i !== void 0 ? i : 0; s[f] = p, l[u]++ } return s } const Yx = (t, r) => { const i = Fn.createTransformer(r), s = Wi(t), l = Wi(r); return s.indexes.var.length === l.indexes.var.length && s.indexes.color.length === l.indexes.color.length && s.indexes.number.length >= l.indexes.number.length ? Du.has(t) && !l.values.length || Du.has(r) && !s.values.length ? qx(t, r) : an(Sy(Xx(s, l), l.values), i) : Ds(t, r) }; function Ey(t, r, i) { return typeof t == "number" && typeof r == "number" && typeof i == "number" ? Ae(t, r, i) : pc(t)(t, r) } function Jx(t, r, i) { const s = [], l = i || Ey, f = t.length - 1; for (let u = 0; u < f; u++) { let h = l(t[u], t[u + 1]); if (r) { const p = Array.isArray(r) ? r[u] || Je : r; h = an(p, h) } s.push(h) } return s } function Zx(t, r, { clamp: i = !0, ease: s, mixer: l } = {}) { const f = t.length; if (Pu(f === r.length), f === 1) return () => r[0]; if (f === 2 && t[0] === t[1]) return () => r[1]; t[0] > t[f - 1] && (t = [...t].reverse(), r = [...r].reverse()); const u = Jx(r, s, l), h = u.length, p = m => { let y = 0; if (h > 1) for (; y < t.length - 2 && !(m < t[y + 1]); y++); const v = Br(t[y], t[y + 1], m); return u[y](v) }; return i ? m => p(un(t[0], t[f - 1], m)) : p } function eS(t, r) { const i = t[t.length - 1]; for (let s = 1; s <= r; s++) { const l = Br(0, r, s); t.push(Ae(i, 1, l)) } } function tS(t) { const r = [0]; return eS(r, t.length - 1), r } function nS(t, r) { return t.map(i => i * r) } function rS(t, r) { return t.map(() => r || xy).splice(0, t.length - 1) } function _s({ duration: t = 300, keyframes: r, times: i, ease: s = "easeInOut" }) { const l = bx(s) ? s.map(fp) : fp(s), f = { done: !1, value: r[0] }, u = nS(i && i.length === r.length ? i : tS(r), t), h = Zx(u, r, { ease: Array.isArray(l) ? l : rS(r, l) }); return { calculatedDuration: t, next: p => (f.value = h(p), f.done = p >= t, f) } } const iS = t => { const r = ({ timestamp: i }) => t(i); return { start: () => ve.update(r, !0), stop: () => Nn(r), now: () => He.isProcessing ? He.timestamp : Wt.now() } }, oS = { decay: up, inertia: up, tween: _s, keyframes: _s, spring: wy }, sS = t => t / 100; class mc extends py { constructor(r) { super(r), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); const { onStop: p } = this.options; p && p() }; const { name: i, motionValue: s, element: l, keyframes: f } = this.options, u = (l == null ? void 0 : l.KeyframeResolver) || ac, h = (p, m) => this.onKeyframesResolved(p, m); this.resolver = new u(f, h, i, s, l), this.resolver.scheduleResolve() } flatten() { super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes)) } initPlayback(r) { const { type: i = "keyframes", repeat: s = 0, repeatDelay: l = 0, repeatType: f, velocity: u = 0 } = this.options, h = dc(i) ? i : oS[i] || _s; let p, m; h !== _s && typeof r[0] != "number" && (p = an(sS, Ey(r[0], r[1])), r = [0, 100]); const y = h({ ...this.options, keyframes: r }); f === "mirror" && (m = h({ ...this.options, keyframes: [...r].reverse(), velocity: -u })), y.calculatedDuration === null && (y.calculatedDuration = vy(y)); const { calculatedDuration: v } = y, w = v + l, C = w * (s + 1) - l; return { generator: y, mirroredGenerator: m, mapPercentToKeyframes: p, calculatedDuration: v, resolvedDuration: w, totalDuration: C } } onPostResolved() { const { autoplay: r = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !r ? this.pause() : this.state = this.pendingPlayState } tick(r, i = !1) { const { resolved: s } = this; if (!s) { const { keyframes: Q } = this.options; return { done: !0, value: Q[Q.length - 1] } } const { finalKeyframe: l, generator: f, mirroredGenerator: u, mapPercentToKeyframes: h, keyframes: p, calculatedDuration: m, totalDuration: y, resolvedDuration: v } = s; if (this.startTime === null) return f.next(0); const { delay: w, repeat: C, repeatType: S, repeatDelay: R, onUpdate: P } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, r) : this.speed < 0 && (this.startTime = Math.min(r - y / this.speed, this.startTime)), i ? this.currentTime = r : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(r - this.startTime) * this.speed; const A = this.currentTime - w * (this.speed >= 0 ? 1 : -1), N = this.speed >= 0 ? A < 0 : A > y; this.currentTime = Math.max(A, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = y); let F = this.currentTime, b = f; if (C) { const Q = Math.min(this.currentTime, y) / v; let se = Math.floor(Q), me = Q % 1; !me && Q >= 1 && (me = 1), me === 1 && se--, se = Math.min(se, C + 1), !!(se % 2) && (S === "reverse" ? (me = 1 - me, R && (me -= R / v)) : S === "mirror" && (b = u)), F = un(0, 1, me) * v } const z = N ? { done: !1, value: p[0] } : b.next(F); h && (z.value = h(z.value)); let { done: Y } = z; !N && m !== null && (Y = this.speed >= 0 ? this.currentTime >= y : this.currentTime <= 0); const ne = this.holdTime === null && (this.state === "finished" || this.state === "running" && Y); return ne && l !== void 0 && (z.value = $s(p, this.options, l)), P && P(z.value), ne && this.finish(), z } get duration() { const { resolved: r } = this; return r ? sn(r.calculatedDuration) : 0 } get time() { return sn(this.currentTime) } set time(r) { r = on(r), this.currentTime = r, this.holdTime !== null || this.speed === 0 ? this.holdTime = r : this.driver && (this.startTime = this.driver.now() - r / this.speed) } get speed() { return this.playbackSpeed } set speed(r) { const i = this.playbackSpeed !== r; this.playbackSpeed = r, i && (this.time = sn(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; const { driver: r = iS, onPlay: i, startTime: s } = this.options; this.driver || (this.driver = r(f => this.tick(f))), i && i(); const l = this.driver.now(); this.holdTime !== null ? this.startTime = l - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = l) : this.startTime = s ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var r; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (r = this.currentTime) !== null && r !== void 0 ? r : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: r } = this.options; r && r() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(r) { return this.startTime = 0, this.tick(r, !0) } } const aS = new Set(["opacity", "clipPath", "filter", "transform"]); function yc(t) { let r; return () => (r === void 0 && (r = t()), r) } const lS = { linearEasing: void 0 }; function uS(t, r) { const i = yc(t); return () => { var s; return (s = lS[r]) !== null && s !== void 0 ? s : i() } } const Ms = uS(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"); function Py(t) { return !!(typeof t == "function" && Ms() || !t || typeof t == "string" && (t in _u || Ms()) || hc(t) || Array.isArray(t) && t.every(Py)) } const ji = ([t, r, i, s]) => `cubic-bezier(${t}, ${r}, ${i}, ${s})`, _u = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: ji([0, .65, .55, 1]), circOut: ji([.55, 0, 1, .45]), backIn: ji([.31, .01, .66, -.59]), backOut: ji([.33, 1.53, .69, .99]) }; function Cy(t, r) { if (t) return typeof t == "function" && Ms() ? my(t, r) : hc(t) ? ji(t) : Array.isArray(t) ? t.map(i => Cy(i, r) || _u.easeOut) : _u[t] } function cS(t, r, i, { delay: s = 0, duration: l = 300, repeat: f = 0, repeatType: u = "loop", ease: h = "easeInOut", times: p } = {}) { const m = { [r]: i }; p && (m.offset = p); const y = Cy(h, l); return Array.isArray(y) && (m.easing = y), t.animate(m, { delay: s, duration: l, easing: Array.isArray(y) ? "linear" : y, fill: "both", iterations: f + 1, direction: u === "reverse" ? "alternate" : "normal" }) } function pp(t, r) { t.timeline = r, t.onfinish = null } const fS = yc(() => Object.hasOwnProperty.call(Element.prototype, "animate")), Os = 10, dS = 2e4; function hS(t) { return dc(t.type) || t.type === "spring" || !Py(t.ease) } function pS(t, r) { const i = new mc({ ...r, keyframes: t, repeat: 0, delay: 0, isGenerator: !0 }); let s = { done: !1, value: t[0] }; const l = []; let f = 0; for (; !s.done && f < dS;)s = i.sample(f), l.push(s.value), f += Os; return { times: void 0, keyframes: l, duration: f - Os, ease: "linear" } } const Ty = { anticipate: Qm, backInOut: Gm, circInOut: Ym }; function mS(t) { return t in Ty } class mp extends py { constructor(r) { super(r); const { name: i, motionValue: s, element: l, keyframes: f } = this.options; this.resolver = new hy(f, (u, h) => this.onKeyframesResolved(u, h), i, s, l), this.resolver.scheduleResolve() } initPlayback(r, i) { var s; let { duration: l = 300, times: f, ease: u, type: h, motionValue: p, name: m, startTime: y } = this.options; if (!(!((s = p.owner) === null || s === void 0) && s.current)) return !1; if (typeof u == "string" && Ms() && mS(u) && (u = Ty[u]), hS(this.options)) { const { onComplete: w, onUpdate: C, motionValue: S, element: R, ...P } = this.options, A = pS(r, P); r = A.keyframes, r.length === 1 && (r[1] = r[0]), l = A.duration, f = A.times, u = A.ease, h = "keyframes" } const v = cS(p.owner.current, m, r, { ...this.options, duration: l, times: f, ease: u }); return v.startTime = y ?? this.calcStartTime(), this.pendingTimeline ? (pp(v, this.pendingTimeline), this.pendingTimeline = void 0) : v.onfinish = () => { const { onComplete: w } = this.options; p.set($s(r, this.options, i)), w && w(), this.cancel(), this.resolveFinishedPromise() }, { animation: v, duration: l, times: f, type: h, ease: u, keyframes: r } } get duration() { const { resolved: r } = this; if (!r) return 0; const { duration: i } = r; return sn(i) } get time() { const { resolved: r } = this; if (!r) return 0; const { animation: i } = r; return sn(i.currentTime || 0) } set time(r) { const { resolved: i } = this; if (!i) return; const { animation: s } = i; s.currentTime = on(r) } get speed() { const { resolved: r } = this; if (!r) return 1; const { animation: i } = r; return i.playbackRate } set speed(r) { const { resolved: i } = this; if (!i) return; const { animation: s } = i; s.playbackRate = r } get state() { const { resolved: r } = this; if (!r) return "idle"; const { animation: i } = r; return i.playState } get startTime() { const { resolved: r } = this; if (!r) return null; const { animation: i } = r; return i.startTime } attachTimeline(r) { if (!this._resolved) this.pendingTimeline = r; else { const { resolved: i } = this; if (!i) return Je; const { animation: s } = i; pp(s, r) } return Je } play() { if (this.isStopped) return; const { resolved: r } = this; if (!r) return; const { animation: i } = r; i.playState === "finished" && this.updateFinishedPromise(), i.play() } pause() { const { resolved: r } = this; if (!r) return; const { animation: i } = r; i.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.resolveFinishedPromise(), this.updateFinishedPromise(); const { resolved: r } = this; if (!r) return; const { animation: i, keyframes: s, duration: l, type: f, ease: u, times: h } = r; if (i.playState === "idle" || i.playState === "finished") return; if (this.time) { const { motionValue: m, onUpdate: y, onComplete: v, element: w, ...C } = this.options, S = new mc({ ...C, keyframes: s, duration: l, type: f, ease: u, times: h, isGenerator: !0 }), R = on(this.time); m.setWithVelocity(S.sample(R - Os).value, S.sample(R).value, Os) } const { onStop: p } = this.options; p && p(), this.cancel() } complete() { const { resolved: r } = this; r && r.animation.finish() } cancel() { const { resolved: r } = this; r && r.animation.cancel() } static supports(r) { const { motionValue: i, name: s, repeatDelay: l, repeatType: f, damping: u, type: h } = r; return fS() && s && aS.has(s) && i && i.owner && i.owner.current instanceof HTMLElement && !i.owner.getProps().onUpdate && !l && f !== "mirror" && u !== 0 && h !== "inertia" } } const yS = yc(() => window.ScrollTimeline !== void 0); class gS { constructor(r) { this.stop = () => this.runAll("stop"), this.animations = r.filter(Boolean) } then(r, i) { return Promise.all(this.animations).then(r).catch(i) } getAll(r) { return this.animations[0][r] } setAll(r, i) { for (let s = 0; s < this.animations.length; s++)this.animations[s][r] = i } attachTimeline(r, i) { const s = this.animations.map(l => yS() && l.attachTimeline ? l.attachTimeline(r) : i(l)); return () => { s.forEach((l, f) => { l && l(), this.animations[f].stop() }) } } get time() { return this.getAll("time") } set time(r) { this.setAll("time", r) } get speed() { return this.getAll("speed") } set speed(r) { this.setAll("speed", r) } get startTime() { return this.getAll("startTime") } get duration() { let r = 0; for (let i = 0; i < this.animations.length; i++)r = Math.max(r, this.animations[i].duration); return r } runAll(r) { this.animations.forEach(i => i[r]()) } flatten() { this.runAll("flatten") } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } } function vS({ when: t, delay: r, delayChildren: i, staggerChildren: s, staggerDirection: l, repeat: f, repeatType: u, repeatDelay: h, from: p, elapsed: m, ...y }) { return !!Object.keys(y).length } const gc = (t, r, i, s = {}, l, f) => u => { const h = rc(s, t) || {}, p = h.delay || s.delay || 0; let { elapsed: m = 0 } = s; m = m - on(p); let y = { keyframes: Array.isArray(i) ? i : [null, i], ease: "easeOut", velocity: r.getVelocity(), ...h, delay: -m, onUpdate: w => { r.set(w), h.onUpdate && h.onUpdate(w) }, onComplete: () => { u(), h.onComplete && h.onComplete() }, name: t, motionValue: r, element: f ? void 0 : l }; vS(h) || (y = { ...y, ...$w(t, y) }), y.duration && (y.duration = on(y.duration)), y.repeatDelay && (y.repeatDelay = on(y.repeatDelay)), y.from !== void 0 && (y.keyframes[0] = y.from); let v = !1; if ((y.type === !1 || y.duration === 0 && !y.repeatDelay) && (y.duration = 0, y.delay === 0 && (v = !0)), v && !f && r.get() !== void 0) { const w = $s(y.keyframes, h); if (w !== void 0) return ve.update(() => { y.onUpdate(w), y.onComplete() }), new gS([]) } return !f && mp.supports(y) ? new mp(y) : new mc(y) }, wS = t => !!(t && typeof t == "object" && t.mix && t.toValue), xS = t => Eu(t) ? t[t.length - 1] || 0 : t; function vc(t, r) { t.indexOf(r) === -1 && t.push(r) } function wc(t, r) { const i = t.indexOf(r); i > -1 && t.splice(i, 1) } class xc { constructor() { this.subscriptions = [] } add(r) { return vc(this.subscriptions, r), () => wc(this.subscriptions, r) } notify(r, i, s) { const l = this.subscriptions.length; if (l) if (l === 1) this.subscriptions[0](r, i, s); else for (let f = 0; f < l; f++) { const u = this.subscriptions[f]; u && u(r, i, s) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const yp = 30, SS = t => !isNaN(parseFloat(t)); class ES { constructor(r, i = {}) { this.version = "11.12.0", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (s, l = !0) => { const f = Wt.now(); this.updatedAt !== f && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(s), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), l && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(r), this.owner = i.owner } setCurrent(r) { this.current = r, this.updatedAt = Wt.now(), this.canTrackVelocity === null && r !== void 0 && (this.canTrackVelocity = SS(this.current)) } setPrevFrameValue(r = this.current) { this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt } onChange(r) { return this.on("change", r) } on(r, i) { this.events[r] || (this.events[r] = new xc); const s = this.events[r].add(i); return r === "change" ? () => { s(), ve.read(() => { this.events.change.getSize() || this.stop() }) } : s } clearListeners() { for (const r in this.events) this.events[r].clear() } attach(r, i) { this.passiveEffect = r, this.stopPassiveEffect = i } set(r, i = !0) { !i || !this.passiveEffect ? this.updateAndNotify(r, i) : this.passiveEffect(r, this.updateAndNotify) } setWithVelocity(r, i, s) { this.set(i), this.prev = void 0, this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt - s } jump(r, i = !0) { this.updateAndNotify(r), this.prev = r, this.prevUpdatedAt = this.prevFrameValue = void 0, i && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const r = Wt.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || r - this.updatedAt > yp) return 0; const i = Math.min(this.updatedAt - this.prevUpdatedAt, yp); return yy(parseFloat(this.current) - parseFloat(this.prevFrameValue), i) } start(r) { return this.stop(), new Promise(i => { this.hasAnimated = !0, this.animation = r(i), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function Ki(t, r) { return new ES(t, r) } function PS(t, r, i) { t.hasValue(r) ? t.getValue(r).set(i) : t.addValue(r, Ki(i)) } function CS(t, r) { const i = bs(t, r); let { transitionEnd: s = {}, transition: l = {}, ...f } = i || {}; f = { ...f, ...s }; for (const u in f) { const h = xS(f[u]); PS(t, u, h) } } const Sc = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), TS = "framerAppearId", ky = "data-" + Sc(TS); function Ry(t) { return t.props[ky] } const Ye = t => !!(t && t.getVelocity); function kS(t) { return !!(Ye(t) && t.add) } function Mu(t, r) { const i = t.getValue("willChange"); if (kS(i)) return i.add(r) } function RS({ protectedKeys: t, needsAnimating: r }, i) { const s = t.hasOwnProperty(i) && r[i] !== !0; return r[i] = !1, s } function Ay(t, r, { delay: i = 0, transitionOverride: s, type: l } = {}) { var f; let { transition: u = t.getDefaultTransition(), transitionEnd: h, ...p } = r; s && (u = s); const m = [], y = l && t.animationState && t.animationState.getState()[l]; for (const v in p) { const w = t.getValue(v, (f = t.latestValues[v]) !== null && f !== void 0 ? f : null), C = p[v]; if (C === void 0 || y && RS(y, v)) continue; const S = { delay: i, ...rc(u || {}, v) }; let R = !1; if (window.MotionHandoffAnimation) { const A = Ry(t); if (A) { const N = window.MotionHandoffAnimation(A, v, ve); N !== null && (S.startTime = N, R = !0) } } Mu(t, v), w.start(gc(v, w, C, t.shouldReduceMotion && sr.has(v) ? { type: !1 } : S, t, R)); const P = w.animation; P && m.push(P) } return h && Promise.all(m).then(() => { ve.update(() => { h && CS(t, h) }) }), m } function Ou(t, r, i = {}) { var s; const l = bs(t, r, i.type === "exit" ? (s = t.presenceContext) === null || s === void 0 ? void 0 : s.custom : void 0); let { transition: f = t.getDefaultTransition() || {} } = l || {}; i.transitionOverride && (f = i.transitionOverride); const u = l ? () => Promise.all(Ay(t, l, i)) : () => Promise.resolve(), h = t.variantChildren && t.variantChildren.size ? (m = 0) => { const { delayChildren: y = 0, staggerChildren: v, staggerDirection: w } = f; return AS(t, r, y + m, v, w, i) } : () => Promise.resolve(), { when: p } = f; if (p) { const [m, y] = p === "beforeChildren" ? [u, h] : [h, u]; return m().then(() => y()) } else return Promise.all([u(), h(i.delay)]) } function AS(t, r, i = 0, s = 0, l = 1, f) { const u = [], h = (t.variantChildren.size - 1) * s, p = l === 1 ? (m = 0) => m * s : (m = 0) => h - m * s; return Array.from(t.variantChildren).sort(LS).forEach((m, y) => { m.notify("AnimationStart", r), u.push(Ou(m, r, { ...f, delay: i + p(y) }).then(() => m.notify("AnimationComplete", r))) }), Promise.all(u) } function LS(t, r) { return t.sortNodePosition(r) } function DS(t, r, i = {}) { t.notify("AnimationStart", r); let s; if (Array.isArray(r)) { const l = r.map(f => Ou(t, f, i)); s = Promise.all(l) } else if (typeof r == "string") s = Ou(t, r, i); else { const l = typeof r == "function" ? bs(t, r, i.custom) : r; s = Promise.all(Ay(t, l, i)) } return s.then(() => { t.notify("AnimationComplete", r) }) } const _S = nc.length; function Ly(t) { if (!t) return; if (!t.isControllingVariants) { const i = t.parent ? Ly(t.parent) || {} : {}; return t.props.initial !== void 0 && (i.initial = t.props.initial), i } const r = {}; for (let i = 0; i < _S; i++) { const s = nc[i], l = t.props[s]; ($i(l) || l === !1) && (r[s] = l) } return r } const MS = [...tc].reverse(), OS = tc.length; function NS(t) { return r => Promise.all(r.map(({ animation: i, options: s }) => DS(t, i, s))) } function FS(t) { let r = NS(t), i = gp(), s = !0; const l = p => (m, y) => { var v; const w = bs(t, y, p === "exit" ? (v = t.presenceContext) === null || v === void 0 ? void 0 : v.custom : void 0); if (w) { const { transition: C, transitionEnd: S, ...R } = w; m = { ...m, ...R, ...S } } return m }; function f(p) { r = p(t) } function u(p) { const { props: m } = t, y = Ly(t.parent) || {}, v = [], w = new Set; let C = {}, S = 1 / 0; for (let P = 0; P < OS; P++) { const A = MS[P], N = i[A], F = m[A] !== void 0 ? m[A] : y[A], b = $i(F), z = A === p ? N.isActive : null; z === !1 && (S = P); let Y = F === y[A] && F !== m[A] && b; if (Y && s && t.manuallyAnimateOnMount && (Y = !1), N.protectedKeys = { ...C }, !N.isActive && z === null || !F && !N.prevProp || Us(F) || typeof F == "boolean") continue; const ne = VS(N.prevProp, F); let Q = ne || A === p && N.isActive && !Y && b || P > S && b, se = !1; const me = Array.isArray(F) ? F : [F]; let Ue = me.reduce(l(A), {}); z === !1 && (Ue = {}); const { prevResolvedValues: ft = {} } = N, Ze = { ...ft, ...Ue }, rt = le => { Q = !0, w.has(le) && (se = !0, w.delete(le)), N.needsAnimating[le] = !0; const $ = t.getValue(le); $ && ($.liveStyle = !1) }; for (const le in Ze) { const $ = Ue[le], Z = ft[le]; if (C.hasOwnProperty(le)) continue; let K = !1; Eu($) && Eu(Z) ? K = !bm($, Z) : K = $ !== Z, K ? $ != null ? rt(le) : w.add(le) : $ !== void 0 && w.has(le) ? rt(le) : N.protectedKeys[le] = !0 } N.prevProp = F, N.prevResolvedValues = Ue, N.isActive && (C = { ...C, ...Ue }), s && t.blockInitialAnimation && (Q = !1), Q && (!(Y && ne) || se) && v.push(...me.map(le => ({ animation: le, options: { type: A } }))) } if (w.size) { const P = {}; w.forEach(A => { const N = t.getBaseTarget(A), F = t.getValue(A); F && (F.liveStyle = !0), P[A] = N ?? null }), v.push({ animation: P }) } let R = !!v.length; return s && (m.initial === !1 || m.initial === m.animate) && !t.manuallyAnimateOnMount && (R = !1), s = !1, R ? r(v) : Promise.resolve() } function h(p, m) { var y; if (i[p].isActive === m) return Promise.resolve(); (y = t.variantChildren) === null || y === void 0 || y.forEach(w => { var C; return (C = w.animationState) === null || C === void 0 ? void 0 : C.setActive(p, m) }), i[p].isActive = m; const v = u(p); for (const w in i) i[w].protectedKeys = {}; return v } return { animateChanges: u, setActive: h, setAnimateFunction: f, getState: () => i, reset: () => { i = gp(), s = !0 } } } function VS(t, r) { return typeof r == "string" ? r !== t : Array.isArray(r) ? !bm(r, t) : !1 } function Yn(t = !1) { return { isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function gp() { return { animate: Yn(!0), whileInView: Yn(), whileHover: Yn(), whileTap: Yn(), whileDrag: Yn(), whileFocus: Yn(), exit: Yn() } } class jn { constructor(r) { this.isMounted = !1, this.node = r } update() { } } class jS extends jn { constructor(r) { super(r), r.animationState || (r.animationState = FS(r)) } updateAnimationControlsSubscription() { const { animate: r } = this.node.getProps(); Us(r) && (this.unmountControls = r.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: r } = this.node.getProps(), { animate: i } = this.node.prevProps || {}; r !== i && this.updateAnimationControlsSubscription() } unmount() { var r; this.node.animationState.reset(), (r = this.unmountControls) === null || r === void 0 || r.call(this) } } let IS = 0; class BS extends jn { constructor() { super(...arguments), this.id = IS++ } update() { if (!this.node.presenceContext) return; const { isPresent: r, onExitComplete: i } = this.node.presenceContext, { isPresent: s } = this.node.prevPresenceContext || {}; if (!this.node.animationState || r === s) return; const l = this.node.animationState.setActive("exit", !r); i && !r && l.then(() => i(this.id)) } mount() { const { register: r } = this.node.presenceContext || {}; r && (this.unmount = r(this.id)) } unmount() { } } const zS = { animation: { Feature: jS }, exit: { Feature: BS } }, Dy = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1; function Hs(t, r = "page") { return { point: { x: t[`${r}X`], y: t[`${r}Y`] } } } const US = t => r => Dy(r) && t(r, Hs(r)); function nn(t, r, i, s = { passive: !0 }) { return t.addEventListener(r, i, s), () => t.removeEventListener(r, i) } function ln(t, r, i, s) { return nn(t, r, US(i), s) } const vp = (t, r) => Math.abs(t - r); function bS(t, r) { const i = vp(t.x, r.x), s = vp(t.y, r.y); return Math.sqrt(i ** 2 + s ** 2) } class _y { constructor(r, i, { transformPagePoint: s, contextWindow: l, dragSnapToOrigin: f = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const v = uu(this.lastMoveEventInfo, this.history), w = this.startEvent !== null, C = bS(v.offset, { x: 0, y: 0 }) >= 3; if (!w && !C) return; const { point: S } = v, { timestamp: R } = He; this.history.push({ ...S, timestamp: R }); const { onStart: P, onMove: A } = this.handlers; w || (P && P(this.lastMoveEvent, v), this.startEvent = this.lastMoveEvent), A && A(this.lastMoveEvent, v) }, this.handlePointerMove = (v, w) => { this.lastMoveEvent = v, this.lastMoveEventInfo = lu(w, this.transformPagePoint), ve.update(this.updatePoint, !0) }, this.handlePointerUp = (v, w) => { this.end(); const { onEnd: C, onSessionEnd: S, resumeAnimation: R } = this.handlers; if (this.dragSnapToOrigin && R && R(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const P = uu(v.type === "pointercancel" ? this.lastMoveEventInfo : lu(w, this.transformPagePoint), this.history); this.startEvent && C && C(v, P), S && S(v, P) }, !Dy(r)) return; this.dragSnapToOrigin = f, this.handlers = i, this.transformPagePoint = s, this.contextWindow = l || window; const u = Hs(r), h = lu(u, this.transformPagePoint), { point: p } = h, { timestamp: m } = He; this.history = [{ ...p, timestamp: m }]; const { onSessionStart: y } = i; y && y(r, uu(h, this.history)), this.removeListeners = an(ln(this.contextWindow, "pointermove", this.handlePointerMove), ln(this.contextWindow, "pointerup", this.handlePointerUp), ln(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(r) { this.handlers = r } end() { this.removeListeners && this.removeListeners(), Nn(this.updatePoint) } } function lu(t, r) { return r ? { point: r(t.point) } : t } function wp(t, r) { return { x: t.x - r.x, y: t.y - r.y } } function uu({ point: t }, r) { return { point: t, delta: wp(t, My(r)), offset: wp(t, $S(r)), velocity: HS(r, .1) } } function $S(t) { return t[0] } function My(t) { return t[t.length - 1] } function HS(t, r) { if (t.length < 2) return { x: 0, y: 0 }; let i = t.length - 1, s = null; const l = My(t); for (; i >= 0 && (s = t[i], !(l.timestamp - s.timestamp > on(r)));)i--; if (!s) return { x: 0, y: 0 }; const f = sn(l.timestamp - s.timestamp); if (f === 0) return { x: 0, y: 0 }; const u = { x: (l.x - s.x) / f, y: (l.y - s.y) / f }; return u.x === 1 / 0 && (u.x = 0), u.y === 1 / 0 && (u.y = 0), u } function Oy(t) { let r = null; return () => { const i = () => { r = null }; return r === null ? (r = t, i) : !1 } } const xp = Oy("dragHorizontal"), Sp = Oy("dragVertical"); function Ny(t) { let r = !1; if (t === "y") r = Sp(); else if (t === "x") r = xp(); else { const i = xp(), s = Sp(); i && s ? r = () => { i(), s() } : (i && i(), s && s()) } return r } function Fy() { const t = Ny(!0); return t ? (t(), !1) : !0 } function Nr(t) { return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current") } const Vy = 1e-4, WS = 1 - Vy, KS = 1 + Vy, jy = .01, qS = 0 - jy, GS = 0 + jy; function vt(t) { return t.max - t.min } function QS(t, r, i) { return Math.abs(t - r) <= i } function Ep(t, r, i, s = .5) { t.origin = s, t.originPoint = Ae(r.min, r.max, t.origin), t.scale = vt(i) / vt(r), t.translate = Ae(i.min, i.max, t.origin) - t.originPoint, (t.scale >= WS && t.scale <= KS || isNaN(t.scale)) && (t.scale = 1), (t.translate >= qS && t.translate <= GS || isNaN(t.translate)) && (t.translate = 0) } function zi(t, r, i, s) { Ep(t.x, r.x, i.x, s ? s.originX : void 0), Ep(t.y, r.y, i.y, s ? s.originY : void 0) } function Pp(t, r, i) { t.min = i.min + r.min, t.max = t.min + vt(r) } function XS(t, r, i) { Pp(t.x, r.x, i.x), Pp(t.y, r.y, i.y) } function Cp(t, r, i) { t.min = r.min - i.min, t.max = t.min + vt(r) } function Ui(t, r, i) { Cp(t.x, r.x, i.x), Cp(t.y, r.y, i.y) } function YS(t, { min: r, max: i }, s) { return r !== void 0 && t < r ? t = s ? Ae(r, t, s.min) : Math.max(t, r) : i !== void 0 && t > i && (t = s ? Ae(i, t, s.max) : Math.min(t, i)), t } function Tp(t, r, i) { return { min: r !== void 0 ? t.min + r : void 0, max: i !== void 0 ? t.max + i - (t.max - t.min) : void 0 } } function JS(t, { top: r, left: i, bottom: s, right: l }) { return { x: Tp(t.x, i, l), y: Tp(t.y, r, s) } } function kp(t, r) { let i = r.min - t.min, s = r.max - t.max; return r.max - r.min < t.max - t.min && ([i, s] = [s, i]), { min: i, max: s } } function ZS(t, r) { return { x: kp(t.x, r.x), y: kp(t.y, r.y) } } function eE(t, r) { let i = .5; const s = vt(t), l = vt(r); return l > s ? i = Br(r.min, r.max - s, t.min) : s > l && (i = Br(t.min, t.max - l, r.min)), un(0, 1, i) } function tE(t, r) { const i = {}; return r.min !== void 0 && (i.min = r.min - t.min), r.max !== void 0 && (i.max = r.max - t.min), i } const Nu = .35; function nE(t = Nu) { return t === !1 ? t = 0 : t === !0 && (t = Nu), { x: Rp(t, "left", "right"), y: Rp(t, "top", "bottom") } } function Rp(t, r, i) { return { min: Ap(t, r), max: Ap(t, i) } } function Ap(t, r) { return typeof t == "number" ? t : t[r] || 0 } const Lp = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Fr = () => ({ x: Lp(), y: Lp() }), Dp = () => ({ min: 0, max: 0 }), Oe = () => ({ x: Dp(), y: Dp() }); function kt(t) { return [t("x"), t("y")] } function Iy({ top: t, left: r, right: i, bottom: s }) { return { x: { min: r, max: i }, y: { min: t, max: s } } } function rE({ x: t, y: r }) { return { top: r.min, right: t.max, bottom: r.max, left: t.min } } function iE(t, r) { if (!r) return t; const i = r({ x: t.left, y: t.top }), s = r({ x: t.right, y: t.bottom }); return { top: i.y, left: i.x, bottom: s.y, right: s.x } } function cu(t) { return t === void 0 || t === 1 } function Fu({ scale: t, scaleX: r, scaleY: i }) { return !cu(t) || !cu(r) || !cu(i) } function Jn(t) { return Fu(t) || By(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY } function By(t) { return _p(t.x) || _p(t.y) } function _p(t) { return t && t !== "0%" } function Ns(t, r, i) { const s = t - i, l = r * s; return i + l } function Mp(t, r, i, s, l) { return l !== void 0 && (t = Ns(t, l, s)), Ns(t, i, s) + r } function Vu(t, r = 0, i = 1, s, l) { t.min = Mp(t.min, r, i, s, l), t.max = Mp(t.max, r, i, s, l) } function zy(t, { x: r, y: i }) { Vu(t.x, r.translate, r.scale, r.originPoint), Vu(t.y, i.translate, i.scale, i.originPoint) } const Op = .999999999999, Np = 1.0000000000001; function oE(t, r, i, s = !1) { const l = i.length; if (!l) return; r.x = r.y = 1; let f, u; for (let h = 0; h < l; h++) { f = i[h], u = f.projectionDelta; const { visualElement: p } = f.options; p && p.props.style && p.props.style.display === "contents" || (s && f.options.layoutScroll && f.scroll && f !== f.root && jr(t, { x: -f.scroll.offset.x, y: -f.scroll.offset.y }), u && (r.x *= u.x.scale, r.y *= u.y.scale, zy(t, u)), s && Jn(f.latestValues) && jr(t, f.latestValues)) } r.x < Np && r.x > Op && (r.x = 1), r.y < Np && r.y > Op && (r.y = 1) } function Vr(t, r) { t.min = t.min + r, t.max = t.max + r } function Fp(t, r, i, s, l = .5) { const f = Ae(t.min, t.max, l); Vu(t, r, i, f, s) } function jr(t, r) { Fp(t.x, r.x, r.scaleX, r.scale, r.originX), Fp(t.y, r.y, r.scaleY, r.scale, r.originY) } function Uy(t, r) { return Iy(iE(t.getBoundingClientRect(), r)) } function sE(t, r, i) { const s = Uy(t, i), { scroll: l } = r; return l && (Vr(s.x, l.offset.x), Vr(s.y, l.offset.y)), s } const by = ({ current: t }) => t ? t.ownerDocument.defaultView : null, aE = new WeakMap; class lE { constructor(r) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Oe(), this.visualElement = r } start(r, { snapToCursor: i = !1 } = {}) { const { presenceContext: s } = this.visualElement; if (s && s.isPresent === !1) return; const l = y => { const { dragSnapToOrigin: v } = this.getProps(); v ? this.pauseAnimation() : this.stopAnimation(), i && this.snapToCursor(Hs(y, "page").point) }, f = (y, v) => { const { drag: w, dragPropagation: C, onDragStart: S } = this.getProps(); if (w && !C && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = Ny(w), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), kt(P => { let A = this.getAxisMotionValue(P).get() || 0; if (Ht.test(A)) { const { projection: N } = this.visualElement; if (N && N.layout) { const F = N.layout.layoutBox[P]; F && (A = vt(F) * (parseFloat(A) / 100)) } } this.originPoint[P] = A }), S && ve.postRender(() => S(y, v)), Mu(this.visualElement, "transform"); const { animationState: R } = this.visualElement; R && R.setActive("whileDrag", !0) }, u = (y, v) => { const { dragPropagation: w, dragDirectionLock: C, onDirectionLock: S, onDrag: R } = this.getProps(); if (!w && !this.openGlobalLock) return; const { offset: P } = v; if (C && this.currentDirection === null) { this.currentDirection = uE(P), this.currentDirection !== null && S && S(this.currentDirection); return } this.updateAxis("x", v.point, P), this.updateAxis("y", v.point, P), this.visualElement.render(), R && R(y, v) }, h = (y, v) => this.stop(y, v), p = () => kt(y => { var v; return this.getAnimationState(y) === "paused" && ((v = this.getAxisMotionValue(y).animation) === null || v === void 0 ? void 0 : v.play()) }), { dragSnapToOrigin: m } = this.getProps(); this.panSession = new _y(r, { onSessionStart: l, onStart: f, onMove: u, onSessionEnd: h, resumeAnimation: p }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: m, contextWindow: by(this.visualElement) }) } stop(r, i) { const s = this.isDragging; if (this.cancel(), !s) return; const { velocity: l } = i; this.startAnimation(l); const { onDragEnd: f } = this.getProps(); f && ve.postRender(() => f(r, i)) } cancel() { this.isDragging = !1; const { projection: r, animationState: i } = this.visualElement; r && (r.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: s } = this.getProps(); !s && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), i && i.setActive("whileDrag", !1) } updateAxis(r, i, s) { const { drag: l } = this.getProps(); if (!s || !ys(r, l, this.currentDirection)) return; const f = this.getAxisMotionValue(r); let u = this.originPoint[r] + s[r]; this.constraints && this.constraints[r] && (u = YS(u, this.constraints[r], this.elastic[r])), f.set(u) } resolveConstraints() { var r; const { dragConstraints: i, dragElastic: s } = this.getProps(), l = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (r = this.visualElement.projection) === null || r === void 0 ? void 0 : r.layout, f = this.constraints; i && Nr(i) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : i && l ? this.constraints = JS(l.layoutBox, i) : this.constraints = !1, this.elastic = nE(s), f !== this.constraints && l && this.constraints && !this.hasMutatedConstraints && kt(u => { this.constraints !== !1 && this.getAxisMotionValue(u) && (this.constraints[u] = tE(l.layoutBox[u], this.constraints[u])) }) } resolveRefConstraints() { const { dragConstraints: r, onMeasureDragConstraints: i } = this.getProps(); if (!r || !Nr(r)) return !1; const s = r.current, { projection: l } = this.visualElement; if (!l || !l.layout) return !1; const f = sE(s, l.root, this.visualElement.getTransformPagePoint()); let u = ZS(l.layout.layoutBox, f); if (i) { const h = i(rE(u)); this.hasMutatedConstraints = !!h, h && (u = Iy(h)) } return u } startAnimation(r) { const { drag: i, dragMomentum: s, dragElastic: l, dragTransition: f, dragSnapToOrigin: u, onDragTransitionEnd: h } = this.getProps(), p = this.constraints || {}, m = kt(y => { if (!ys(y, i, this.currentDirection)) return; let v = p && p[y] || {}; u && (v = { min: 0, max: 0 }); const w = l ? 200 : 1e6, C = l ? 40 : 1e7, S = { type: "inertia", velocity: s ? r[y] : 0, bounceStiffness: w, bounceDamping: C, timeConstant: 750, restDelta: 1, restSpeed: 10, ...f, ...v }; return this.startAxisValueAnimation(y, S) }); return Promise.all(m).then(h) } startAxisValueAnimation(r, i) { const s = this.getAxisMotionValue(r); return Mu(this.visualElement, r), s.start(gc(r, s, 0, i, this.visualElement, !1)) } stopAnimation() { kt(r => this.getAxisMotionValue(r).stop()) } pauseAnimation() { kt(r => { var i; return (i = this.getAxisMotionValue(r).animation) === null || i === void 0 ? void 0 : i.pause() }) } getAnimationState(r) { var i; return (i = this.getAxisMotionValue(r).animation) === null || i === void 0 ? void 0 : i.state } getAxisMotionValue(r) { const i = `_drag${r.toUpperCase()}`, s = this.visualElement.getProps(), l = s[i]; return l || this.visualElement.getValue(r, (s.initial ? s.initial[r] : void 0) || 0) } snapToCursor(r) { kt(i => { const { drag: s } = this.getProps(); if (!ys(i, s, this.currentDirection)) return; const { projection: l } = this.visualElement, f = this.getAxisMotionValue(i); if (l && l.layout) { const { min: u, max: h } = l.layout.layoutBox[i]; f.set(r[i] - Ae(u, h, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: r, dragConstraints: i } = this.getProps(), { projection: s } = this.visualElement; if (!Nr(i) || !s || !this.constraints) return; this.stopAnimation(); const l = { x: 0, y: 0 }; kt(u => { const h = this.getAxisMotionValue(u); if (h && this.constraints !== !1) { const p = h.get(); l[u] = eE({ min: p, max: p }, this.constraints[u]) } }); const { transformTemplate: f } = this.visualElement.getProps(); this.visualElement.current.style.transform = f ? f({}, "") : "none", s.root && s.root.updateScroll(), s.updateLayout(), this.resolveConstraints(), kt(u => { if (!ys(u, r, null)) return; const h = this.getAxisMotionValue(u), { min: p, max: m } = this.constraints[u]; h.set(Ae(p, m, l[u])) }) } addListeners() { if (!this.visualElement.current) return; aE.set(this.visualElement, this); const r = this.visualElement.current, i = ln(r, "pointerdown", p => { const { drag: m, dragListener: y = !0 } = this.getProps(); m && y && this.start(p) }), s = () => { const { dragConstraints: p } = this.getProps(); Nr(p) && p.current && (this.constraints = this.resolveRefConstraints()) }, { projection: l } = this.visualElement, f = l.addEventListener("measure", s); l && !l.layout && (l.root && l.root.updateScroll(), l.updateLayout()), ve.read(s); const u = nn(window, "resize", () => this.scalePositionWithinConstraints()), h = l.addEventListener("didUpdate", ({ delta: p, hasLayoutChanged: m }) => { this.isDragging && m && (kt(y => { const v = this.getAxisMotionValue(y); v && (this.originPoint[y] += p[y].translate, v.set(v.get() + p[y].translate)) }), this.visualElement.render()) }); return () => { u(), i(), f(), h && h() } } getProps() { const r = this.visualElement.getProps(), { drag: i = !1, dragDirectionLock: s = !1, dragPropagation: l = !1, dragConstraints: f = !1, dragElastic: u = Nu, dragMomentum: h = !0 } = r; return { ...r, drag: i, dragDirectionLock: s, dragPropagation: l, dragConstraints: f, dragElastic: u, dragMomentum: h } } } function ys(t, r, i) { return (r === !0 || r === t) && (i === null || i === t) } function uE(t, r = 10) { let i = null; return Math.abs(t.y) > r ? i = "y" : Math.abs(t.x) > r && (i = "x"), i } class cE extends jn { constructor(r) { super(r), this.removeGroupControls = Je, this.removeListeners = Je, this.controls = new lE(r) } mount() { const { dragControls: r } = this.node.getProps(); r && (this.removeGroupControls = r.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Je } unmount() { this.removeGroupControls(), this.removeListeners() } } const Vp = t => (r, i) => { t && ve.postRender(() => t(r, i)) }; class fE extends jn { constructor() { super(...arguments), this.removePointerDownListener = Je } onPointerDown(r) { this.session = new _y(r, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: by(this.node) }) } createPanHandlers() { const { onPanSessionStart: r, onPanStart: i, onPan: s, onPanEnd: l } = this.node.getProps(); return { onSessionStart: Vp(r), onStart: Vp(i), onMove: s, onEnd: (f, u) => { delete this.session, l && ve.postRender(() => l(f, u)) } } } mount() { this.removePointerDownListener = ln(this.node.current, "pointerdown", r => this.onPointerDown(r)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const Ws = k.createContext(null); function dE() { const t = k.useContext(Ws); if (t === null) return [!0, null]; const { isPresent: r, onExitComplete: i, register: s } = t, l = k.useId(); k.useEffect(() => s(l), []); const f = k.useCallback(() => i && i(l), [l, i]); return !r && i ? [!1, f] : [!0] } const Ec = k.createContext({}), $y = k.createContext({}), Es = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function jp(t, r) { return r.max === r.min ? 0 : t / (r.max - r.min) * 100 } const Fi = { correct: (t, r) => { if (!r.target) return t; if (typeof t == "string") if (re.test(t)) t = parseFloat(t); else return t; const i = jp(t, r.target.x), s = jp(t, r.target.y); return `${i}% ${s}%` } }, hE = { correct: (t, { treeScale: r, projectionDelta: i }) => { const s = t, l = Fn.parse(t); if (l.length > 5) return s; const f = Fn.createTransformer(t), u = typeof l[0] != "number" ? 1 : 0, h = i.x.scale * r.x, p = i.y.scale * r.y; l[0 + u] /= h, l[1 + u] /= p; const m = Ae(h, p, .5); return typeof l[2 + u] == "number" && (l[2 + u] /= m), typeof l[3 + u] == "number" && (l[3 + u] /= m), f(l) } }, Fs = {}; function pE(t) { Object.assign(Fs, t) } const { schedule: Pc, cancel: $T } = $m(queueMicrotask, !1); class mE extends k.Component { componentDidMount() { const { visualElement: r, layoutGroup: i, switchLayoutGroup: s, layoutId: l } = this.props, { projection: f } = r; pE(yE), f && (i.group && i.group.add(f), s && s.register && l && s.register(f), f.root.didUpdate(), f.addEventListener("animationComplete", () => { this.safeToRemove() }), f.setOptions({ ...f.options, onExitComplete: () => this.safeToRemove() })), Es.hasEverUpdated = !0 } getSnapshotBeforeUpdate(r) { const { layoutDependency: i, visualElement: s, drag: l, isPresent: f } = this.props, u = s.projection; return u && (u.isPresent = f, l || r.layoutDependency !== i || i === void 0 ? u.willUpdate() : this.safeToRemove(), r.isPresent !== f && (f ? u.promote() : u.relegate() || ve.postRender(() => { const h = u.getStack(); (!h || !h.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: r } = this.props.visualElement; r && (r.root.didUpdate(), Pc.postRender(() => { !r.currentAnimation && r.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: r, layoutGroup: i, switchLayoutGroup: s } = this.props, { projection: l } = r; l && (l.scheduleCheckAfterUnmount(), i && i.group && i.group.remove(l), s && s.deregister && s.deregister(l)) } safeToRemove() { const { safeToRemove: r } = this.props; r && r() } render() { return null } } function Hy(t) { const [r, i] = dE(), s = k.useContext(Ec); return H.jsx(mE, { ...t, layoutGroup: s, switchLayoutGroup: k.useContext($y), isPresent: r, safeToRemove: i }) } const yE = { borderRadius: { ...Fi, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: Fi, borderTopRightRadius: Fi, borderBottomLeftRadius: Fi, borderBottomRightRadius: Fi, boxShadow: hE }, Wy = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], gE = Wy.length, Ip = t => typeof t == "string" ? parseFloat(t) : t, Bp = t => typeof t == "number" || re.test(t); function vE(t, r, i, s, l, f) { l ? (t.opacity = Ae(0, i.opacity !== void 0 ? i.opacity : 1, wE(s)), t.opacityExit = Ae(r.opacity !== void 0 ? r.opacity : 1, 0, xE(s))) : f && (t.opacity = Ae(r.opacity !== void 0 ? r.opacity : 1, i.opacity !== void 0 ? i.opacity : 1, s)); for (let u = 0; u < gE; u++) { const h = `border${Wy[u]}Radius`; let p = zp(r, h), m = zp(i, h); if (p === void 0 && m === void 0) continue; p || (p = 0), m || (m = 0), p === 0 || m === 0 || Bp(p) === Bp(m) ? (t[h] = Math.max(Ae(Ip(p), Ip(m), s), 0), (Ht.test(m) || Ht.test(p)) && (t[h] += "%")) : t[h] = m } (r.rotate || i.rotate) && (t.rotate = Ae(r.rotate || 0, i.rotate || 0, s)) } function zp(t, r) { return t[r] !== void 0 ? t[r] : t.borderRadius } const wE = Ky(0, .5, Xm), xE = Ky(.5, .95, Je); function Ky(t, r, i) { return s => s < t ? 0 : s > r ? 1 : i(Br(t, r, s)) } function Up(t, r) { t.min = r.min, t.max = r.max } function Tt(t, r) { Up(t.x, r.x), Up(t.y, r.y) } function bp(t, r) { t.translate = r.translate, t.scale = r.scale, t.originPoint = r.originPoint, t.origin = r.origin } function $p(t, r, i, s, l) { return t -= r, t = Ns(t, 1 / i, s), l !== void 0 && (t = Ns(t, 1 / l, s)), t } function SE(t, r = 0, i = 1, s = .5, l, f = t, u = t) { if (Ht.test(r) && (r = parseFloat(r), r = Ae(u.min, u.max, r / 100) - u.min), typeof r != "number") return; let h = Ae(f.min, f.max, s); t === f && (h -= r), t.min = $p(t.min, r, i, h, l), t.max = $p(t.max, r, i, h, l) } function Hp(t, r, [i, s, l], f, u) { SE(t, r[i], r[s], r[l], r.scale, f, u) } const EE = ["x", "scaleX", "originX"], PE = ["y", "scaleY", "originY"]; function Wp(t, r, i, s) { Hp(t.x, r, EE, i ? i.x : void 0, s ? s.x : void 0), Hp(t.y, r, PE, i ? i.y : void 0, s ? s.y : void 0) } function Kp(t) { return t.translate === 0 && t.scale === 1 } function qy(t) { return Kp(t.x) && Kp(t.y) } function qp(t, r) { return t.min === r.min && t.max === r.max } function CE(t, r) { return qp(t.x, r.x) && qp(t.y, r.y) } function Gp(t, r) { return Math.round(t.min) === Math.round(r.min) && Math.round(t.max) === Math.round(r.max) } function Gy(t, r) { return Gp(t.x, r.x) && Gp(t.y, r.y) } function Qp(t) { return vt(t.x) / vt(t.y) } function Xp(t, r) { return t.translate === r.translate && t.scale === r.scale && t.originPoint === r.originPoint } class TE { constructor() { this.members = [] } add(r) { vc(this.members, r), r.scheduleRender() } remove(r) { if (wc(this.members, r), r === this.prevLead && (this.prevLead = void 0), r === this.lead) { const i = this.members[this.members.length - 1]; i && this.promote(i) } } relegate(r) { const i = this.members.findIndex(l => r === l); if (i === 0) return !1; let s; for (let l = i; l >= 0; l--) { const f = this.members[l]; if (f.isPresent !== !1) { s = f; break } } return s ? (this.promote(s), !0) : !1 } promote(r, i) { const s = this.lead; if (r !== s && (this.prevLead = s, this.lead = r, r.show(), s)) { s.instance && s.scheduleRender(), r.scheduleRender(), r.resumeFrom = s, i && (r.resumeFrom.preserveOpacity = !0), s.snapshot && (r.snapshot = s.snapshot, r.snapshot.latestValues = s.animationValues || s.latestValues), r.root && r.root.isUpdating && (r.isLayoutDirty = !0); const { crossfade: l } = r.options; l === !1 && s.hide() } } exitAnimationComplete() { this.members.forEach(r => { const { options: i, resumingFrom: s } = r; i.onExitComplete && i.onExitComplete(), s && s.options.onExitComplete && s.options.onExitComplete() }) } scheduleRender() { this.members.forEach(r => { r.instance && r.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function kE(t, r, i) { let s = ""; const l = t.x.translate / r.x, f = t.y.translate / r.y, u = (i == null ? void 0 : i.z) || 0; if ((l || f || u) && (s = `translate3d(${l}px, ${f}px, ${u}px) `), (r.x !== 1 || r.y !== 1) && (s += `scale(${1 / r.x}, ${1 / r.y}) `), i) { const { transformPerspective: m, rotate: y, rotateX: v, rotateY: w, skewX: C, skewY: S } = i; m && (s = `perspective(${m}px) ${s}`), y && (s += `rotate(${y}deg) `), v && (s += `rotateX(${v}deg) `), w && (s += `rotateY(${w}deg) `), C && (s += `skewX(${C}deg) `), S && (s += `skewY(${S}deg) `) } const h = t.x.scale * r.x, p = t.y.scale * r.y; return (h !== 1 || p !== 1) && (s += `scale(${h}, ${p})`), s || "none" } const RE = (t, r) => t.depth - r.depth; class AE { constructor() { this.children = [], this.isDirty = !1 } add(r) { vc(this.children, r), this.isDirty = !0 } remove(r) { wc(this.children, r), this.isDirty = !0 } forEach(r) { this.isDirty && this.children.sort(RE), this.isDirty = !1, this.children.forEach(r) } } function Ps(t) { const r = Ye(t) ? t.get() : t; return wS(r) ? r.toValue() : r } function LE(t, r) { const i = Wt.now(), s = ({ timestamp: l }) => { const f = l - i; f >= r && (Nn(s), t(f - r)) }; return ve.read(s, !0), () => Nn(s) } function DE(t) { return t instanceof SVGElement && t.tagName !== "svg" } function _E(t, r, i) { const s = Ye(t) ? t : Ki(t); return s.start(gc("", s, r, i)), s.animation } const Zn = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }, Ii = typeof window < "u" && window.MotionDebug !== void 0, fu = ["", "X", "Y", "Z"], ME = { visibility: "hidden" }, Yp = 1e3; let OE = 0; function du(t, r, i, s) { const { latestValues: l } = r; l[t] && (i[t] = l[t], r.setStaticValue(t, 0), s && (s[t] = 0)) } function Qy(t) { if (t.hasCheckedOptimisedAppear = !0, t.root === t) return; const { visualElement: r } = t.options; if (!r) return; const i = Ry(r); if (window.MotionHasOptimisedAnimation(i, "transform")) { const { layout: l, layoutId: f } = t.options; window.MotionCancelOptimisedAnimation(i, "transform", ve, !(l || f)) } const { parent: s } = t; s && !s.hasCheckedOptimisedAppear && Qy(s) } function Xy({ attachResizeListener: t, defaultParent: r, measureScroll: i, checkIsScrollRoot: s, resetTransform: l }) { return class { constructor(u = {}, h = r == null ? void 0 : r()) { this.id = OE++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, Ii && (Zn.totalNodes = Zn.resolvedTargetDeltas = Zn.recalculatedProjection = 0), this.nodes.forEach(VE), this.nodes.forEach(UE), this.nodes.forEach(bE), this.nodes.forEach(jE), Ii && window.MotionDebug.record(Zn) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = u, this.root = h ? h.root || h : this, this.path = h ? [...h.path, h] : [], this.parent = h, this.depth = h ? h.depth + 1 : 0; for (let p = 0; p < this.path.length; p++)this.path[p].shouldResetTransform = !0; this.root === this && (this.nodes = new AE) } addEventListener(u, h) { return this.eventHandlers.has(u) || this.eventHandlers.set(u, new xc), this.eventHandlers.get(u).add(h) } notifyListeners(u, ...h) { const p = this.eventHandlers.get(u); p && p.notify(...h) } hasListeners(u) { return this.eventHandlers.has(u) } mount(u, h = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = DE(u), this.instance = u; const { layoutId: p, layout: m, visualElement: y } = this.options; if (y && !y.current && y.mount(u), this.root.nodes.add(this), this.parent && this.parent.children.add(this), h && (m || p) && (this.isLayoutDirty = !0), t) { let v; const w = () => this.root.updateBlockedByResize = !1; t(u, () => { this.root.updateBlockedByResize = !0, v && v(), v = LE(w, 250), Es.hasAnimatedSinceResize && (Es.hasAnimatedSinceResize = !1, this.nodes.forEach(Zp)) }) } p && this.root.registerSharedNode(p, this), this.options.animate !== !1 && y && (p || m) && this.addEventListener("didUpdate", ({ delta: v, hasLayoutChanged: w, hasRelativeTargetChanged: C, layout: S }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const R = this.options.transition || y.getDefaultTransition() || qE, { onLayoutAnimationStart: P, onLayoutAnimationComplete: A } = y.getProps(), N = !this.targetLayout || !Gy(this.targetLayout, S) || C, F = !w && C; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || F || w && (N || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(v, F); const b = { ...rc(R, "layout"), onPlay: P, onComplete: A }; (y.shouldReduceMotion || this.options.layoutRoot) && (b.delay = 0, b.type = !1), this.startAnimation(b) } else w || Zp(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = S }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const u = this.getStack(); u && u.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Nn(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach($E), this.animationId++) } getTransformTemplate() { const { visualElement: u } = this.options; return u && u.getProps().transformTemplate } willUpdate(u = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && Qy(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let y = 0; y < this.path.length; y++) { const v = this.path[y]; v.shouldResetTransform = !0, v.updateScroll("snapshot"), v.options.layoutRoot && v.willUpdate(!1) } const { layoutId: h, layout: p } = this.options; if (h === void 0 && !p) return; const m = this.getTransformTemplate(); this.prevTransformTemplateValue = m ? m(this.latestValues, "") : void 0, this.updateSnapshot(), u && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Jp); return } this.isUpdating || this.nodes.forEach(BE), this.isUpdating = !1, this.nodes.forEach(zE), this.nodes.forEach(NE), this.nodes.forEach(FE), this.clearAllSnapshots(); const h = Wt.now(); He.delta = un(0, 1e3 / 60, h - He.timestamp), He.timestamp = h, He.isProcessing = !0, ru.update.process(He), ru.preRender.process(He), ru.render.process(He), He.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Pc.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(IE), this.sharedNodes.forEach(HE) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, ve.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { ve.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let p = 0; p < this.path.length; p++)this.path[p].updateScroll(); const u = this.layout; this.layout = this.measure(!1), this.layoutCorrected = Oe(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: h } = this.options; h && h.notify("LayoutMeasure", this.layout.layoutBox, u ? u.layoutBox : void 0) } updateScroll(u = "measure") { let h = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === u && (h = !1), h) { const p = s(this.instance); this.scroll = { animationId: this.root.animationId, phase: u, isRoot: p, offset: i(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : p } } } resetTransform() { if (!l) return; const u = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, h = this.projectionDelta && !qy(this.projectionDelta), p = this.getTransformTemplate(), m = p ? p(this.latestValues, "") : void 0, y = m !== this.prevTransformTemplateValue; u && (h || Jn(this.latestValues) || y) && (l(this.instance, m), this.shouldResetTransform = !1, this.scheduleRender()) } measure(u = !0) { const h = this.measurePageBox(); let p = this.removeElementScroll(h); return u && (p = this.removeTransform(p)), GE(p), { animationId: this.root.animationId, measuredBox: h, layoutBox: p, latestValues: {}, source: this.id } } measurePageBox() { var u; const { visualElement: h } = this.options; if (!h) return Oe(); const p = h.measureViewportBox(); if (!(((u = this.scroll) === null || u === void 0 ? void 0 : u.wasRoot) || this.path.some(QE))) { const { scroll: y } = this.root; y && (Vr(p.x, y.offset.x), Vr(p.y, y.offset.y)) } return p } removeElementScroll(u) { var h; const p = Oe(); if (Tt(p, u), !((h = this.scroll) === null || h === void 0) && h.wasRoot) return p; for (let m = 0; m < this.path.length; m++) { const y = this.path[m], { scroll: v, options: w } = y; y !== this.root && v && w.layoutScroll && (v.wasRoot && Tt(p, u), Vr(p.x, v.offset.x), Vr(p.y, v.offset.y)) } return p } applyTransform(u, h = !1) { const p = Oe(); Tt(p, u); for (let m = 0; m < this.path.length; m++) { const y = this.path[m]; !h && y.options.layoutScroll && y.scroll && y !== y.root && jr(p, { x: -y.scroll.offset.x, y: -y.scroll.offset.y }), Jn(y.latestValues) && jr(p, y.latestValues) } return Jn(this.latestValues) && jr(p, this.latestValues), p } removeTransform(u) { const h = Oe(); Tt(h, u); for (let p = 0; p < this.path.length; p++) { const m = this.path[p]; if (!m.instance || !Jn(m.latestValues)) continue; Fu(m.latestValues) && m.updateSnapshot(); const y = Oe(), v = m.measurePageBox(); Tt(y, v), Wp(h, m.latestValues, m.snapshot ? m.snapshot.layoutBox : void 0, y) } return Jn(this.latestValues) && Wp(h, this.latestValues), h } setTargetDelta(u) { this.targetDelta = u, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(u) { this.options = { ...this.options, ...u, crossfade: u.crossfade !== void 0 ? u.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== He.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(u = !1) { var h; const p = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = p.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = p.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = p.isSharedProjectionDirty); const m = !!this.resumingFrom || this !== p; if (!(u || m && this.isSharedProjectionDirty || this.isProjectionDirty || !((h = this.parent) === null || h === void 0) && h.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: v, layoutId: w } = this.options; if (!(!this.layout || !(v || w))) { if (this.resolvedRelativeTargetAt = He.timestamp, !this.targetDelta && !this.relativeTarget) { const C = this.getClosestProjectingParent(); C && C.layout && this.animationProgress !== 1 ? (this.relativeParent = C, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Oe(), this.relativeTargetOrigin = Oe(), Ui(this.relativeTargetOrigin, this.layout.layoutBox, C.layout.layoutBox), Tt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = Oe(), this.targetWithTransforms = Oe()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), XS(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Tt(this.target, this.layout.layoutBox), zy(this.target, this.targetDelta)) : Tt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const C = this.getClosestProjectingParent(); C && !!C.resumingFrom == !!this.resumingFrom && !C.options.layoutScroll && C.target && this.animationProgress !== 1 ? (this.relativeParent = C, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Oe(), this.relativeTargetOrigin = Oe(), Ui(this.relativeTargetOrigin, this.target, C.target), Tt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } Ii && Zn.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || Fu(this.parent.latestValues) || By(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var u; const h = this.getLead(), p = !!this.resumingFrom || this !== h; let m = !0; if ((this.isProjectionDirty || !((u = this.parent) === null || u === void 0) && u.isProjectionDirty) && (m = !1), p && (this.isSharedProjectionDirty || this.isTransformDirty) && (m = !1), this.resolvedRelativeTargetAt === He.timestamp && (m = !1), m) return; const { layout: y, layoutId: v } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(y || v)) return; Tt(this.layoutCorrected, this.layout.layoutBox); const w = this.treeScale.x, C = this.treeScale.y; oE(this.layoutCorrected, this.treeScale, this.path, p), h.layout && !h.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (h.target = h.layout.layoutBox, h.targetWithTransforms = Oe()); const { target: S } = h; if (!S) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (bp(this.prevProjectionDelta.x, this.projectionDelta.x), bp(this.prevProjectionDelta.y, this.projectionDelta.y)), zi(this.projectionDelta, this.layoutCorrected, S, this.latestValues), (this.treeScale.x !== w || this.treeScale.y !== C || !Xp(this.projectionDelta.x, this.prevProjectionDelta.x) || !Xp(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", S)), Ii && Zn.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(u = !0) { var h; if ((h = this.options.visualElement) === null || h === void 0 || h.scheduleRender(), u) { const p = this.getStack(); p && p.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = Fr(), this.projectionDelta = Fr(), this.projectionDeltaWithTransform = Fr() } setAnimationOrigin(u, h = !1) { const p = this.snapshot, m = p ? p.latestValues : {}, y = { ...this.latestValues }, v = Fr(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !h; const w = Oe(), C = p ? p.source : void 0, S = this.layout ? this.layout.source : void 0, R = C !== S, P = this.getStack(), A = !P || P.members.length <= 1, N = !!(R && !A && this.options.crossfade === !0 && !this.path.some(KE)); this.animationProgress = 0; let F; this.mixTargetDelta = b => { const z = b / 1e3; em(v.x, u.x, z), em(v.y, u.y, z), this.setTargetDelta(v), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Ui(w, this.layout.layoutBox, this.relativeParent.layout.layoutBox), WE(this.relativeTarget, this.relativeTargetOrigin, w, z), F && CE(this.relativeTarget, F) && (this.isProjectionDirty = !1), F || (F = Oe()), Tt(F, this.relativeTarget)), R && (this.animationValues = y, vE(y, m, this.latestValues, z, N, A)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = z }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(u) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Nn(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = ve.update(() => { Es.hasAnimatedSinceResize = !0, this.currentAnimation = _E(0, Yp, { ...u, onUpdate: h => { this.mixTargetDelta(h), u.onUpdate && u.onUpdate(h) }, onComplete: () => { u.onComplete && u.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const u = this.getStack(); u && u.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Yp), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const u = this.getLead(); let { targetWithTransforms: h, target: p, layout: m, latestValues: y } = u; if (!(!h || !p || !m)) { if (this !== u && this.layout && m && Yy(this.options.animationType, this.layout.layoutBox, m.layoutBox)) { p = this.target || Oe(); const v = vt(this.layout.layoutBox.x); p.x.min = u.target.x.min, p.x.max = p.x.min + v; const w = vt(this.layout.layoutBox.y); p.y.min = u.target.y.min, p.y.max = p.y.min + w } Tt(h, p), jr(h, y), zi(this.projectionDeltaWithTransform, this.layoutCorrected, h, y) } } registerSharedNode(u, h) { this.sharedNodes.has(u) || this.sharedNodes.set(u, new TE), this.sharedNodes.get(u).add(h); const m = h.options.initialPromotionConfig; h.promote({ transition: m ? m.transition : void 0, preserveFollowOpacity: m && m.shouldPreserveFollowOpacity ? m.shouldPreserveFollowOpacity(h) : void 0 }) } isLead() { const u = this.getStack(); return u ? u.lead === this : !0 } getLead() { var u; const { layoutId: h } = this.options; return h ? ((u = this.getStack()) === null || u === void 0 ? void 0 : u.lead) || this : this } getPrevLead() { var u; const { layoutId: h } = this.options; return h ? (u = this.getStack()) === null || u === void 0 ? void 0 : u.prevLead : void 0 } getStack() { const { layoutId: u } = this.options; if (u) return this.root.sharedNodes.get(u) } promote({ needsReset: u, transition: h, preserveFollowOpacity: p } = {}) { const m = this.getStack(); m && m.promote(this, p), u && (this.projectionDelta = void 0, this.needsReset = !0), h && this.setOptions({ transition: h }) } relegate() { const u = this.getStack(); return u ? u.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: u } = this.options; if (!u) return; let h = !1; const { latestValues: p } = u; if ((p.z || p.rotate || p.rotateX || p.rotateY || p.rotateZ || p.skewX || p.skewY) && (h = !0), !h) return; const m = {}; p.z && du("z", u, m, this.animationValues); for (let y = 0; y < fu.length; y++)du(`rotate${fu[y]}`, u, m, this.animationValues), du(`skew${fu[y]}`, u, m, this.animationValues); u.render(); for (const y in m) u.setStaticValue(y, m[y]), this.animationValues && (this.animationValues[y] = m[y]); u.scheduleRender() } getProjectionStyles(u) { var h, p; if (!this.instance || this.isSVG) return; if (!this.isVisible) return ME; const m = { visibility: "" }, y = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, m.opacity = "", m.pointerEvents = Ps(u == null ? void 0 : u.pointerEvents) || "", m.transform = y ? y(this.latestValues, "") : "none", m; const v = this.getLead(); if (!this.projectionDelta || !this.layout || !v.target) { const R = {}; return this.options.layoutId && (R.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, R.pointerEvents = Ps(u == null ? void 0 : u.pointerEvents) || ""), this.hasProjected && !Jn(this.latestValues) && (R.transform = y ? y({}, "") : "none", this.hasProjected = !1), R } const w = v.animationValues || v.latestValues; this.applyTransformsToTarget(), m.transform = kE(this.projectionDeltaWithTransform, this.treeScale, w), y && (m.transform = y(w, m.transform)); const { x: C, y: S } = this.projectionDelta; m.transformOrigin = `${C.origin * 100}% ${S.origin * 100}% 0`, v.animationValues ? m.opacity = v === this ? (p = (h = w.opacity) !== null && h !== void 0 ? h : this.latestValues.opacity) !== null && p !== void 0 ? p : 1 : this.preserveOpacity ? this.latestValues.opacity : w.opacityExit : m.opacity = v === this ? w.opacity !== void 0 ? w.opacity : "" : w.opacityExit !== void 0 ? w.opacityExit : 0; for (const R in Fs) { if (w[R] === void 0) continue; const { correct: P, applyTo: A } = Fs[R], N = m.transform === "none" ? w[R] : P(w[R], v); if (A) { const F = A.length; for (let b = 0; b < F; b++)m[A[b]] = N } else m[R] = N } return this.options.layoutId && (m.pointerEvents = v === this ? Ps(u == null ? void 0 : u.pointerEvents) || "" : "none"), m } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(u => { var h; return (h = u.currentAnimation) === null || h === void 0 ? void 0 : h.stop() }), this.root.nodes.forEach(Jp), this.root.sharedNodes.clear() } } } function NE(t) { t.updateLayout() } function FE(t) { var r; const i = ((r = t.resumeFrom) === null || r === void 0 ? void 0 : r.snapshot) || t.snapshot; if (t.isLead() && t.layout && i && t.hasListeners("didUpdate")) { const { layoutBox: s, measuredBox: l } = t.layout, { animationType: f } = t.options, u = i.source !== t.layout.source; f === "size" ? kt(v => { const w = u ? i.measuredBox[v] : i.layoutBox[v], C = vt(w); w.min = s[v].min, w.max = w.min + C }) : Yy(f, i.layoutBox, s) && kt(v => { const w = u ? i.measuredBox[v] : i.layoutBox[v], C = vt(s[v]); w.max = w.min + C, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[v].max = t.relativeTarget[v].min + C) }); const h = Fr(); zi(h, s, i.layoutBox); const p = Fr(); u ? zi(p, t.applyTransform(l, !0), i.measuredBox) : zi(p, s, i.layoutBox); const m = !qy(h); let y = !1; if (!t.resumeFrom) { const v = t.getClosestProjectingParent(); if (v && !v.resumeFrom) { const { snapshot: w, layout: C } = v; if (w && C) { const S = Oe(); Ui(S, i.layoutBox, w.layoutBox); const R = Oe(); Ui(R, s, C.layoutBox), Gy(S, R) || (y = !0), v.options.layoutRoot && (t.relativeTarget = R, t.relativeTargetOrigin = S, t.relativeParent = v) } } } t.notifyListeners("didUpdate", { layout: s, snapshot: i, delta: p, layoutDelta: h, hasLayoutChanged: m, hasRelativeTargetChanged: y }) } else if (t.isLead()) { const { onExitComplete: s } = t.options; s && s() } t.options.transition = void 0 } function VE(t) { Ii && Zn.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty)) } function jE(t) { t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1 } function IE(t) { t.clearSnapshot() } function Jp(t) { t.clearMeasurements() } function BE(t) { t.isLayoutDirty = !1 } function zE(t) { const { visualElement: r } = t.options; r && r.getProps().onBeforeLayoutMeasure && r.notify("BeforeLayoutMeasure"), t.resetTransform() } function Zp(t) { t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0 } function UE(t) { t.resolveTargetDelta() } function bE(t) { t.calcProjection() } function $E(t) { t.resetSkewAndRotation() } function HE(t) { t.removeLeadSnapshot() } function em(t, r, i) { t.translate = Ae(r.translate, 0, i), t.scale = Ae(r.scale, 1, i), t.origin = r.origin, t.originPoint = r.originPoint } function tm(t, r, i, s) { t.min = Ae(r.min, i.min, s), t.max = Ae(r.max, i.max, s) } function WE(t, r, i, s) { tm(t.x, r.x, i.x, s), tm(t.y, r.y, i.y, s) } function KE(t) { return t.animationValues && t.animationValues.opacityExit !== void 0 } const qE = { duration: .45, ease: [.4, 0, .1, 1] }, nm = t => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), rm = nm("applewebkit/") && !nm("chrome/") ? Math.round : Je; function im(t) { t.min = rm(t.min), t.max = rm(t.max) } function GE(t) { im(t.x), im(t.y) } function Yy(t, r, i) { return t === "position" || t === "preserve-aspect" && !QS(Qp(r), Qp(i), .2) } function QE(t) { var r; return t !== t.root && ((r = t.scroll) === null || r === void 0 ? void 0 : r.wasRoot) } const XE = Xy({ attachResizeListener: (t, r) => nn(t, "resize", r), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), hu = { current: void 0 }, Jy = Xy({ measureScroll: t => ({ x: t.scrollLeft, y: t.scrollTop }), defaultParent: () => { if (!hu.current) { const t = new XE({}); t.mount(window), t.setOptions({ layoutScroll: !0 }), hu.current = t } return hu.current }, resetTransform: (t, r) => { t.style.transform = r !== void 0 ? r : "none" }, checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed" }), YE = { pan: { Feature: fE }, drag: { Feature: cE, ProjectionNode: Jy, MeasureLayout: Hy } }; function om(t, r) { const i = r ? "pointerenter" : "pointerleave", s = r ? "onHoverStart" : "onHoverEnd", l = (f, u) => { if (f.pointerType === "touch" || Fy()) return; const h = t.getProps(); t.animationState && h.whileHover && t.animationState.setActive("whileHover", r); const p = h[s]; p && ve.postRender(() => p(f, u)) }; return ln(t.current, i, l, { passive: !t.getProps()[s] }) } class JE extends jn { mount() { this.unmount = an(om(this.node, !0), om(this.node, !1)) } unmount() { } } class ZE extends jn { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let r = !1; try { r = this.node.current.matches(":focus-visible") } catch { r = !0 } !r || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = an(nn(this.node.current, "focus", () => this.onFocus()), nn(this.node.current, "blur", () => this.onBlur())) } unmount() { } } const Zy = (t, r) => r ? t === r ? !0 : Zy(t, r.parentElement) : !1; function pu(t, r) { if (!r) return; const i = new PointerEvent("pointer" + t); r(i, Hs(i)) } class eP extends jn { constructor() { super(...arguments), this.removeStartListeners = Je, this.removeEndListeners = Je, this.removeAccessibleListeners = Je, this.startPointerPress = (r, i) => { if (this.isPressing) return; this.removeEndListeners(); const s = this.node.getProps(), f = ln(window, "pointerup", (h, p) => { if (!this.checkPressEnd()) return; const { onTap: m, onTapCancel: y, globalTapTarget: v } = this.node.getProps(), w = !v && !Zy(this.node.current, h.target) ? y : m; w && ve.update(() => w(h, p)) }, { passive: !(s.onTap || s.onPointerUp) }), u = ln(window, "pointercancel", (h, p) => this.cancelPress(h, p), { passive: !(s.onTapCancel || s.onPointerCancel) }); this.removeEndListeners = an(f, u), this.startPress(r, i) }, this.startAccessiblePress = () => { const r = f => { if (f.key !== "Enter" || this.isPressing) return; const u = h => { h.key !== "Enter" || !this.checkPressEnd() || pu("up", (p, m) => { const { onTap: y } = this.node.getProps(); y && ve.postRender(() => y(p, m)) }) }; this.removeEndListeners(), this.removeEndListeners = nn(this.node.current, "keyup", u), pu("down", (h, p) => { this.startPress(h, p) }) }, i = nn(this.node.current, "keydown", r), s = () => { this.isPressing && pu("cancel", (f, u) => this.cancelPress(f, u)) }, l = nn(this.node.current, "blur", s); this.removeAccessibleListeners = an(i, l) } } startPress(r, i) { this.isPressing = !0; const { onTapStart: s, whileTap: l } = this.node.getProps(); l && this.node.animationState && this.node.animationState.setActive("whileTap", !0), s && ve.postRender(() => s(r, i)) } checkPressEnd() { return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !Fy() } cancelPress(r, i) { if (!this.checkPressEnd()) return; const { onTapCancel: s } = this.node.getProps(); s && ve.postRender(() => s(r, i)) } mount() { const r = this.node.getProps(), i = ln(r.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(r.onTapStart || r.onPointerStart) }), s = nn(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = an(i, s) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } } const ju = new WeakMap, mu = new WeakMap, tP = t => { const r = ju.get(t.target); r && r(t) }, nP = t => { t.forEach(tP) }; function rP({ root: t, ...r }) { const i = t || document; mu.has(i) || mu.set(i, {}); const s = mu.get(i), l = JSON.stringify(r); return s[l] || (s[l] = new IntersectionObserver(nP, { root: t, ...r })), s[l] } function iP(t, r, i) { const s = rP(r); return ju.set(t, i), s.observe(t), () => { ju.delete(t), s.unobserve(t) } } const oP = { some: 0, all: 1 }; class sP extends jn { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: r = {} } = this.node.getProps(), { root: i, margin: s, amount: l = "some", once: f } = r, u = { root: i ? i.current : void 0, rootMargin: s, threshold: typeof l == "number" ? l : oP[l] }, h = p => { const { isIntersecting: m } = p; if (this.isInView === m || (this.isInView = m, f && !m && this.hasEnteredView)) return; m && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", m); const { onViewportEnter: y, onViewportLeave: v } = this.node.getProps(), w = m ? y : v; w && w(p) }; return iP(this.node.current, u, h) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: r, prevProps: i } = this.node;["amount", "margin", "root"].some(aP(r, i)) && this.startObserver() } unmount() { } } function aP({ viewport: t = {} }, { viewport: r = {} } = {}) { return i => t[i] !== r[i] } const lP = { inView: { Feature: sP }, tap: { Feature: eP }, focus: { Feature: ZE }, hover: { Feature: JE } }, uP = { layout: { ProjectionNode: Jy, MeasureLayout: Hy } }, Cc = k.createContext({ transformPagePoint: t => t, isStatic: !1, reducedMotion: "never" }), Ks = k.createContext({}), Tc = typeof window < "u", eg = Tc ? k.useLayoutEffect : k.useEffect, tg = k.createContext({ strict: !1 }); function cP(t, r, i, s, l) { var f, u; const { visualElement: h } = k.useContext(Ks), p = k.useContext(tg), m = k.useContext(Ws), y = k.useContext(Cc).reducedMotion, v = k.useRef(); s = s || p.renderer, !v.current && s && (v.current = s(t, { visualState: r, parent: h, props: i, presenceContext: m, blockInitialAnimation: m ? m.initial === !1 : !1, reducedMotionConfig: y })); const w = v.current, C = k.useContext($y); w && !w.projection && l && (w.type === "html" || w.type === "svg") && fP(v.current, i, l, C); const S = k.useRef(!1); k.useInsertionEffect(() => { w && S.current && w.update(i, m) }); const R = i[ky], P = k.useRef(!!R && !(!((f = window.MotionHandoffIsComplete) === null || f === void 0) && f.call(window, R)) && ((u = window.MotionHasOptimisedAnimation) === null || u === void 0 ? void 0 : u.call(window, R))); return eg(() => { w && (S.current = !0, window.MotionIsMounted = !0, w.updateFeatures(), Pc.render(w.render), P.current && w.animationState && w.animationState.animateChanges()) }), k.useEffect(() => { w && (!P.current && w.animationState && w.animationState.animateChanges(), P.current && (queueMicrotask(() => { var A; (A = window.MotionHandoffMarkAsComplete) === null || A === void 0 || A.call(window, R) }), P.current = !1)) }), w } function fP(t, r, i, s) { const { layoutId: l, layout: f, drag: u, dragConstraints: h, layoutScroll: p, layoutRoot: m } = r; t.projection = new i(t.latestValues, r["data-framer-portal-id"] ? void 0 : ng(t.parent)), t.projection.setOptions({ layoutId: l, layout: f, alwaysMeasureLayout: !!u || h && Nr(h), visualElement: t, animationType: typeof f == "string" ? f : "both", initialPromotionConfig: s, layoutScroll: p, layoutRoot: m }) } function ng(t) { if (t) return t.options.allowProjection !== !1 ? t.projection : ng(t.parent) } function dP(t, r, i) { return k.useCallback(s => { s && t.mount && t.mount(s), r && (s ? r.mount(s) : r.unmount()), i && (typeof i == "function" ? i(s) : Nr(i) && (i.current = s)) }, [r]) } function qs(t) { return Us(t.animate) || nc.some(r => $i(t[r])) } function rg(t) { return !!(qs(t) || t.variants) } function hP(t, r) { if (qs(t)) { const { initial: i, animate: s } = t; return { initial: i === !1 || $i(i) ? i : void 0, animate: $i(s) ? s : void 0 } } return t.inherit !== !1 ? r : {} } function pP(t) { const { initial: r, animate: i } = hP(t, k.useContext(Ks)); return k.useMemo(() => ({ initial: r, animate: i }), [sm(r), sm(i)]) } function sm(t) { return Array.isArray(t) ? t.join(" ") : t } const am = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, zr = {}; for (const t in am) zr[t] = { isEnabled: r => am[t].some(i => !!r[i]) }; function mP(t) { for (const r in t) zr[r] = { ...zr[r], ...t[r] } } const yP = Symbol.for("motionComponentSymbol"); function gP({ preloadedFeatures: t, createVisualElement: r, useRender: i, useVisualState: s, Component: l }) { t && mP(t); function f(h, p) { let m; const y = { ...k.useContext(Cc), ...h, layoutId: vP(h) }, { isStatic: v } = y, w = pP(h), C = s(h, v); if (!v && Tc) { wP(); const S = xP(y); m = S.MeasureLayout, w.visualElement = cP(l, C, y, r, S.ProjectionNode) } return H.jsxs(Ks.Provider, { value: w, children: [m && w.visualElement ? H.jsx(m, { visualElement: w.visualElement, ...y }) : null, i(l, h, dP(C, w.visualElement, p), C, v, w.visualElement)] }) } const u = k.forwardRef(f); return u[yP] = l, u } function vP({ layoutId: t }) { const r = k.useContext(Ec).id; return r && t !== void 0 ? r + "-" + t : t } function wP(t, r) { k.useContext(tg).strict } function xP(t) { const { drag: r, layout: i } = zr; if (!r && !i) return {}; const s = { ...r, ...i }; return { MeasureLayout: r != null && r.isEnabled(t) || i != null && i.isEnabled(t) ? s.MeasureLayout : void 0, ProjectionNode: s.ProjectionNode } } const SP = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function kc(t) { return typeof t != "string" || t.includes("-") ? !1 : !!(SP.indexOf(t) > -1 || /[A-Z]/u.test(t)) } function ig(t, { style: r, vars: i }, s, l) { Object.assign(t.style, r, l && l.getProjectionStyles(s)); for (const f in i) t.style.setProperty(f, i[f]) } const og = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function sg(t, r, i, s) { ig(t, r, void 0, s); for (const l in r.attrs) t.setAttribute(og.has(l) ? l : Sc(l), r.attrs[l]) } function ag(t, { layout: r, layoutId: i }) { return sr.has(t) || t.startsWith("origin") || (r || i !== void 0) && (!!Fs[t] || t === "opacity") } function Rc(t, r, i) { var s; const { style: l } = t, f = {}; for (const u in l) (Ye(l[u]) || r.style && Ye(r.style[u]) || ag(u, t) || ((s = i == null ? void 0 : i.getValue(u)) === null || s === void 0 ? void 0 : s.liveStyle) !== void 0) && (f[u] = l[u]); return f } function lg(t, r, i) { const s = Rc(t, r, i); for (const l in t) if (Ye(t[l]) || Ye(r[l])) { const f = Xi.indexOf(l) !== -1 ? "attr" + l.charAt(0).toUpperCase() + l.substring(1) : l; s[f] = t[l] } return s } function Ac(t) { const r = k.useRef(null); return r.current === null && (r.current = t()), r.current } function EP({ scrapeMotionValuesFromProps: t, createRenderState: r, onMount: i }, s, l, f) { const u = { latestValues: PP(s, l, f, t), renderState: r() }; return i && (u.mount = h => i(s, h, u)), u } const ug = t => (r, i) => { const s = k.useContext(Ks), l = k.useContext(Ws), f = () => EP(t, r, s, l); return i ? f() : Ac(f) }; function PP(t, r, i, s) { const l = {}, f = s(t, {}); for (const w in f) l[w] = Ps(f[w]); let { initial: u, animate: h } = t; const p = qs(t), m = rg(t); r && m && !p && t.inherit !== !1 && (u === void 0 && (u = r.initial), h === void 0 && (h = r.animate)); let y = i ? i.initial === !1 : !1; y = y || u === !1; const v = y ? h : u; if (v && typeof v != "boolean" && !Us(v)) { const w = Array.isArray(v) ? v : [v]; for (let C = 0; C < w.length; C++) { const S = ec(t, w[C]); if (S) { const { transitionEnd: R, transition: P, ...A } = S; for (const N in A) { let F = A[N]; if (Array.isArray(F)) { const b = y ? F.length - 1 : 0; F = F[b] } F !== null && (l[N] = F) } for (const N in R) l[N] = R[N] } } } return l } const Lc = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }), cg = () => ({ ...Lc(), attrs: {} }), fg = (t, r) => r && typeof t == "number" ? r.transform(t) : t, CP = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, TP = Xi.length; function kP(t, r, i) { let s = "", l = !0; for (let f = 0; f < TP; f++) { const u = Xi[f], h = t[u]; if (h === void 0) continue; let p = !0; if (typeof h == "number" ? p = h === (u.startsWith("scale") ? 1 : 0) : p = parseFloat(h) === 0, !p || i) { const m = fg(h, cc[u]); if (!p) { l = !1; const y = CP[u] || u; s += `${y}(${m}) ` } i && (r[u] = m) } } return s = s.trim(), i ? s = i(r, l ? "" : s) : l && (s = "none"), s } function Dc(t, r, i) { const { style: s, vars: l, transformOrigin: f } = t; let u = !1, h = !1; for (const p in r) { const m = r[p]; if (sr.has(p)) { u = !0; continue } else if (ty(p)) { l[p] = m; continue } else { const y = fg(m, cc[p]); p.startsWith("origin") ? (h = !0, f[p] = y) : s[p] = y } } if (r.transform || (u || i ? s.transform = kP(r, t.transform, i) : s.transform && (s.transform = "none")), h) { const { originX: p = "50%", originY: m = "50%", originZ: y = 0 } = f; s.transformOrigin = `${p} ${m} ${y}` } } function lm(t, r, i) { return typeof t == "string" ? t : re.transform(r + i * t) } function RP(t, r, i) { const s = lm(r, t.x, t.width), l = lm(i, t.y, t.height); return `${s} ${l}` } const AP = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, LP = { offset: "strokeDashoffset", array: "strokeDasharray" }; function DP(t, r, i = 1, s = 0, l = !0) { t.pathLength = 1; const f = l ? AP : LP; t[f.offset] = re.transform(-s); const u = re.transform(r), h = re.transform(i); t[f.array] = `${u} ${h}` } function _c(t, { attrX: r, attrY: i, attrScale: s, originX: l, originY: f, pathLength: u, pathSpacing: h = 1, pathOffset: p = 0, ...m }, y, v) { if (Dc(t, m, v), y) { t.style.viewBox && (t.attrs.viewBox = t.style.viewBox); return } t.attrs = t.style, t.style = {}; const { attrs: w, style: C, dimensions: S } = t; w.transform && (S && (C.transform = w.transform), delete w.transform), S && (l !== void 0 || f !== void 0 || C.transform) && (C.transformOrigin = RP(S, l !== void 0 ? l : .5, f !== void 0 ? f : .5)), r !== void 0 && (w.x = r), i !== void 0 && (w.y = i), s !== void 0 && (w.scale = s), u !== void 0 && DP(w, u, h, p, !1) } const Mc = t => typeof t == "string" && t.toLowerCase() === "svg", _P = { useVisualState: ug({ scrapeMotionValuesFromProps: lg, createRenderState: cg, onMount: (t, r, { renderState: i, latestValues: s }) => { ve.read(() => { try { i.dimensions = typeof r.getBBox == "function" ? r.getBBox() : r.getBoundingClientRect() } catch { i.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), ve.render(() => { _c(i, s, Mc(r.tagName), t.transformTemplate), sg(r, i) }) } }) }, MP = { useVisualState: ug({ scrapeMotionValuesFromProps: Rc, createRenderState: Lc }) }; function dg(t, r, i) { for (const s in r) !Ye(r[s]) && !ag(s, i) && (t[s] = r[s]) } function OP({ transformTemplate: t }, r) { return k.useMemo(() => { const i = Lc(); return Dc(i, r, t), Object.assign({}, i.vars, i.style) }, [r]) } function NP(t, r) { const i = t.style || {}, s = {}; return dg(s, i, t), Object.assign(s, OP(t, r)), s } function FP(t, r) { const i = {}, s = NP(t, r); return t.drag && t.dragListener !== !1 && (i.draggable = !1, s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = "none", s.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (i.tabIndex = 0), i.style = s, i } const VP = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function Vs(t) { return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || VP.has(t) } let hg = t => !Vs(t); function jP(t) { t && (hg = r => r.startsWith("on") ? !Vs(r) : t(r)) } try { jP(require("@emotion/is-prop-valid").default) } catch { } function IP(t, r, i) { const s = {}; for (const l in t) l === "values" && typeof t.values == "object" || (hg(l) || i === !0 && Vs(l) || !r && !Vs(l) || t.draggable && l.startsWith("onDrag")) && (s[l] = t[l]); return s } function BP(t, r, i, s) { const l = k.useMemo(() => { const f = cg(); return _c(f, r, Mc(s), t.transformTemplate), { ...f.attrs, style: { ...f.style } } }, [r]); if (t.style) { const f = {}; dg(f, t.style, t), l.style = { ...f, ...l.style } } return l } function zP(t = !1) { return (i, s, l, { latestValues: f }, u) => { const p = (kc(i) ? BP : FP)(s, f, u, i), m = IP(s, typeof i == "string", t), y = i !== k.Fragment ? { ...m, ...p, ref: l } : {}, { children: v } = s, w = k.useMemo(() => Ye(v) ? v.get() : v, [v]); return k.createElement(i, { ...y, children: w }) } } function UP(t, r) { return function (s, { forwardMotionProps: l } = { forwardMotionProps: !1 }) { const u = { ...kc(s) ? _P : MP, preloadedFeatures: t, useRender: zP(l), createVisualElement: r, Component: s }; return gP(u) } } const Iu = { current: null }, pg = { current: !1 }; function bP() { if (pg.current = !0, !!Tc) if (window.matchMedia) { const t = window.matchMedia("(prefers-reduced-motion)"), r = () => Iu.current = t.matches; t.addListener(r), r() } else Iu.current = !1 } function $P(t, r, i) { for (const s in r) { const l = r[s], f = i[s]; if (Ye(l)) t.addValue(s, l); else if (Ye(f)) t.addValue(s, Ki(l, { owner: t })); else if (f !== l) if (t.hasValue(s)) { const u = t.getValue(s); u.liveStyle === !0 ? u.jump(l) : u.hasAnimated || u.set(l) } else { const u = t.getStaticValue(s); t.addValue(s, Ki(u !== void 0 ? u : l, { owner: t })) } } for (const s in i) r[s] === void 0 && t.removeValue(s); return r } const um = new WeakMap, HP = [...iy, Qe, Fn], WP = t => HP.find(ry(t)), cm = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class KP { scrapeMotionValuesFromProps(r, i, s) { return {} } constructor({ parent: r, props: i, presenceContext: s, reducedMotionConfig: l, blockInitialAnimation: f, visualState: u }, h = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = ac, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const w = Wt.now(); this.renderScheduledAt < w && (this.renderScheduledAt = w, ve.render(this.render, !1, !0)) }; const { latestValues: p, renderState: m } = u; this.latestValues = p, this.baseTarget = { ...p }, this.initialValues = i.initial ? { ...p } : {}, this.renderState = m, this.parent = r, this.props = i, this.presenceContext = s, this.depth = r ? r.depth + 1 : 0, this.reducedMotionConfig = l, this.options = h, this.blockInitialAnimation = !!f, this.isControllingVariants = qs(i), this.isVariantNode = rg(i), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(r && r.current); const { willChange: y, ...v } = this.scrapeMotionValuesFromProps(i, {}, this); for (const w in v) { const C = v[w]; p[w] !== void 0 && Ye(C) && C.set(p[w], !1) } } mount(r) { this.current = r, um.set(r, this), this.projection && !this.projection.instance && this.projection.mount(r), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((i, s) => this.bindToMotionValue(s, i)), pg.current || bP(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Iu.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { um.delete(this.current), this.projection && this.projection.unmount(), Nn(this.notifyUpdate), Nn(this.render), this.valueSubscriptions.forEach(r => r()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const r in this.events) this.events[r].clear(); for (const r in this.features) { const i = this.features[r]; i && (i.unmount(), i.isMounted = !1) } this.current = null } bindToMotionValue(r, i) { this.valueSubscriptions.has(r) && this.valueSubscriptions.get(r)(); const s = sr.has(r), l = i.on("change", h => { this.latestValues[r] = h, this.props.onUpdate && ve.preRender(this.notifyUpdate), s && this.projection && (this.projection.isTransformDirty = !0) }), f = i.on("renderRequest", this.scheduleRender); let u; window.MotionCheckAppearSync && (u = window.MotionCheckAppearSync(this, r, i)), this.valueSubscriptions.set(r, () => { l(), f(), u && u(), i.owner && i.stop() }) } sortNodePosition(r) { return !this.current || !this.sortInstanceNodePosition || this.type !== r.type ? 0 : this.sortInstanceNodePosition(this.current, r.current) } updateFeatures() { let r = "animation"; for (r in zr) { const i = zr[r]; if (!i) continue; const { isEnabled: s, Feature: l } = i; if (!this.features[r] && l && s(this.props) && (this.features[r] = new l(this)), this.features[r]) { const f = this.features[r]; f.isMounted ? f.update() : (f.mount(), f.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Oe() } getStaticValue(r) { return this.latestValues[r] } setStaticValue(r, i) { this.latestValues[r] = i } update(r, i) { (r.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = r, this.prevPresenceContext = this.presenceContext, this.presenceContext = i; for (let s = 0; s < cm.length; s++) { const l = cm[s]; this.propEventSubscriptions[l] && (this.propEventSubscriptions[l](), delete this.propEventSubscriptions[l]); const f = "on" + l, u = r[f]; u && (this.propEventSubscriptions[l] = this.on(l, u)) } this.prevMotionValues = $P(this, this.scrapeMotionValuesFromProps(r, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(r) { return this.props.variants ? this.props.variants[r] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(r) { const i = this.getClosestVariantNode(); if (i) return i.variantChildren && i.variantChildren.add(r), () => i.variantChildren.delete(r) } addValue(r, i) { const s = this.values.get(r); i !== s && (s && this.removeValue(r), this.bindToMotionValue(r, i), this.values.set(r, i), this.latestValues[r] = i.get()) } removeValue(r) { this.values.delete(r); const i = this.valueSubscriptions.get(r); i && (i(), this.valueSubscriptions.delete(r)), delete this.latestValues[r], this.removeValueFromRenderState(r, this.renderState) } hasValue(r) { return this.values.has(r) } getValue(r, i) { if (this.props.values && this.props.values[r]) return this.props.values[r]; let s = this.values.get(r); return s === void 0 && i !== void 0 && (s = Ki(i === null ? void 0 : i, { owner: this }), this.addValue(r, s)), s } readValue(r, i) { var s; let l = this.latestValues[r] !== void 0 || !this.current ? this.latestValues[r] : (s = this.getBaseTargetFromProps(this.props, r)) !== null && s !== void 0 ? s : this.readValueFromInstance(this.current, r, this.options); return l != null && (typeof l == "string" && (Zm(l) || Jm(l)) ? l = parseFloat(l) : !WP(l) && Fn.test(i) && (l = dy(r, i)), this.setBaseTarget(r, Ye(l) ? l.get() : l)), Ye(l) ? l.get() : l } setBaseTarget(r, i) { this.baseTarget[r] = i } getBaseTarget(r) { var i; const { initial: s } = this.props; let l; if (typeof s == "string" || typeof s == "object") { const u = ec(this.props, s, (i = this.presenceContext) === null || i === void 0 ? void 0 : i.custom); u && (l = u[r]) } if (s && l !== void 0) return l; const f = this.getBaseTargetFromProps(this.props, r); return f !== void 0 && !Ye(f) ? f : this.initialValues[r] !== void 0 && l === void 0 ? void 0 : this.baseTarget[r] } on(r, i) { return this.events[r] || (this.events[r] = new xc), this.events[r].add(i) } notify(r, ...i) { this.events[r] && this.events[r].notify(...i) } } class mg extends KP { constructor() { super(...arguments), this.KeyframeResolver = hy } sortInstanceNodePosition(r, i) { return r.compareDocumentPosition(i) & 2 ? 1 : -1 } getBaseTargetFromProps(r, i) { return r.style ? r.style[i] : void 0 } removeValueFromRenderState(r, { vars: i, style: s }) { delete i[r], delete s[r] } } function qP(t) { return window.getComputedStyle(t) } class GP extends mg { constructor() { super(...arguments), this.type = "html", this.renderInstance = ig } readValueFromInstance(r, i) { if (sr.has(i)) { const s = fc(i); return s && s.default || 0 } else { const s = qP(r), l = (ty(i) ? s.getPropertyValue(i) : s[i]) || 0; return typeof l == "string" ? l.trim() : l } } measureInstanceViewportBox(r, { transformPagePoint: i }) { return Uy(r, i) } build(r, i, s) { Dc(r, i, s.transformTemplate) } scrapeMotionValuesFromProps(r, i, s) { return Rc(r, i, s) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: r } = this.props; Ye(r) && (this.childSubscription = r.on("change", i => { this.current && (this.current.textContent = `${i}`) })) } } class QP extends mg { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Oe } getBaseTargetFromProps(r, i) { return r[i] } readValueFromInstance(r, i) { if (sr.has(i)) { const s = fc(i); return s && s.default || 0 } return i = og.has(i) ? i : Sc(i), r.getAttribute(i) } scrapeMotionValuesFromProps(r, i, s) { return lg(r, i, s) } build(r, i, s) { _c(r, i, this.isSVGTag, s.transformTemplate) } renderInstance(r, i, s, l) { sg(r, i, s, l) } mount(r) { this.isSVGTag = Mc(r.tagName), super.mount(r) } } const XP = (t, r) => kc(t) ? new QP(r) : new GP(r, { allowProjection: t !== k.Fragment }), YP = UP({ ...zS, ...lP, ...YE, ...uP }, XP), gs = Iw(YP); class JP extends k.Component { getSnapshotBeforeUpdate(r) { const i = this.props.childRef.current; if (i && r.isPresent && !this.props.isPresent) { const s = this.props.sizeRef.current; s.height = i.offsetHeight || 0, s.width = i.offsetWidth || 0, s.top = i.offsetTop, s.left = i.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } } function ZP({ children: t, isPresent: r }) {
  const i = k.useId(), s = k.useRef(null), l = k.useRef({ width: 0, height: 0, top: 0, left: 0 }), { nonce: f } = k.useContext(Cc); return k.useInsertionEffect(() => {
    const { width: u, height: h, top: p, left: m } = l.current; if (r || !s.current || !u || !h) return; s.current.dataset.motionPopId = i; const y = document.createElement("style"); return f && (y.nonce = f), document.head.appendChild(y), y.sheet && y.sheet.insertRule(`
          [data-motion-pop-id="${i}"] {
            position: absolute !important;
            width: ${u}px !important;
            height: ${h}px !important;
            top: ${p}px !important;
            left: ${m}px !important;
          }
        `), () => { document.head.removeChild(y) }
  }, [r]), H.jsx(JP, { isPresent: r, childRef: s, sizeRef: l, children: k.cloneElement(t, { ref: s }) })
} const eC = ({ children: t, initial: r, isPresent: i, onExitComplete: s, custom: l, presenceAffectsLayout: f, mode: u }) => { const h = Ac(tC), p = k.useId(), m = k.useCallback(v => { h.set(v, !0); for (const w of h.values()) if (!w) return; s && s() }, [h, s]), y = k.useMemo(() => ({ id: p, initial: r, isPresent: i, custom: l, onExitComplete: m, register: v => (h.set(v, !1), () => h.delete(v)) }), f ? [Math.random(), m] : [i, m]); return k.useMemo(() => { h.forEach((v, w) => h.set(w, !1)) }, [i]), k.useEffect(() => { !i && !h.size && s && s() }, [i]), u === "popLayout" && (t = H.jsx(ZP, { isPresent: i, children: t })), H.jsx(Ws.Provider, { value: y, children: t }) }; function tC() { return new Map } const vs = t => t.key || ""; function fm(t) { const r = []; return k.Children.forEach(t, i => { k.isValidElement(i) && r.push(i) }), r } const nC = ({ children: t, exitBeforeEnter: r, custom: i, initial: s = !0, onExitComplete: l, presenceAffectsLayout: f = !0, mode: u = "sync" }) => { const h = k.useMemo(() => fm(t), [t]), p = h.map(vs), m = k.useRef(!0), y = k.useRef(h), v = Ac(() => new Map), [w, C] = k.useState(h), [S, R] = k.useState(h); eg(() => { m.current = !1, y.current = h; for (let N = 0; N < S.length; N++) { const F = vs(S[N]); p.includes(F) ? v.delete(F) : v.get(F) !== !0 && v.set(F, !1) } }, [S, p.length, p.join("-")]); const P = []; if (h !== w) { let N = [...h]; for (let F = 0; F < S.length; F++) { const b = S[F], z = vs(b); p.includes(z) || (N.splice(F, 0, b), P.push(b)) } u === "wait" && P.length && (N = P), R(fm(N)), C(h); return } const { forceRender: A } = k.useContext(Ec); return H.jsx(H.Fragment, { children: S.map(N => { const F = vs(N), b = h === S || p.includes(F), z = () => { if (v.has(F)) v.set(F, !0); else return; let Y = !0; v.forEach(ne => { ne || (Y = !1) }), Y && (A == null || A(), R(y.current), l && l()) }; return H.jsx(eC, { isPresent: b, initial: !m.current || s ? void 0 : !1, custom: b ? void 0 : i, presenceAffectsLayout: f, mode: u, onExitComplete: b ? void 0 : z, children: N }, F) }) }) }, Oc = k.createContext(null), yg = ({ children: t }) => { const [r, i] = k.useState(() => { const l = localStorage.getItem("userDetail"); return l ? JSON.parse(l) : null }), s = k.useMemo(() => ({ userDetail: r, setUserDetails: i, logout: () => { i(null), localStorage.removeItem("userDetail") }, isAuthenticated: !!r }), [r]); return k.useEffect(() => { r ? localStorage.setItem("userDetail", JSON.stringify(r)) : localStorage.removeItem("userDetail") }, [r]), H.jsx(Oc.Provider, { value: s, children: t }) }; yg.propTypes = { children: Ls.node.isRequired }; function gg(t, r) { return function () { return t.apply(r, arguments) } } const { toString: rC } = Object.prototype, { getPrototypeOf: Nc } = Object, Gs = (t => r => { const i = rC.call(r); return t[i] || (t[i] = i.slice(8, -1).toLowerCase()) })(Object.create(null)), jt = t => (t = t.toLowerCase(), r => Gs(r) === t), Qs = t => r => typeof r === t, { isArray: Wr } = Array, qi = Qs("undefined"); function iC(t) { return t !== null && !qi(t) && t.constructor !== null && !qi(t.constructor) && gt(t.constructor.isBuffer) && t.constructor.isBuffer(t) } const vg = jt("ArrayBuffer"); function oC(t) { let r; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? r = ArrayBuffer.isView(t) : r = t && t.buffer && vg(t.buffer), r } const sC = Qs("string"), gt = Qs("function"), wg = Qs("number"), Xs = t => t !== null && typeof t == "object", aC = t => t === !0 || t === !1, Cs = t => { if (Gs(t) !== "object") return !1; const r = Nc(t); return (r === null || r === Object.prototype || Object.getPrototypeOf(r) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t) }, lC = jt("Date"), uC = jt("File"), cC = jt("Blob"), fC = jt("FileList"), dC = t => Xs(t) && gt(t.pipe), hC = t => { let r; return t && (typeof FormData == "function" && t instanceof FormData || gt(t.append) && ((r = Gs(t)) === "formdata" || r === "object" && gt(t.toString) && t.toString() === "[object FormData]")) }, pC = jt("URLSearchParams"), [mC, yC, gC, vC] = ["ReadableStream", "Request", "Response", "Headers"].map(jt), wC = t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function Zi(t, r, { allOwnKeys: i = !1 } = {}) { if (t === null || typeof t > "u") return; let s, l; if (typeof t != "object" && (t = [t]), Wr(t)) for (s = 0, l = t.length; s < l; s++)r.call(null, t[s], s, t); else { const f = i ? Object.getOwnPropertyNames(t) : Object.keys(t), u = f.length; let h; for (s = 0; s < u; s++)h = f[s], r.call(null, t[h], h, t) } } function xg(t, r) { r = r.toLowerCase(); const i = Object.keys(t); let s = i.length, l; for (; s-- > 0;)if (l = i[s], r === l.toLowerCase()) return l; return null } const tr = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, Sg = t => !qi(t) && t !== tr; function Bu() { const { caseless: t } = Sg(this) && this || {}, r = {}, i = (s, l) => { const f = t && xg(r, l) || l; Cs(r[f]) && Cs(s) ? r[f] = Bu(r[f], s) : Cs(s) ? r[f] = Bu({}, s) : Wr(s) ? r[f] = s.slice() : r[f] = s }; for (let s = 0, l = arguments.length; s < l; s++)arguments[s] && Zi(arguments[s], i); return r } const xC = (t, r, i, { allOwnKeys: s } = {}) => (Zi(r, (l, f) => { i && gt(l) ? t[f] = gg(l, i) : t[f] = l }, { allOwnKeys: s }), t), SC = t => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), EC = (t, r, i, s) => { t.prototype = Object.create(r.prototype, s), t.prototype.constructor = t, Object.defineProperty(t, "super", { value: r.prototype }), i && Object.assign(t.prototype, i) }, PC = (t, r, i, s) => { let l, f, u; const h = {}; if (r = r || {}, t == null) return r; do { for (l = Object.getOwnPropertyNames(t), f = l.length; f-- > 0;)u = l[f], (!s || s(u, t, r)) && !h[u] && (r[u] = t[u], h[u] = !0); t = i !== !1 && Nc(t) } while (t && (!i || i(t, r)) && t !== Object.prototype); return r }, CC = (t, r, i) => { t = String(t), (i === void 0 || i > t.length) && (i = t.length), i -= r.length; const s = t.indexOf(r, i); return s !== -1 && s === i }, TC = t => { if (!t) return null; if (Wr(t)) return t; let r = t.length; if (!wg(r)) return null; const i = new Array(r); for (; r-- > 0;)i[r] = t[r]; return i }, kC = (t => r => t && r instanceof t)(typeof Uint8Array < "u" && Nc(Uint8Array)), RC = (t, r) => { const s = (t && t[Symbol.iterator]).call(t); let l; for (; (l = s.next()) && !l.done;) { const f = l.value; r.call(t, f[0], f[1]) } }, AC = (t, r) => { let i; const s = []; for (; (i = t.exec(r)) !== null;)s.push(i); return s }, LC = jt("HTMLFormElement"), DC = t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (i, s, l) { return s.toUpperCase() + l }), dm = (({ hasOwnProperty: t }) => (r, i) => t.call(r, i))(Object.prototype), _C = jt("RegExp"), Eg = (t, r) => { const i = Object.getOwnPropertyDescriptors(t), s = {}; Zi(i, (l, f) => { let u; (u = r(l, f, t)) !== !1 && (s[f] = u || l) }), Object.defineProperties(t, s) }, MC = t => { Eg(t, (r, i) => { if (gt(t) && ["arguments", "caller", "callee"].indexOf(i) !== -1) return !1; const s = t[i]; if (gt(s)) { if (r.enumerable = !1, "writable" in r) { r.writable = !1; return } r.set || (r.set = () => { throw Error("Can not rewrite read-only method '" + i + "'") }) } }) }, OC = (t, r) => { const i = {}, s = l => { l.forEach(f => { i[f] = !0 }) }; return Wr(t) ? s(t) : s(String(t).split(r)), i }, NC = () => { }, FC = (t, r) => t != null && Number.isFinite(t = +t) ? t : r, yu = "abcdefghijklmnopqrstuvwxyz", hm = "0123456789", Pg = { DIGIT: hm, ALPHA: yu, ALPHA_DIGIT: yu + yu.toUpperCase() + hm }, VC = (t = 16, r = Pg.ALPHA_DIGIT) => { let i = ""; const { length: s } = r; for (; t--;)i += r[Math.random() * s | 0]; return i }; function jC(t) { return !!(t && gt(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]) } const IC = t => { const r = new Array(10), i = (s, l) => { if (Xs(s)) { if (r.indexOf(s) >= 0) return; if (!("toJSON" in s)) { r[l] = s; const f = Wr(s) ? [] : {}; return Zi(s, (u, h) => { const p = i(u, l + 1); !qi(p) && (f[h] = p) }), r[l] = void 0, f } } return s }; return i(t, 0) }, BC = jt("AsyncFunction"), zC = t => t && (Xs(t) || gt(t)) && gt(t.then) && gt(t.catch), Cg = ((t, r) => t ? setImmediate : r ? ((i, s) => (tr.addEventListener("message", ({ source: l, data: f }) => { l === tr && f === i && s.length && s.shift()() }, !1), l => { s.push(l), tr.postMessage(i, "*") }))(`axios@${Math.random()}`, []) : i => setTimeout(i))(typeof setImmediate == "function", gt(tr.postMessage)), UC = typeof queueMicrotask < "u" ? queueMicrotask.bind(tr) : typeof process < "u" && process.nextTick || Cg, O = { isArray: Wr, isArrayBuffer: vg, isBuffer: iC, isFormData: hC, isArrayBufferView: oC, isString: sC, isNumber: wg, isBoolean: aC, isObject: Xs, isPlainObject: Cs, isReadableStream: mC, isRequest: yC, isResponse: gC, isHeaders: vC, isUndefined: qi, isDate: lC, isFile: uC, isBlob: cC, isRegExp: _C, isFunction: gt, isStream: dC, isURLSearchParams: pC, isTypedArray: kC, isFileList: fC, forEach: Zi, merge: Bu, extend: xC, trim: wC, stripBOM: SC, inherits: EC, toFlatObject: PC, kindOf: Gs, kindOfTest: jt, endsWith: CC, toArray: TC, forEachEntry: RC, matchAll: AC, isHTMLForm: LC, hasOwnProperty: dm, hasOwnProp: dm, reduceDescriptors: Eg, freezeMethods: MC, toObjectSet: OC, toCamelCase: DC, noop: NC, toFiniteNumber: FC, findKey: xg, global: tr, isContextDefined: Sg, ALPHABET: Pg, generateString: VC, isSpecCompliantForm: jC, toJSONObject: IC, isAsyncFn: BC, isThenable: zC, setImmediate: Cg, asap: UC }; function oe(t, r, i, s, l) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", r && (this.code = r), i && (this.config = i), s && (this.request = s), l && (this.response = l, this.status = l.status ? l.status : null) } O.inherits(oe, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: O.toJSONObject(this.config), code: this.code, status: this.status } } }); const Tg = oe.prototype, kg = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(t => { kg[t] = { value: t } }); Object.defineProperties(oe, kg); Object.defineProperty(Tg, "isAxiosError", { value: !0 }); oe.from = (t, r, i, s, l, f) => { const u = Object.create(Tg); return O.toFlatObject(t, u, function (p) { return p !== Error.prototype }, h => h !== "isAxiosError"), oe.call(u, t.message, r, i, s, l), u.cause = t, u.name = t.name, f && Object.assign(u, f), u }; const bC = null; function zu(t) { return O.isPlainObject(t) || O.isArray(t) } function Rg(t) { return O.endsWith(t, "[]") ? t.slice(0, -2) : t } function pm(t, r, i) { return t ? t.concat(r).map(function (l, f) { return l = Rg(l), !i && f ? "[" + l + "]" : l }).join(i ? "." : "") : r } function $C(t) { return O.isArray(t) && !t.some(zu) } const HC = O.toFlatObject(O, {}, null, function (r) { return /^is[A-Z]/.test(r) }); function Ys(t, r, i) { if (!O.isObject(t)) throw new TypeError("target must be an object"); r = r || new FormData, i = O.toFlatObject(i, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (R, P) { return !O.isUndefined(P[R]) }); const s = i.metaTokens, l = i.visitor || y, f = i.dots, u = i.indexes, p = (i.Blob || typeof Blob < "u" && Blob) && O.isSpecCompliantForm(r); if (!O.isFunction(l)) throw new TypeError("visitor must be a function"); function m(S) { if (S === null) return ""; if (O.isDate(S)) return S.toISOString(); if (!p && O.isBlob(S)) throw new oe("Blob is not supported. Use a Buffer instead."); return O.isArrayBuffer(S) || O.isTypedArray(S) ? p && typeof Blob == "function" ? new Blob([S]) : Buffer.from(S) : S } function y(S, R, P) { let A = S; if (S && !P && typeof S == "object") { if (O.endsWith(R, "{}")) R = s ? R : R.slice(0, -2), S = JSON.stringify(S); else if (O.isArray(S) && $C(S) || (O.isFileList(S) || O.endsWith(R, "[]")) && (A = O.toArray(S))) return R = Rg(R), A.forEach(function (F, b) { !(O.isUndefined(F) || F === null) && r.append(u === !0 ? pm([R], b, f) : u === null ? R : R + "[]", m(F)) }), !1 } return zu(S) ? !0 : (r.append(pm(P, R, f), m(S)), !1) } const v = [], w = Object.assign(HC, { defaultVisitor: y, convertValue: m, isVisitable: zu }); function C(S, R) { if (!O.isUndefined(S)) { if (v.indexOf(S) !== -1) throw Error("Circular reference detected in " + R.join(".")); v.push(S), O.forEach(S, function (A, N) { (!(O.isUndefined(A) || A === null) && l.call(r, A, O.isString(N) ? N.trim() : N, R, w)) === !0 && C(A, R ? R.concat(N) : [N]) }), v.pop() } } if (!O.isObject(t)) throw new TypeError("data must be an object"); return C(t), r } function mm(t) { const r = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (s) { return r[s] }) } function Fc(t, r) { this._pairs = [], t && Ys(t, this, r) } const Ag = Fc.prototype; Ag.append = function (r, i) { this._pairs.push([r, i]) }; Ag.toString = function (r) { const i = r ? function (s) { return r.call(this, s, mm) } : mm; return this._pairs.map(function (l) { return i(l[0]) + "=" + i(l[1]) }, "").join("&") }; function WC(t) { return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function Lg(t, r, i) { if (!r) return t; const s = i && i.encode || WC; O.isFunction(i) && (i = { serialize: i }); const l = i && i.serialize; let f; if (l ? f = l(r, i) : f = O.isURLSearchParams(r) ? r.toString() : new Fc(r, i).toString(s), f) { const u = t.indexOf("#"); u !== -1 && (t = t.slice(0, u)), t += (t.indexOf("?") === -1 ? "?" : "&") + f } return t } class ym { constructor() { this.handlers = [] } use(r, i, s) { return this.handlers.push({ fulfilled: r, rejected: i, synchronous: s ? s.synchronous : !1, runWhen: s ? s.runWhen : null }), this.handlers.length - 1 } eject(r) { this.handlers[r] && (this.handlers[r] = null) } clear() { this.handlers && (this.handlers = []) } forEach(r) { O.forEach(this.handlers, function (s) { s !== null && r(s) }) } } const Dg = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, KC = typeof URLSearchParams < "u" ? URLSearchParams : Fc, qC = typeof FormData < "u" ? FormData : null, GC = typeof Blob < "u" ? Blob : null, QC = { isBrowser: !0, classes: { URLSearchParams: KC, FormData: qC, Blob: GC }, protocols: ["http", "https", "file", "blob", "url", "data"] }, Vc = typeof window < "u" && typeof document < "u", Uu = typeof navigator == "object" && navigator || void 0, XC = Vc && (!Uu || ["ReactNative", "NativeScript", "NS"].indexOf(Uu.product) < 0), YC = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", JC = Vc && window.location.href || "http://localhost", ZC = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: Vc, hasStandardBrowserEnv: XC, hasStandardBrowserWebWorkerEnv: YC, navigator: Uu, origin: JC }, Symbol.toStringTag, { value: "Module" })), Xe = { ...ZC, ...QC }; function eT(t, r) { return Ys(t, new Xe.classes.URLSearchParams, Object.assign({ visitor: function (i, s, l, f) { return Xe.isNode && O.isBuffer(i) ? (this.append(s, i.toString("base64")), !1) : f.defaultVisitor.apply(this, arguments) } }, r)) } function tT(t) { return O.matchAll(/\w+|\[(\w*)]/g, t).map(r => r[0] === "[]" ? "" : r[1] || r[0]) } function nT(t) { const r = {}, i = Object.keys(t); let s; const l = i.length; let f; for (s = 0; s < l; s++)f = i[s], r[f] = t[f]; return r } function _g(t) { function r(i, s, l, f) { let u = i[f++]; if (u === "__proto__") return !0; const h = Number.isFinite(+u), p = f >= i.length; return u = !u && O.isArray(l) ? l.length : u, p ? (O.hasOwnProp(l, u) ? l[u] = [l[u], s] : l[u] = s, !h) : ((!l[u] || !O.isObject(l[u])) && (l[u] = []), r(i, s, l[u], f) && O.isArray(l[u]) && (l[u] = nT(l[u])), !h) } if (O.isFormData(t) && O.isFunction(t.entries)) { const i = {}; return O.forEachEntry(t, (s, l) => { r(tT(s), l, i, 0) }), i } return null } function rT(t, r, i) { if (O.isString(t)) try { return (r || JSON.parse)(t), O.trim(t) } catch (s) { if (s.name !== "SyntaxError") throw s } return (0, JSON.stringify)(t) } const eo = { transitional: Dg, adapter: ["xhr", "http", "fetch"], transformRequest: [function (r, i) { const s = i.getContentType() || "", l = s.indexOf("application/json") > -1, f = O.isObject(r); if (f && O.isHTMLForm(r) && (r = new FormData(r)), O.isFormData(r)) return l ? JSON.stringify(_g(r)) : r; if (O.isArrayBuffer(r) || O.isBuffer(r) || O.isStream(r) || O.isFile(r) || O.isBlob(r) || O.isReadableStream(r)) return r; if (O.isArrayBufferView(r)) return r.buffer; if (O.isURLSearchParams(r)) return i.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), r.toString(); let h; if (f) { if (s.indexOf("application/x-www-form-urlencoded") > -1) return eT(r, this.formSerializer).toString(); if ((h = O.isFileList(r)) || s.indexOf("multipart/form-data") > -1) { const p = this.env && this.env.FormData; return Ys(h ? { "files[]": r } : r, p && new p, this.formSerializer) } } return f || l ? (i.setContentType("application/json", !1), rT(r)) : r }], transformResponse: [function (r) { const i = this.transitional || eo.transitional, s = i && i.forcedJSONParsing, l = this.responseType === "json"; if (O.isResponse(r) || O.isReadableStream(r)) return r; if (r && O.isString(r) && (s && !this.responseType || l)) { const u = !(i && i.silentJSONParsing) && l; try { return JSON.parse(r) } catch (h) { if (u) throw h.name === "SyntaxError" ? oe.from(h, oe.ERR_BAD_RESPONSE, this, null, this.response) : h } } return r }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Xe.classes.FormData, Blob: Xe.classes.Blob }, validateStatus: function (r) { return r >= 200 && r < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; O.forEach(["delete", "get", "head", "post", "put", "patch"], t => { eo.headers[t] = {} }); const iT = O.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), oT = t => {
  const r = {}; let i, s, l; return t && t.split(`
`).forEach(function (u) { l = u.indexOf(":"), i = u.substring(0, l).trim().toLowerCase(), s = u.substring(l + 1).trim(), !(!i || r[i] && iT[i]) && (i === "set-cookie" ? r[i] ? r[i].push(s) : r[i] = [s] : r[i] = r[i] ? r[i] + ", " + s : s) }), r
}, gm = Symbol("internals"); function Vi(t) { return t && String(t).trim().toLowerCase() } function Ts(t) { return t === !1 || t == null ? t : O.isArray(t) ? t.map(Ts) : String(t) } function sT(t) { const r = Object.create(null), i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let s; for (; s = i.exec(t);)r[s[1]] = s[2]; return r } const aT = t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim()); function gu(t, r, i, s, l) { if (O.isFunction(s)) return s.call(this, r, i); if (l && (r = i), !!O.isString(r)) { if (O.isString(s)) return r.indexOf(s) !== -1; if (O.isRegExp(s)) return s.test(r) } } function lT(t) { return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (r, i, s) => i.toUpperCase() + s) } function uT(t, r) { const i = O.toCamelCase(" " + r);["get", "set", "has"].forEach(s => { Object.defineProperty(t, s + i, { value: function (l, f, u) { return this[s].call(this, r, l, f, u) }, configurable: !0 }) }) } class ct {
  constructor(r) { r && this.set(r) } set(r, i, s) { const l = this; function f(h, p, m) { const y = Vi(p); if (!y) throw new Error("header name must be a non-empty string"); const v = O.findKey(l, y); (!v || l[v] === void 0 || m === !0 || m === void 0 && l[v] !== !1) && (l[v || p] = Ts(h)) } const u = (h, p) => O.forEach(h, (m, y) => f(m, y, p)); if (O.isPlainObject(r) || r instanceof this.constructor) u(r, i); else if (O.isString(r) && (r = r.trim()) && !aT(r)) u(oT(r), i); else if (O.isHeaders(r)) for (const [h, p] of r.entries()) f(p, h, s); else r != null && f(i, r, s); return this } get(r, i) { if (r = Vi(r), r) { const s = O.findKey(this, r); if (s) { const l = this[s]; if (!i) return l; if (i === !0) return sT(l); if (O.isFunction(i)) return i.call(this, l, s); if (O.isRegExp(i)) return i.exec(l); throw new TypeError("parser must be boolean|regexp|function") } } } has(r, i) { if (r = Vi(r), r) { const s = O.findKey(this, r); return !!(s && this[s] !== void 0 && (!i || gu(this, this[s], s, i))) } return !1 } delete(r, i) { const s = this; let l = !1; function f(u) { if (u = Vi(u), u) { const h = O.findKey(s, u); h && (!i || gu(s, s[h], h, i)) && (delete s[h], l = !0) } } return O.isArray(r) ? r.forEach(f) : f(r), l } clear(r) { const i = Object.keys(this); let s = i.length, l = !1; for (; s--;) { const f = i[s]; (!r || gu(this, this[f], f, r, !0)) && (delete this[f], l = !0) } return l } normalize(r) { const i = this, s = {}; return O.forEach(this, (l, f) => { const u = O.findKey(s, f); if (u) { i[u] = Ts(l), delete i[f]; return } const h = r ? lT(f) : String(f).trim(); h !== f && delete i[f], i[h] = Ts(l), s[h] = !0 }), this } concat(...r) { return this.constructor.concat(this, ...r) } toJSON(r) { const i = Object.create(null); return O.forEach(this, (s, l) => { s != null && s !== !1 && (i[l] = r && O.isArray(s) ? s.join(", ") : s) }), i } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
    return Object.entries(this.toJSON()).map(([r, i]) => r + ": " + i).join(`
`)
  } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(r) { return r instanceof this ? r : new this(r) } static concat(r, ...i) { const s = new this(r); return i.forEach(l => s.set(l)), s } static accessor(r) { const s = (this[gm] = this[gm] = { accessors: {} }).accessors, l = this.prototype; function f(u) { const h = Vi(u); s[h] || (uT(l, u), s[h] = !0) } return O.isArray(r) ? r.forEach(f) : f(r), this }
} ct.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); O.reduceDescriptors(ct.prototype, ({ value: t }, r) => { let i = r[0].toUpperCase() + r.slice(1); return { get: () => t, set(s) { this[i] = s } } }); O.freezeMethods(ct); function vu(t, r) { const i = this || eo, s = r || i, l = ct.from(s.headers); let f = s.data; return O.forEach(t, function (h) { f = h.call(i, f, l.normalize(), r ? r.status : void 0) }), l.normalize(), f } function Mg(t) { return !!(t && t.__CANCEL__) } function Kr(t, r, i) { oe.call(this, t ?? "canceled", oe.ERR_CANCELED, r, i), this.name = "CanceledError" } O.inherits(Kr, oe, { __CANCEL__: !0 }); function Og(t, r, i) { const s = i.config.validateStatus; !i.status || !s || s(i.status) ? t(i) : r(new oe("Request failed with status code " + i.status, [oe.ERR_BAD_REQUEST, oe.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4], i.config, i.request, i)) } function cT(t) { const r = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t); return r && r[1] || "" } function fT(t, r) { t = t || 10; const i = new Array(t), s = new Array(t); let l = 0, f = 0, u; return r = r !== void 0 ? r : 1e3, function (p) { const m = Date.now(), y = s[f]; u || (u = m), i[l] = p, s[l] = m; let v = f, w = 0; for (; v !== l;)w += i[v++], v = v % t; if (l = (l + 1) % t, l === f && (f = (f + 1) % t), m - u < r) return; const C = y && m - y; return C ? Math.round(w * 1e3 / C) : void 0 } } function dT(t, r) { let i = 0, s = 1e3 / r, l, f; const u = (m, y = Date.now()) => { i = y, l = null, f && (clearTimeout(f), f = null), t.apply(null, m) }; return [(...m) => { const y = Date.now(), v = y - i; v >= s ? u(m, y) : (l = m, f || (f = setTimeout(() => { f = null, u(l) }, s - v))) }, () => l && u(l)] } const js = (t, r, i = 3) => { let s = 0; const l = fT(50, 250); return dT(f => { const u = f.loaded, h = f.lengthComputable ? f.total : void 0, p = u - s, m = l(p), y = u <= h; s = u; const v = { loaded: u, total: h, progress: h ? u / h : void 0, bytes: p, rate: m || void 0, estimated: m && h && y ? (h - u) / m : void 0, event: f, lengthComputable: h != null, [r ? "download" : "upload"]: !0 }; t(v) }, i) }, vm = (t, r) => { const i = t != null; return [s => r[0]({ lengthComputable: i, total: t, loaded: s }), r[1]] }, wm = t => (...r) => O.asap(() => t(...r)), hT = Xe.hasStandardBrowserEnv ? ((t, r) => i => (i = new URL(i, Xe.origin), t.protocol === i.protocol && t.host === i.host && (r || t.port === i.port)))(new URL(Xe.origin), Xe.navigator && /(msie|trident)/i.test(Xe.navigator.userAgent)) : () => !0, pT = Xe.hasStandardBrowserEnv ? { write(t, r, i, s, l, f) { const u = [t + "=" + encodeURIComponent(r)]; O.isNumber(i) && u.push("expires=" + new Date(i).toGMTString()), O.isString(s) && u.push("path=" + s), O.isString(l) && u.push("domain=" + l), f === !0 && u.push("secure"), document.cookie = u.join("; ") }, read(t) { const r = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")); return r ? decodeURIComponent(r[3]) : null }, remove(t) { this.write(t, "", Date.now() - 864e5) } } : { write() { }, read() { return null }, remove() { } }; function mT(t) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) } function yT(t, r) { return r ? t.replace(/\/?\/$/, "") + "/" + r.replace(/^\/+/, "") : t } function Ng(t, r) { return t && !mT(r) ? yT(t, r) : r } const xm = t => t instanceof ct ? { ...t } : t; function ir(t, r) { r = r || {}; const i = {}; function s(m, y, v, w) { return O.isPlainObject(m) && O.isPlainObject(y) ? O.merge.call({ caseless: w }, m, y) : O.isPlainObject(y) ? O.merge({}, y) : O.isArray(y) ? y.slice() : y } function l(m, y, v, w) { if (O.isUndefined(y)) { if (!O.isUndefined(m)) return s(void 0, m, v, w) } else return s(m, y, v, w) } function f(m, y) { if (!O.isUndefined(y)) return s(void 0, y) } function u(m, y) { if (O.isUndefined(y)) { if (!O.isUndefined(m)) return s(void 0, m) } else return s(void 0, y) } function h(m, y, v) { if (v in r) return s(m, y); if (v in t) return s(void 0, m) } const p = { url: f, method: f, data: f, baseURL: u, transformRequest: u, transformResponse: u, paramsSerializer: u, timeout: u, timeoutMessage: u, withCredentials: u, withXSRFToken: u, adapter: u, responseType: u, xsrfCookieName: u, xsrfHeaderName: u, onUploadProgress: u, onDownloadProgress: u, decompress: u, maxContentLength: u, maxBodyLength: u, beforeRedirect: u, transport: u, httpAgent: u, httpsAgent: u, cancelToken: u, socketPath: u, responseEncoding: u, validateStatus: h, headers: (m, y, v) => l(xm(m), xm(y), v, !0) }; return O.forEach(Object.keys(Object.assign({}, t, r)), function (y) { const v = p[y] || l, w = v(t[y], r[y], y); O.isUndefined(w) && v !== h || (i[y] = w) }), i } const Fg = t => { const r = ir({}, t); let { data: i, withXSRFToken: s, xsrfHeaderName: l, xsrfCookieName: f, headers: u, auth: h } = r; r.headers = u = ct.from(u), r.url = Lg(Ng(r.baseURL, r.url), t.params, t.paramsSerializer), h && u.set("Authorization", "Basic " + btoa((h.username || "") + ":" + (h.password ? unescape(encodeURIComponent(h.password)) : ""))); let p; if (O.isFormData(i)) { if (Xe.hasStandardBrowserEnv || Xe.hasStandardBrowserWebWorkerEnv) u.setContentType(void 0); else if ((p = u.getContentType()) !== !1) { const [m, ...y] = p ? p.split(";").map(v => v.trim()).filter(Boolean) : []; u.setContentType([m || "multipart/form-data", ...y].join("; ")) } } if (Xe.hasStandardBrowserEnv && (s && O.isFunction(s) && (s = s(r)), s || s !== !1 && hT(r.url))) { const m = l && f && pT.read(f); m && u.set(l, m) } return r }, gT = typeof XMLHttpRequest < "u", vT = gT && function (t) { return new Promise(function (i, s) { const l = Fg(t); let f = l.data; const u = ct.from(l.headers).normalize(); let { responseType: h, onUploadProgress: p, onDownloadProgress: m } = l, y, v, w, C, S; function R() { C && C(), S && S(), l.cancelToken && l.cancelToken.unsubscribe(y), l.signal && l.signal.removeEventListener("abort", y) } let P = new XMLHttpRequest; P.open(l.method.toUpperCase(), l.url, !0), P.timeout = l.timeout; function A() { if (!P) return; const F = ct.from("getAllResponseHeaders" in P && P.getAllResponseHeaders()), z = { data: !h || h === "text" || h === "json" ? P.responseText : P.response, status: P.status, statusText: P.statusText, headers: F, config: t, request: P }; Og(function (ne) { i(ne), R() }, function (ne) { s(ne), R() }, z), P = null } "onloadend" in P ? P.onloadend = A : P.onreadystatechange = function () { !P || P.readyState !== 4 || P.status === 0 && !(P.responseURL && P.responseURL.indexOf("file:") === 0) || setTimeout(A) }, P.onabort = function () { P && (s(new oe("Request aborted", oe.ECONNABORTED, t, P)), P = null) }, P.onerror = function () { s(new oe("Network Error", oe.ERR_NETWORK, t, P)), P = null }, P.ontimeout = function () { let b = l.timeout ? "timeout of " + l.timeout + "ms exceeded" : "timeout exceeded"; const z = l.transitional || Dg; l.timeoutErrorMessage && (b = l.timeoutErrorMessage), s(new oe(b, z.clarifyTimeoutError ? oe.ETIMEDOUT : oe.ECONNABORTED, t, P)), P = null }, f === void 0 && u.setContentType(null), "setRequestHeader" in P && O.forEach(u.toJSON(), function (b, z) { P.setRequestHeader(z, b) }), O.isUndefined(l.withCredentials) || (P.withCredentials = !!l.withCredentials), h && h !== "json" && (P.responseType = l.responseType), m && ([w, S] = js(m, !0), P.addEventListener("progress", w)), p && P.upload && ([v, C] = js(p), P.upload.addEventListener("progress", v), P.upload.addEventListener("loadend", C)), (l.cancelToken || l.signal) && (y = F => { P && (s(!F || F.type ? new Kr(null, t, P) : F), P.abort(), P = null) }, l.cancelToken && l.cancelToken.subscribe(y), l.signal && (l.signal.aborted ? y() : l.signal.addEventListener("abort", y))); const N = cT(l.url); if (N && Xe.protocols.indexOf(N) === -1) { s(new oe("Unsupported protocol " + N + ":", oe.ERR_BAD_REQUEST, t)); return } P.send(f || null) }) }, wT = (t, r) => { const { length: i } = t = t ? t.filter(Boolean) : []; if (r || i) { let s = new AbortController, l; const f = function (m) { if (!l) { l = !0, h(); const y = m instanceof Error ? m : this.reason; s.abort(y instanceof oe ? y : new Kr(y instanceof Error ? y.message : y)) } }; let u = r && setTimeout(() => { u = null, f(new oe(`timeout ${r} of ms exceeded`, oe.ETIMEDOUT)) }, r); const h = () => { t && (u && clearTimeout(u), u = null, t.forEach(m => { m.unsubscribe ? m.unsubscribe(f) : m.removeEventListener("abort", f) }), t = null) }; t.forEach(m => m.addEventListener("abort", f)); const { signal: p } = s; return p.unsubscribe = () => O.asap(h), p } }, xT = function* (t, r) { let i = t.byteLength; if (i < r) { yield t; return } let s = 0, l; for (; s < i;)l = s + r, yield t.slice(s, l), s = l }, ST = async function* (t, r) { for await (const i of ET(t)) yield* xT(i, r) }, ET = async function* (t) { if (t[Symbol.asyncIterator]) { yield* t; return } const r = t.getReader(); try { for (; ;) { const { done: i, value: s } = await r.read(); if (i) break; yield s } } finally { await r.cancel() } }, Sm = (t, r, i, s) => { const l = ST(t, r); let f = 0, u, h = p => { u || (u = !0, s && s(p)) }; return new ReadableStream({ async pull(p) { try { const { done: m, value: y } = await l.next(); if (m) { h(), p.close(); return } let v = y.byteLength; if (i) { let w = f += v; i(w) } p.enqueue(new Uint8Array(y)) } catch (m) { throw h(m), m } }, cancel(p) { return h(p), l.return() } }, { highWaterMark: 2 }) }, Js = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", Vg = Js && typeof ReadableStream == "function", PT = Js && (typeof TextEncoder == "function" ? (t => r => t.encode(r))(new TextEncoder) : async t => new Uint8Array(await new Response(t).arrayBuffer())), jg = (t, ...r) => { try { return !!t(...r) } catch { return !1 } }, CT = Vg && jg(() => { let t = !1; const r = new Request(Xe.origin, { body: new ReadableStream, method: "POST", get duplex() { return t = !0, "half" } }).headers.has("Content-Type"); return t && !r }), Em = 64 * 1024, bu = Vg && jg(() => O.isReadableStream(new Response("").body)), Is = { stream: bu && (t => t.body) }; Js && (t => { ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(r => { !Is[r] && (Is[r] = O.isFunction(t[r]) ? i => i[r]() : (i, s) => { throw new oe(`Response type '${r}' is not supported`, oe.ERR_NOT_SUPPORT, s) }) }) })(new Response); const TT = async t => { if (t == null) return 0; if (O.isBlob(t)) return t.size; if (O.isSpecCompliantForm(t)) return (await new Request(Xe.origin, { method: "POST", body: t }).arrayBuffer()).byteLength; if (O.isArrayBufferView(t) || O.isArrayBuffer(t)) return t.byteLength; if (O.isURLSearchParams(t) && (t = t + ""), O.isString(t)) return (await PT(t)).byteLength }, kT = async (t, r) => { const i = O.toFiniteNumber(t.getContentLength()); return i ?? TT(r) }, RT = Js && (async t => { let { url: r, method: i, data: s, signal: l, cancelToken: f, timeout: u, onDownloadProgress: h, onUploadProgress: p, responseType: m, headers: y, withCredentials: v = "same-origin", fetchOptions: w } = Fg(t); m = m ? (m + "").toLowerCase() : "text"; let C = wT([l, f && f.toAbortSignal()], u), S; const R = C && C.unsubscribe && (() => { C.unsubscribe() }); let P; try { if (p && CT && i !== "get" && i !== "head" && (P = await kT(y, s)) !== 0) { let z = new Request(r, { method: "POST", body: s, duplex: "half" }), Y; if (O.isFormData(s) && (Y = z.headers.get("content-type")) && y.setContentType(Y), z.body) { const [ne, Q] = vm(P, js(wm(p))); s = Sm(z.body, Em, ne, Q) } } O.isString(v) || (v = v ? "include" : "omit"); const A = "credentials" in Request.prototype; S = new Request(r, { ...w, signal: C, method: i.toUpperCase(), headers: y.normalize().toJSON(), body: s, duplex: "half", credentials: A ? v : void 0 }); let N = await fetch(S); const F = bu && (m === "stream" || m === "response"); if (bu && (h || F && R)) { const z = {};["status", "statusText", "headers"].forEach(se => { z[se] = N[se] }); const Y = O.toFiniteNumber(N.headers.get("content-length")), [ne, Q] = h && vm(Y, js(wm(h), !0)) || []; N = new Response(Sm(N.body, Em, ne, () => { Q && Q(), R && R() }), z) } m = m || "text"; let b = await Is[O.findKey(Is, m) || "text"](N, t); return !F && R && R(), await new Promise((z, Y) => { Og(z, Y, { data: b, headers: ct.from(N.headers), status: N.status, statusText: N.statusText, config: t, request: S }) }) } catch (A) { throw R && R(), A && A.name === "TypeError" && /fetch/i.test(A.message) ? Object.assign(new oe("Network Error", oe.ERR_NETWORK, t, S), { cause: A.cause || A }) : oe.from(A, A && A.code, t, S) } }), $u = { http: bC, xhr: vT, fetch: RT }; O.forEach($u, (t, r) => { if (t) { try { Object.defineProperty(t, "name", { value: r }) } catch { } Object.defineProperty(t, "adapterName", { value: r }) } }); const Pm = t => `- ${t}`, AT = t => O.isFunction(t) || t === null || t === !1, Ig = {
  getAdapter: t => {
    t = O.isArray(t) ? t : [t]; const { length: r } = t; let i, s; const l = {}; for (let f = 0; f < r; f++) { i = t[f]; let u; if (s = i, !AT(i) && (s = $u[(u = String(i)).toLowerCase()], s === void 0)) throw new oe(`Unknown adapter '${u}'`); if (s) break; l[u || "#" + f] = s } if (!s) {
      const f = Object.entries(l).map(([h, p]) => `adapter ${h} ` + (p === !1 ? "is not supported by the environment" : "is not available in the build")); let u = r ? f.length > 1 ? `since :
`+ f.map(Pm).join(`
`) : " " + Pm(f[0]) : "as no adapter specified"; throw new oe("There is no suitable adapter to dispatch the request " + u, "ERR_NOT_SUPPORT")
    } return s
  }, adapters: $u
}; function wu(t) { if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new Kr(null, t) } function Cm(t) { return wu(t), t.headers = ct.from(t.headers), t.data = vu.call(t, t.transformRequest), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), Ig.getAdapter(t.adapter || eo.adapter)(t).then(function (s) { return wu(t), s.data = vu.call(t, t.transformResponse, s), s.headers = ct.from(s.headers), s }, function (s) { return Mg(s) || (wu(t), s && s.response && (s.response.data = vu.call(t, t.transformResponse, s.response), s.response.headers = ct.from(s.response.headers))), Promise.reject(s) }) } const Bg = "1.7.8", Zs = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((t, r) => { Zs[t] = function (s) { return typeof s === t || "a" + (r < 1 ? "n " : " ") + t } }); const Tm = {}; Zs.transitional = function (r, i, s) { function l(f, u) { return "[Axios v" + Bg + "] Transitional option '" + f + "'" + u + (s ? ". " + s : "") } return (f, u, h) => { if (r === !1) throw new oe(l(u, " has been removed" + (i ? " in " + i : "")), oe.ERR_DEPRECATED); return i && !Tm[u] && (Tm[u] = !0, console.warn(l(u, " has been deprecated since v" + i + " and will be removed in the near future"))), r ? r(f, u, h) : !0 } }; Zs.spelling = function (r) { return (i, s) => (console.warn(`${s} is likely a misspelling of ${r}`), !0) }; function LT(t, r, i) { if (typeof t != "object") throw new oe("options must be an object", oe.ERR_BAD_OPTION_VALUE); const s = Object.keys(t); let l = s.length; for (; l-- > 0;) { const f = s[l], u = r[f]; if (u) { const h = t[f], p = h === void 0 || u(h, f, t); if (p !== !0) throw new oe("option " + f + " must be " + p, oe.ERR_BAD_OPTION_VALUE); continue } if (i !== !0) throw new oe("Unknown option " + f, oe.ERR_BAD_OPTION) } } const ks = { assertOptions: LT, validators: Zs }, $t = ks.validators; class rr {
  constructor(r) { this.defaults = r, this.interceptors = { request: new ym, response: new ym } } async request(r, i) {
    try { return await this._request(r, i) } catch (s) {
      if (s instanceof Error) {
        let l = {}; Error.captureStackTrace ? Error.captureStackTrace(l) : l = new Error; const f = l.stack ? l.stack.replace(/^.+\n/, "") : ""; try {
          s.stack ? f && !String(s.stack).endsWith(f.replace(/^.+\n.+\n/, "")) && (s.stack += `
`+ f) : s.stack = f
        } catch { }
      } throw s
    }
  } _request(r, i) { typeof r == "string" ? (i = i || {}, i.url = r) : i = r || {}, i = ir(this.defaults, i); const { transitional: s, paramsSerializer: l, headers: f } = i; s !== void 0 && ks.assertOptions(s, { silentJSONParsing: $t.transitional($t.boolean), forcedJSONParsing: $t.transitional($t.boolean), clarifyTimeoutError: $t.transitional($t.boolean) }, !1), l != null && (O.isFunction(l) ? i.paramsSerializer = { serialize: l } : ks.assertOptions(l, { encode: $t.function, serialize: $t.function }, !0)), ks.assertOptions(i, { baseUrl: $t.spelling("baseURL"), withXsrfToken: $t.spelling("withXSRFToken") }, !0), i.method = (i.method || this.defaults.method || "get").toLowerCase(); let u = f && O.merge(f.common, f[i.method]); f && O.forEach(["delete", "get", "head", "post", "put", "patch", "common"], S => { delete f[S] }), i.headers = ct.concat(u, f); const h = []; let p = !0; this.interceptors.request.forEach(function (R) { typeof R.runWhen == "function" && R.runWhen(i) === !1 || (p = p && R.synchronous, h.unshift(R.fulfilled, R.rejected)) }); const m = []; this.interceptors.response.forEach(function (R) { m.push(R.fulfilled, R.rejected) }); let y, v = 0, w; if (!p) { const S = [Cm.bind(this), void 0]; for (S.unshift.apply(S, h), S.push.apply(S, m), w = S.length, y = Promise.resolve(i); v < w;)y = y.then(S[v++], S[v++]); return y } w = h.length; let C = i; for (v = 0; v < w;) { const S = h[v++], R = h[v++]; try { C = S(C) } catch (P) { R.call(this, P); break } } try { y = Cm.call(this, C) } catch (S) { return Promise.reject(S) } for (v = 0, w = m.length; v < w;)y = y.then(m[v++], m[v++]); return y } getUri(r) { r = ir(this.defaults, r); const i = Ng(r.baseURL, r.url); return Lg(i, r.params, r.paramsSerializer) }
} O.forEach(["delete", "get", "head", "options"], function (r) { rr.prototype[r] = function (i, s) { return this.request(ir(s || {}, { method: r, url: i, data: (s || {}).data })) } }); O.forEach(["post", "put", "patch"], function (r) { function i(s) { return function (f, u, h) { return this.request(ir(h || {}, { method: r, headers: s ? { "Content-Type": "multipart/form-data" } : {}, url: f, data: u })) } } rr.prototype[r] = i(), rr.prototype[r + "Form"] = i(!0) }); class jc { constructor(r) { if (typeof r != "function") throw new TypeError("executor must be a function."); let i; this.promise = new Promise(function (f) { i = f }); const s = this; this.promise.then(l => { if (!s._listeners) return; let f = s._listeners.length; for (; f-- > 0;)s._listeners[f](l); s._listeners = null }), this.promise.then = l => { let f; const u = new Promise(h => { s.subscribe(h), f = h }).then(l); return u.cancel = function () { s.unsubscribe(f) }, u }, r(function (f, u, h) { s.reason || (s.reason = new Kr(f, u, h), i(s.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(r) { if (this.reason) { r(this.reason); return } this._listeners ? this._listeners.push(r) : this._listeners = [r] } unsubscribe(r) { if (!this._listeners) return; const i = this._listeners.indexOf(r); i !== -1 && this._listeners.splice(i, 1) } toAbortSignal() { const r = new AbortController, i = s => { r.abort(s) }; return this.subscribe(i), r.signal.unsubscribe = () => this.unsubscribe(i), r.signal } static source() { let r; return { token: new jc(function (l) { r = l }), cancel: r } } } function DT(t) { return function (i) { return t.apply(null, i) } } function _T(t) { return O.isObject(t) && t.isAxiosError === !0 } const Hu = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(Hu).forEach(([t, r]) => { Hu[r] = t }); function zg(t) { const r = new rr(t), i = gg(rr.prototype.request, r); return O.extend(i, rr.prototype, r, { allOwnKeys: !0 }), O.extend(i, r, null, { allOwnKeys: !0 }), i.create = function (l) { return zg(ir(t, l)) }, i } const Fe = zg(eo); Fe.Axios = rr; Fe.CanceledError = Kr; Fe.CancelToken = jc; Fe.isCancel = Mg; Fe.VERSION = Bg; Fe.toFormData = Ys; Fe.AxiosError = oe; Fe.Cancel = Fe.CanceledError; Fe.all = function (r) { return Promise.all(r) }; Fe.spread = DT; Fe.isAxiosError = _T; Fe.mergeConfig = ir; Fe.AxiosHeaders = ct; Fe.formToJSON = t => _g(O.isHTMLForm(t) ? new FormData(t) : t); Fe.getAdapter = Ig.getAdapter; Fe.HttpStatusCode = Hu; Fe.default = Fe; const MT = () => { const { userDetail: t, logout: r } = k.useContext(Oc), [i, s] = k.useState(!1), [l, f] = k.useState(!1), u = Qu(), h = async () => { f(!0); try { await Fe.post("https://vrv-security-rbac-task-round.vercel.app/logout", {}, { headers: { "Content-Type": "application/json" }, withCredentials: !0 }), r(), u("/login") } catch (m) { console.error("Logout failed", m) } finally { f(!1) } }, p = ({ mobile: m = !1 }) => { const y = m ? "group flex items-center space-x-3 p-3 rounded-lg transition-all duration-300 hover:bg-blue-50 hover:text-blue-600" : "group flex items-center space-x-2 px-3 py-2 rounded-md transition-all duration-300 hover:bg-blue-50 hover:text-blue-600", v = "text-gray-500 group-hover:text-blue-600 transition-colors"; return H.jsxs(gs.div, { initial: { opacity: 0, y: m ? 20 : 0 }, animate: { opacity: 1, y: 0 }, exit: { opacity: 0, y: m ? 20 : 0 }, transition: { duration: .3 }, className: m ? "flex flex-col items-center justify-center space-y-4 h-full w-full p-6" : "flex space-x-2 items-center", children: [[{ to: "/", label: "Home", icon: Dw }, ...(t == null ? void 0 : t.role) === "admin" ? [{ to: "/admin-dashboard", label: "Dashboard", icon: Nw }] : [], ...t ? [{ to: "/profile", label: "Profile", icon: Vw }, ...t.role !== "admin" ? [{ to: "/create-post", label: "Create", icon: Lw }] : []] : [], ...t ? [] : [{ to: "/login", label: "Login", icon: _w }, { to: "/signup", label: "Sign Up", icon: Fw }]].map(({ to: w, label: C, icon: S }) => H.jsxs(As, { to: w, onClick: () => m && s(!1), className: y, children: [H.jsx(S, { className: v }), H.jsx("span", { children: C })] }, w)), t && H.jsxs("button", { onClick: h, disabled: l, className: `${y} text-red-500 hover:text-red-700`, children: [l ? H.jsx(zm, { className: "animate-spin" }) : H.jsx(Mw, {}), H.jsx("span", { children: "Logout" })] })] }) }; return H.jsxs(gs.nav, { initial: { opacity: 0 }, animate: { opacity: 1 }, transition: { duration: .5 }, className: "bg-white/90 backdrop-blur-xl shadow-lg fixed top-0 left-0 right-0 z-50", children: [H.jsx("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: H.jsxs("div", { className: "flex items-center justify-between h-16", children: [H.jsx(As, { to: "/", className: "text-2xl font-bold  text-blue-600  hover:scale-105 transition-transform", children: "VRV" }), H.jsx("div", { className: "hidden md:flex space-x-2 items-center", children: H.jsx(p, {}) }), H.jsx("div", { className: "md:hidden", children: H.jsx(gs.button, { whileTap: { scale: .9 }, onClick: () => s(!i), className: "text-gray-800 hover:text-blue-600 focus:outline-none", children: i ? H.jsx(jw, { size: 24 }) : H.jsx(Ow, { size: 24 }) }) })] }) }), H.jsx(nC, { children: i && H.jsx(gs.div, { initial: { opacity: 0, x: "-100%" }, animate: { opacity: 1, x: 0 }, exit: { opacity: 0, x: "-100%" }, transition: { type: "tween", duration: .3 }, className: "md:hidden bg-white/95 backdrop-blur-xl z-40 flex flex-col items-center justify-center min-h-screen", children: H.jsx(p, { mobile: !0 }) }) })] }) }, Mr = ({ children: t }) => { const { userDetail: r } = k.useContext(Oc), [i, s] = k.useState(!0); return k.useEffect(() => { const l = setTimeout(() => { s(!1) }, 200); return () => clearTimeout(l) }, []), i ? H.jsx(Um, {}) : r ? H.jsx(H.Fragment, { children: t }) : H.jsx(z1, { to: "/login", replace: !0 }) }; Mr.propTypes = { children: Ls.node.isRequired }; const OT = k.lazy(() => or(() => import("./Login-BGRZ3ENH.js"), __vite__mapDeps([0, 1, 2]))), NT = k.lazy(() => or(() => import("./Signup-BPlnPFWT.js"), __vite__mapDeps([3, 1]))), FT = k.lazy(() => or(() => import("./Home-CxFjwrMi.js"), __vite__mapDeps([4, 5, 6]))), VT = k.lazy(() => or(() => import("./Profile-BklSzYE6.js"), __vite__mapDeps([7, 2]))), jT = k.lazy(() => or(() => import("./AdminDashboard-DNovdMO1.js"), __vite__mapDeps([8, 5, 6]))), IT = k.lazy(() => or(() => import("./CreatePost-CG8DdBcO.js"), [])), BT = k.lazy(() => or(() => import("./PostDetail-C3Av3PFg.js"), __vite__mapDeps([9, 6]))); function Dn({ error: t, resetErrorBoundary: r }) { return H.jsx("div", { role: "alert", className: "min-h-screen bg-red-50 flex items-center justify-center p-4", children: H.jsxs("div", { className: "bg-white rounded-xl shadow-2xl p-8 max-w-md text-center", children: [H.jsx("h2", { className: "text-2xl font-bold text-red-600 mb-4", children: "Something went wrong" }), H.jsx("pre", { className: "text-gray-700 mb-4 overflow-x-auto", children: t.message }), H.jsx("button", { onClick: r, className: "bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition", children: "Try again" })] }) }) } function zT() { return H.jsx(dw, { children: H.jsxs(tn, { FallbackComponent: Dn, children: [H.jsx(MT, {}), H.jsx(k.Suspense, { fallback: H.jsx(Um, {}), children: H.jsxs(b1, { children: [H.jsx(_n, { path: "/login", element: H.jsx(tn, { FallbackComponent: Dn, children: H.jsx(OT, {}) }) }), H.jsx(_n, { path: "/signup", element: H.jsx(tn, { FallbackComponent: Dn, children: H.jsx(NT, {}) }) }), H.jsx(_n, { path: "/", element: H.jsx(Mr, { children: H.jsx(tn, { FallbackComponent: Dn, children: H.jsx(FT, {}) }) }) }), H.jsx(_n, { path: "/profile", element: H.jsx(Mr, { children: H.jsx(tn, { FallbackComponent: Dn, children: H.jsx(VT, {}) }) }) }), H.jsx(_n, { path: "/admin-dashboard", element: H.jsx(Mr, { children: H.jsx(tn, { FallbackComponent: Dn, children: H.jsx(jT, {}) }) }) }), H.jsx(_n, { path: "/create-post", element: H.jsx(Mr, { children: H.jsx(tn, { FallbackComponent: Dn, children: H.jsx(IT, {}) }) }) }), H.jsx(_n, { path: "/post/:postId", element: H.jsx(Mr, { children: H.jsx(tn, { FallbackComponent: Dn, children: H.jsx(BT, {}) }) }) })] }) })] }) }) } G0.createRoot(document.getElementById("root")).render(H.jsx(k.StrictMode, { children: H.jsx(yg, { children: H.jsx(zT, {}) }) })); export { Oc as A, zm as L, Nw as S, Vw as U, k as a, Fe as b, Kt as c, bT as d, b0 as e, km as g, H as j, K0 as r, Qu as u };
